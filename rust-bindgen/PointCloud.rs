/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const EIGEN_CUDACC_VER: u32 = 0;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 9;
pub const __GLIBCXX__: u32 = 20210601;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_USE_STD_SPEC_FUNCS: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const __PSTL_USE_PAR_POLICIES: u32 = 1;
pub const PSTL_VERSION: u32 = 203;
pub const PSTL_VERSION_MAJOR: u32 = 2;
pub const PSTL_VERSION_MINOR: u32 = 3;
pub const __PSTL_PAR_BACKEND_TBB: u32 = 1;
pub const __PSTL_USAGE_WARNINGS: u32 = 0;
pub const __PSTL_UDR_PRESENT: u32 = 0;
pub const __PSTL_PRAGMA_LOCATION: &[u8; 26] = b" [Parallel STL message]: \0";
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EBADMSG: u32 = 1;
pub const _GLIBCXX_HAVE_ECANCELED: u32 = 1;
pub const _GLIBCXX_HAVE_ECHILD: u32 = 1;
pub const _GLIBCXX_HAVE_EIDRM: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENODATA: u32 = 1;
pub const _GLIBCXX_HAVE_ENOLINK: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSPC: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSTR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: u32 = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: u32 = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: u32 = 1;
pub const _GLIBCXX_HAVE_EPERM: u32 = 1;
pub const _GLIBCXX_HAVE_EPROTO: u32 = 1;
pub const _GLIBCXX_HAVE_ETIME: u32 = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: u32 = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: u32 = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const __EXCEPTION_H: u32 = 1;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _CXXABI_INIT_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_HAVE_CDTOR_CALLABI: u32 = 0;
pub const _HASH_BYTES_H: u32 = 1;
pub const __GXX_MERGED_TYPEINFO_NAMES: u32 = 0;
pub const __GXX_TYPEINFO_EQUALITY_INLINE: u32 = 1;
pub const _GLIBCXX_NESTED_EXCEPTION_H: u32 = 1;
pub const _MOVE_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _GLIBCXX_TYPE_TRAITS: u32 = 1;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_launder: u32 = 201606;
pub const EIGEN_WORLD_VERSION: u32 = 3;
pub const EIGEN_MAJOR_VERSION: u32 = 3;
pub const EIGEN_MINOR_VERSION: u32 = 7;
pub const EIGEN_COMP_GNUC: u32 = 1;
pub const EIGEN_COMP_LLVM: u32 = 1;
pub const EIGEN_COMP_ICC: u32 = 0;
pub const EIGEN_COMP_MINGW: u32 = 0;
pub const EIGEN_COMP_SUNCC: u32 = 0;
pub const EIGEN_COMP_MSVC: u32 = 0;
pub const EIGEN_COMP_MSVC_STRICT: u32 = 0;
pub const EIGEN_COMP_IBM: u32 = 0;
pub const EIGEN_COMP_PGI: u32 = 0;
pub const EIGEN_COMP_ARM: u32 = 0;
pub const EIGEN_COMP_EMSCRIPTEN: u32 = 0;
pub const EIGEN_COMP_GNUC_STRICT: u32 = 0;
pub const EIGEN_GCC3_OR_OLDER: u32 = 0;
pub const EIGEN_ARCH_x86_64: u32 = 1;
pub const EIGEN_ARCH_i386: u32 = 0;
pub const EIGEN_ARCH_i386_OR_x86_64: u32 = 1;
pub const EIGEN_ARCH_ARM: u32 = 0;
pub const EIGEN_ARCH_ARM64: u32 = 0;
pub const EIGEN_ARCH_ARM_OR_ARM64: u32 = 0;
pub const EIGEN_ARCH_MIPS: u32 = 0;
pub const EIGEN_ARCH_SPARC: u32 = 0;
pub const EIGEN_ARCH_IA64: u32 = 0;
pub const EIGEN_ARCH_PPC: u32 = 0;
pub const EIGEN_OS_UNIX: u32 = 1;
pub const EIGEN_OS_LINUX: u32 = 1;
pub const EIGEN_OS_ANDROID: u32 = 0;
pub const EIGEN_OS_GNULINUX: u32 = 1;
pub const EIGEN_OS_BSD: u32 = 0;
pub const EIGEN_OS_MAC: u32 = 0;
pub const EIGEN_OS_QNX: u32 = 0;
pub const EIGEN_OS_WIN: u32 = 0;
pub const EIGEN_OS_WIN64: u32 = 0;
pub const EIGEN_OS_WINCE: u32 = 0;
pub const EIGEN_OS_CYGWIN: u32 = 0;
pub const EIGEN_OS_WIN_STRICT: u32 = 0;
pub const EIGEN_OS_SUN: u32 = 0;
pub const EIGEN_OS_SOLARIS: u32 = 0;
pub const EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO: u32 = 1;
pub const EIGEN_MAX_CPP_VER: u32 = 99;
pub const EIGEN_HAS_CXX11: u32 = 1;
pub const EIGEN_HAS_RVALUE_REFERENCES: u32 = 1;
pub const EIGEN_HAS_C99_MATH: u32 = 1;
pub const EIGEN_HAS_STD_RESULT_OF: u32 = 1;
pub const EIGEN_HAS_VARIADIC_TEMPLATES: u32 = 1;
pub const EIGEN_HAS_CONSTEXPR: u32 = 1;
pub const EIGEN_HAS_CXX11_MATH: u32 = 1;
pub const EIGEN_HAS_CXX11_CONTAINERS: u32 = 1;
pub const EIGEN_HAS_CXX11_NOEXCEPT: u32 = 1;
pub const EIGEN_FAST_MATH: u32 = 1;
pub const EIGEN_IDEAL_MAX_ALIGN_BYTES: u32 = 16;
pub const EIGEN_MIN_ALIGN_BYTES: u32 = 16;
pub const EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT: u32 = 0;
pub const EIGEN_ARCH_WANTS_STACK_ALIGNMENT: u32 = 1;
pub const EIGEN_MAX_STATIC_ALIGN_BYTES: u32 = 16;
pub const EIGEN_MAX_ALIGN_BYTES: u32 = 16;
pub const EIGEN_DEFAULT_ALIGN_BYTES: u32 = 16;
pub const EIGEN_UNALIGNED_VECTORIZE: u32 = 1;
pub const EIGEN_STACK_ALLOCATION_LIMIT: u32 = 131072;
pub const _GLIBCXX_COMPLEX: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __FP_LONG_MAX: u64 = 9223372036854775807;
pub const FP_LLOGB0: i64 = -9223372036854775808;
pub const FP_LLOGBNAN: i64 = -9223372036854775808;
pub const FP_INT_UPWARD: u32 = 0;
pub const FP_INT_DOWNWARD: u32 = 1;
pub const FP_INT_TOWARDZERO: u32 = 2;
pub const FP_INT_TONEARESTFROMZERO: u32 = 3;
pub const FP_INT_TONEAREST: u32 = 4;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _GLIBCXX_CMATH: u32 = 1;
pub const __cpp_lib_hypot: u32 = 201603;
pub const _GLIBCXX_BITS_SPECFUN_H: u32 = 1;
pub const __STDCPP_MATH_SPEC_FUNCS__: u32 = 201003;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _GLIBCXX_DEBUG_ASSERTIONS_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const _GLIBCXX_DEBUG_MACRO_SWITCH_H: u32 = 1;
pub const _GLIBCXX_PREDEFINED_OPS_H: u32 = 1;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const _GLIBCXX_NUMERIC_LIMITS: u32 = 1;
pub const _GLIBCXX_TR1_GAMMA_TCC: u32 = 1;
pub const _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H: u32 = 1;
pub const _GLIBCXX_TR1_BESSEL_FUNCTION_TCC: u32 = 1;
pub const _GLIBCXX_TR1_BETA_FUNCTION_TCC: u32 = 1;
pub const _GLIBCXX_TR1_ELL_INTEGRAL_TCC: u32 = 1;
pub const _GLIBCXX_TR1_EXP_INTEGRAL_TCC: u32 = 1;
pub const _GLIBCXX_TR1_HYPERGEOMETRIC_TCC: u32 = 1;
pub const _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC: u32 = 1;
pub const _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC: u32 = 1;
pub const _GLIBCXX_TR1_POLY_HERMITE_TCC: u32 = 1;
pub const _GLIBCXX_TR1_POLY_LAGUERRE_TCC: u32 = 1;
pub const _GLIBCXX_TR1_RIEMANN_ZETA_TCC: u32 = 1;
pub const _GLIBCXX_SSTREAM: u32 = 1;
pub const _GLIBCXX_ISTREAM: u32 = 1;
pub const _GLIBCXX_IOS: u32 = 1;
pub const _GLIBCXX_IOSFWD: u32 = 1;
pub const _STRINGFWD_H: u32 = 1;
pub const _MEMORYFWD_H: u32 = 1;
pub const _GLIBCXX_POSTYPES_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _GLIBCXX_CWCHAR: u32 = 1;
pub const _CHAR_TRAITS_H: u32 = 1;
pub const __cpp_lib_constexpr_char_traits: u32 = 201611;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _LOCALE_FWD_H: u32 = 1;
pub const _GLIBCXX_CXX_LOCALE_H: u32 = 1;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const _GLIBCXX_CLOCALE: u32 = 1;
pub const _GLIBCXX_C_LOCALE_GNU: u32 = 1;
pub const _GLIBCXX_NUM_CATEGORIES: u32 = 6;
pub const _CTYPE_H: u32 = 1;
pub const _GLIBCXX_CCTYPE: u32 = 1;
pub const _IOS_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMICITY_H: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 1;
pub const __GTHREADS: u32 = 1;
pub const __GTHREADS_CXX0X: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __GTHREAD_HAS_COND: u32 = 1;
pub const __GTHREAD_ONCE_INIT: u32 = 0;
pub const _GLIBCXX_ATOMIC_WORD_H: u32 = 1;
pub const _LOCALE_CLASSES_H: u32 = 1;
pub const _GLIBCXX_STRING: u32 = 1;
pub const _ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_CXX_ALLOCATOR_H: u32 = 1;
pub const _NEW_ALLOCATOR_H: u32 = 1;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_allocator_is_always_equal: u32 = 201411;
pub const _OSTREAM_INSERT_H: u32 = 1;
pub const _CXXABI_FORCED_H: u32 = 1;
pub const _STL_FUNCTION_H: u32 = 1;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const _BACKWARD_BINDERS_H: u32 = 1;
pub const _GLIBCXX_RANGE_ACCESS_H: u32 = 1;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const _BASIC_STRING_H: u32 = 1;
pub const _EXT_ALLOC_TRAITS_H: u32 = 1;
pub const _ALLOC_TRAITS_H: u32 = 1;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const _GLIBCXX_STRING_VIEW: u32 = 1;
pub const _FUNCTIONAL_HASH_H: u32 = 1;
pub const __cpp_lib_string_view: u32 = 201803;
pub const _GLIBCXX_STRING_VIEW_TCC: u32 = 1;
pub const __cpp_lib_constexpr_string: u32 = 201611;
pub const _STRING_CONVERSIONS_H: u32 = 1;
pub const _GLIBCXX_CSTDLIB: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _GLIBCXX_CERRNO: u32 = 1;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const _BASIC_STRING_TCC: u32 = 1;
pub const _LOCALE_CLASSES_TCC: u32 = 1;
pub const _GLIBCXX_SYSTEM_ERROR: u32 = 1;
pub const _GLIBCXX_ERROR_CONSTANTS: u32 = 1;
pub const _GLIBCXX_STDEXCEPT: u32 = 1;
pub const _GLIBXX_STREAMBUF: u32 = 1;
pub const _STREAMBUF_TCC: u32 = 1;
pub const _BASIC_IOS_H: u32 = 1;
pub const _LOCALE_FACETS_H: u32 = 1;
pub const _WCTYPE_H: u32 = 1;
pub const _BITS_WCTYPE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_CWCTYPE: u32 = 1;
pub const _STREAMBUF_ITERATOR_H: u32 = 1;
pub const _GLIBCXX_NUM_FACETS: u32 = 28;
pub const _GLIBCXX_NUM_CXX11_FACETS: u32 = 16;
pub const _GLIBCXX_NUM_UNICODE_FACETS: u32 = 2;
pub const _LOCALE_FACETS_TCC: u32 = 1;
pub const _BASIC_IOS_TCC: u32 = 1;
pub const _GLIBCXX_OSTREAM: u32 = 1;
pub const _OSTREAM_TCC: u32 = 1;
pub const _ISTREAM_TCC: u32 = 1;
pub const _SSTREAM_TCC: u32 = 1;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const _GLIBCXX_STDLIB_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _GLIBCXX_CSTDDEF: u32 = 1;
pub const __cpp_lib_byte: u32 = 201603;
pub const _ASSERT_H: u32 = 1;
pub const _GLIBCXX_FUNCTIONAL: u32 = 1;
pub const _GLIBCXX_TUPLE: u32 = 1;
pub const _GLIBCXX_UTILITY: u32 = 1;
pub const _STL_RELOPS_H: u32 = 1;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const _GLIBCXX_USE_MAKE_INTEGER_SEQ: u32 = 1;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_as_const: u32 = 201510;
pub const _GLIBCXX_ARRAY: u32 = 1;
pub const _USES_ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_INVOKE_H: u32 = 1;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const _GLIBCXX_REFWRAP_H: u32 = 1;
pub const _GLIBCXX_STD_FUNCTION_H: u32 = 1;
pub const _GLIBCXX_UNORDERED_MAP: u32 = 1;
pub const _ALIGNED_BUFFER_H: u32 = 1;
pub const _HASHTABLE_H: u32 = 1;
pub const _HASHTABLE_POLICY_H: u32 = 1;
pub const _NODE_HANDLE: u32 = 1;
pub const __cpp_lib_node_extract: u32 = 201606;
pub const _GLIBCXX_OPTIONAL: u32 = 1;
pub const _ENABLE_SPECIAL_MEMBERS_H: u32 = 1;
pub const __cpp_lib_optional: u32 = 201606;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_unordered_map_insertion: u32 = 201411;
pub const _GLIBCXX_ERASE_IF_H: u32 = 1;
pub const _GLIBCXX_VECTOR: u32 = 1;
pub const _STL_CONSTRUCT_H: u32 = 1;
pub const _STL_UNINITIALIZED_H: u32 = 1;
pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
pub const _STL_VECTOR_H: u32 = 1;
pub const _STL_BVECTOR_H: u32 = 1;
pub const _VECTOR_TCC: u32 = 1;
pub const _STL_ALGO_H: u32 = 1;
pub const _GLIBCXX_ALGORITHMFWD_H: u32 = 1;
pub const _STL_HEAP_H: u32 = 1;
pub const _STL_TEMPBUF_H: u32 = 1;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_sample: u32 = 201603;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_not_fn: u32 = 201603;
pub const __cpp_lib_boyer_moore_searcher: u32 = 201603;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _GLIBCXX_CSTRING: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _GLIBCXX_CLIMITS: u32 = 1;
pub const _GLIBCXX_ALGORITHM: u32 = 1;
pub const __PSTL_ALGORITHM_FORWARD_DECLARED: u32 = 1;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED: u32 = 1;
pub const EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED: u32 = 0;
pub const EIGEN_MALLOC_ALREADY_ALIGNED: u32 = 1;
pub const EIGEN_PI: f64 = 3.141592653589793;
pub const EIGEN_USE_STD_FPCLASSIFY: u32 = 1;
pub const EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD: u32 = 8;
pub const EIGEN_UNROLLING_LIMIT: u32 = 100;
pub const EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH: u32 = 8;
pub const _GLIBCXX_MEMORY: u32 = 1;
pub const _STL_RAW_STORAGE_ITERATOR_H: u32 = 1;
pub const _CONCURRENCE_H: u32 = 1;
pub const _UNIQUE_PTR_H: u32 = 1;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const _SHARED_PTR_H: u32 = 1;
pub const _SHARED_PTR_BASE_H: u32 = 1;
pub const _ALLOCATED_PTR_H: u32 = 1;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_shared_ptr_weak_type: u32 = 201606;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const _SHARED_PTR_ATOMIC_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_LOCK_FREE_H: u32 = 1;
pub const _BACKWARD_AUTO_PTR_H: u32 = 1;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_byname {
    pub _address: u8,
}
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
pub type std_basic_string___sv_type<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string__If_sv = std_enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper<_CharT> {
    pub _M_sv: std_basic_string___sv_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_collate {
    pub _base: std_locale_facet,
    pub _M_c_locale_collate: std___c_locale,
}
pub type std_collate_char_type<_CharT> = _CharT;
pub type std_collate_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_collate_byname {
    pub _base: std_collate,
}
pub type std_collate_byname_char_type<_CharT> = _CharT;
pub type std_collate_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct<_CharT> {
    pub _base: std_locale_facet,
    pub _M_data: *mut std_numpunct___cache_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_numpunct_char_type<_CharT> = _CharT;
pub type std_numpunct_string_type = std_basic_string<_CharT>;
pub type std_numpunct___cache_type<_CharT> = std___numpunct_cache<_CharT>;
extern "C" {
    #[link_name = "\u{1}id"]
    pub static mut std_id: std_locale_id;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct_byname<_CharT> {
    pub _base: std_numpunct<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_numpunct_byname_char_type<_CharT> = _CharT;
pub type std_numpunct_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
pub struct std_basic_stringbuf<_CharT> {
    pub _base: std_basic_streambuf<_CharT>,
    pub _M_mode: std_ios_base_openmode,
    pub _M_string: std_basic_stringbuf___string_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_stringbuf_char_type<_CharT> = _CharT;
pub type std_basic_stringbuf_traits_type<_Traits> = _Traits;
pub type std_basic_stringbuf_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringbuf_int_type = [u8; 0usize];
pub type std_basic_stringbuf_pos_type = [u8; 0usize];
pub type std_basic_stringbuf_off_type = [u8; 0usize];
pub type std_basic_stringbuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_stringbuf_char_type<_CharT>>;
pub type std_basic_stringbuf___string_type<_CharT> =
    std_basic_string<std_basic_stringbuf_char_type<_CharT>>;
pub type std_basic_stringbuf___size_type<_CharT> = std_basic_stringbuf___string_type<_CharT>;
#[repr(C)]
pub struct std_basic_stringbuf___xfer_bufptrs<_CharT> {
    pub _M_to: *mut std_basic_stringbuf<_CharT>,
    pub _M_goff: [std_basic_stringbuf_off_type; 3usize],
    pub _M_poff: [std_basic_stringbuf_off_type; 3usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
pub struct std_basic_istringstream<_CharT> {
    pub _base: std_basic_istream<_CharT>,
    pub _M_stringbuf: std_basic_istringstream___stringbuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_istringstream_char_type<_CharT> = _CharT;
pub type std_basic_istringstream_traits_type<_Traits> = _Traits;
pub type std_basic_istringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_istringstream_int_type = [u8; 0usize];
pub type std_basic_istringstream_pos_type = [u8; 0usize];
pub type std_basic_istringstream_off_type = [u8; 0usize];
pub type std_basic_istringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_istringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_istringstream___istream_type<_CharT> =
    std_basic_istream<std_basic_istringstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_ostringstream<_CharT> {
    pub _base: std_basic_ostream<_CharT>,
    pub _M_stringbuf: std_basic_ostringstream___stringbuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_ostringstream_char_type<_CharT> = _CharT;
pub type std_basic_ostringstream_traits_type<_Traits> = _Traits;
pub type std_basic_ostringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_ostringstream_int_type = [u8; 0usize];
pub type std_basic_ostringstream_pos_type = [u8; 0usize];
pub type std_basic_ostringstream_off_type = [u8; 0usize];
pub type std_basic_ostringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_ostringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_ostringstream___ostream_type<_CharT> =
    std_basic_ostream<std_basic_ostringstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_stringstream<_CharT> {
    pub _base: std_basic_iostream<_CharT>,
    pub _M_stringbuf: std_basic_stringstream___stringbuf_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_stringstream_char_type<_CharT> = _CharT;
pub type std_basic_stringstream_traits_type<_Traits> = _Traits;
pub type std_basic_stringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringstream_int_type = [u8; 0usize];
pub type std_basic_stringstream_pos_type = [u8; 0usize];
pub type std_basic_stringstream_off_type = [u8; 0usize];
pub type std_basic_stringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_stringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_stringstream___iostream_type<_CharT> =
    std_basic_iostream<std_basic_stringstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type std_unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt9terminatev"]
    pub fn std_terminate() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt10unexpectedv"]
    pub fn std_unexpected() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvmm"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvmm"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std_type_info() {
    const UNINIT: ::std::mem::MaybeUninit<std_type_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        16usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_type_info),
            "::",
            stringify!(__name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *const std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *const __cxxabiv1___class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_cast>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_cast))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_cast>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_cast))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_typeid>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_typeid))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_typeid>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_typeid))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___exception_ptr_exception_ptr {
    pub _M_exception_object: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std___exception_ptr_exception_ptr() {
    const UNINIT: ::std::mem::MaybeUninit<std___exception_ptr_exception_ptr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___exception_ptr_exception_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std___exception_ptr_exception_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std___exception_ptr_exception_ptr>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___exception_ptr_exception_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_exception_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___exception_ptr_exception_ptr),
            "::",
            stringify!(_M_exception_object)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptr4swapERS0_"]
    pub fn std___exception_ptr_exception_ptr_swap(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *mut std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt15__exception_ptr13exception_ptr20__cxa_exception_typeEv"]
    pub fn std___exception_ptr_exception_ptr___cxa_exception_type(
        this: *const std___exception_ptr_exception_ptr,
    ) -> *const std_type_info;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1ERKS0_"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr1(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *const std___exception_ptr_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrD1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr_destructor(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
impl std___exception_ptr_exception_ptr {
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut std___exception_ptr_exception_ptr) {
        std___exception_ptr_exception_ptr_swap(self, arg1)
    }
    #[inline]
    pub unsafe fn __cxa_exception_type(&self) -> *const std_type_info {
        std___exception_ptr_exception_ptr___cxa_exception_type(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std___exception_ptr_exception_ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___exception_ptr_exception_ptr_exception_ptr_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std___exception_ptr_exception_ptr;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17rethrow_exceptionNSt15__exception_ptr13exception_ptrE"]
    pub fn std_rethrow_exception(arg1: std___exception_ptr_exception_ptr) -> !;
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std_value: _Tp;
}
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
pub type std_bool_constant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___or__open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___or_>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std___or_))
    );
    assert_eq!(
        ::std::mem::align_of::<std___or_>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___or_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___and__open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___and_>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std___and_))
    );
    assert_eq!(
        ::std::mem::align_of::<std___and_>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___and_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_conjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___failure_type() {
    assert_eq!(
        ::std::mem::size_of::<std___failure_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___failure_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___failure_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___failure_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_void_helper_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_void_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_void_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_void_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_void_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0___float128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_null_pointer_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_null_pointer_helper_open0_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_null_pointer_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_null_pointer_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_null_pointer_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_null_pointer_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_is_destructible_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nt_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_nt_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_nt_destructible_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_implicitly_default_constructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
pub type std___is_convertible_helper_type = std_is_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type = std_add_const;
pub type std_remove_const_t = std_remove_const;
pub type std_remove_volatile_t = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
pub type std_add_const_t = std_add_const;
pub type std_add_volatile_t = std_add_volatile;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_remove_reference_t = std_remove_reference;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___make_unsigned_selector_base() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___make_unsigned_selector_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___make_unsigned_selector_base)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = std_remove_pointer;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___aligned_storage_msa___type() {
    assert_eq!(
        ::std::mem::size_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!("Size of: ", stringify!(std___aligned_storage_msa___type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___aligned_storage_msa___type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = std___strictest_alignment;
pub type std_aligned_union_type = u8;
extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay___remove_type = std_remove_reference;
pub type std_decay_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___decay_and_strip {
    pub _address: u8,
}
pub type std___decay_and_strip___type = std___strip_reference_wrapper;
pub type std__Require = u8;
pub type std_conditional_type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_common_type_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_common_type_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_common_type_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_member_type_wrapper {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_member_type_wrapper() {
    assert_eq!(
        ::std::mem::size_of::<std___do_member_type_wrapper>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_member_type_wrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_member_type_wrapper>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_member_type_wrapper))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_type_wrapper {
    pub _address: u8,
}
pub type std___member_type_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___expanded_common_type_wrapper {
    pub _address: u8,
}
pub type std___expanded_common_type_wrapper_type = std_common_type;
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
pub type std___remove_cvref_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_ref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_deref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_ref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_deref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_other() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_other>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_other))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_other>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_other))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memfun_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memfun_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memobj_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memobj_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_other_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_other_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_other_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = std_decay;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = std_common_type;
pub type std_underlying_type_t = std_underlying_type;
pub type std_result_of_t = std_result_of;
pub type std___enable_if_t = u8;
pub type std___void_t = ::std::os::raw::c_void;
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_nothrow_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_swappable_with_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_with_details___do_is_swappable_with_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_with_details___do_is_swappable_with_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_with_details___do_is_swappable_with_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_with_details___do_is_swappable_with_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_nothrow_swappable_with_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_with_details___do_is_nothrow_swappable_with_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_with_details___do_is_nothrow_swappable_with_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_with_details___do_is_nothrow_swappable_with_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_with_details___do_is_nothrow_swappable_with_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuch() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuch>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuch))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuch>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuch))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_invoke_result {
    pub _address: u8,
}
pub type std_invoke_result_t = std_invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_invocable_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_unique_object_representations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_aggregate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub _M_ptr: std___exception_ptr_exception_ptr,
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    const UNINIT: ::std::mem::MaybeUninit<std_nested_exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_nested_exception>(),
        16usize,
        concat!("Size of: ", stringify!(std_nested_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nested_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nested_exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_nested_exception),
            "::",
            stringify!(_M_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Nested_exception<_Except> {
    pub _base: _Except,
    pub _base_1: std_nested_exception,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Except>>,
}
pub type std___rethrow_if_nested_cond = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_array_new_length))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_array_new_length))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_align_val_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nothrow_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nothrow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nothrow_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nothrow_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___true_type() {
    assert_eq!(
        ::std::mem::size_of::<std___true_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___true_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___true_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___true_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___false_type() {
    assert_eq!(
        ::std::mem::size_of::<std___false_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___false_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___false_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___false_type))
    );
}
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_void_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_void>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_void)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_void)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_integer_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_floating_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_char_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_char>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_char)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_char>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_char)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_char_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_char>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_char)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_char>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_char)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_byte_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_std_byte_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = std___false_type;
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch_no_braces {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuch_no_braces() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuch_no_braces>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuch_no_braces))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuch_no_braces>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuch_no_braces))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_output_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_output_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std__RequireInputIter = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
pub type std___replace_first_arg_t = std___replace_first_arg;
pub type std___make_not_void = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
pub type std___ptr_rebind = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub iter: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator___base_ref = std_move_iterator___traits_type;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category = std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = u8;
pub type std___iter_key_t = std_remove_const_t;
pub type std___iter_val_t = std_iterator_traits;
pub type std___iter_to_alloc_t = std_pair<std_add_const_t, std___iter_val_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___lc_rai_open0_std_random_access_iterator_tag_std_random_access_iterator_tag_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___lc_rai>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___lc_rai)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___lc_rai>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___lc_rai)
        )
    );
}
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[test]
fn bindgen_test_layout_std___numeric_limits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___numeric_limits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___numeric_limits_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___floating_point_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___numeric_constants {
    pub _address: u8,
}
pub type std___detail___idt = std_common_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___variant__Never_valueless_alt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Identity {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Identity() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Identity>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Identity))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Identity>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Identity))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Select1st {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Select1st() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Select1st>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Select1st))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Select1st>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Select1st))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___detail__ReuseOrAllocNode {
    pub _M_nodes: *mut std___detail__ReuseOrAllocNode___node_type,
    pub _M_h: *mut std___detail__ReuseOrAllocNode___hashtable_alloc,
}
pub type std___detail__ReuseOrAllocNode___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__ReuseOrAllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_alloc_traits =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_type =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__AllocNode {
    pub _M_h: *mut std___detail__AllocNode___hashtable_alloc,
}
pub type std___detail__AllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__AllocNode___node_type = std___detail__AllocNode___hashtable_alloc;
pub type std___detail__Hashtable_traits___hash_cached = std___bool_constant;
pub type std___detail__Hashtable_traits___constant_iterators = std___bool_constant;
pub type std___detail__Hashtable_traits___unique_keys = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_base {
    pub _M_nxt: *mut std___detail__Hash_node_base,
}
#[test]
fn bindgen_test_layout_std___detail__Hash_node_base() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Hash_node_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Hash_node_base),
            "::",
            stringify!(_M_nxt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_value_base {
    pub _base: std___detail__Hash_node_base,
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std___detail__Hash_node_value_base_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_base___node_type = u8;
pub type std___detail__Node_iterator___base_type = u8;
pub type std___detail__Node_iterator___node_type = std___detail__Node_iterator___base_type;
pub type std___detail__Node_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_difference_type = isize;
pub type std___detail__Node_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_iterator_pointer = u8;
pub type std___detail__Node_iterator_reference = u8;
pub type std___detail__Node_const_iterator___base_type = u8;
pub type std___detail__Node_const_iterator___node_type =
    std___detail__Node_const_iterator___base_type;
pub type std___detail__Node_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_const_iterator_difference_type = isize;
pub type std___detail__Node_const_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Node_const_iterator_reference<_Value> = *const _Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mod_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mod_range_hashing_first_argument_type = usize;
pub type std___detail__Mod_range_hashing_second_argument_type = usize;
pub type std___detail__Mod_range_hashing_result_type = usize;
#[test]
fn bindgen_test_layout_std___detail__Mod_range_hashing() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Mod_range_hashing>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Mod_range_hashing))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Mod_range_hashing>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Mod_range_hashing))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Default_ranged_hash {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Default_ranged_hash() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Default_ranged_hash>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Default_ranged_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Default_ranged_hash>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Default_ranged_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Prime_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Prime_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Prime_rehash_policy__State = usize;
pub const std___detail__Prime_rehash_policy__S_growth_factor: usize = 2;
#[test]
fn bindgen_test_layout_std___detail__Prime_rehash_policy() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Prime_rehash_policy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Prime_rehash_policy>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__Prime_rehash_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Prime_rehash_policy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Prime_rehash_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_max_load_factor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Prime_rehash_policy),
            "::",
            stringify!(_M_max_load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next_resize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Prime_rehash_policy),
            "::",
            stringify!(_M_next_resize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEm"]
    pub fn std___detail__Prime_rehash_policy__M_next_bkt(
        this: *const std___detail__Prime_rehash_policy,
        __n: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEmmm"]
    pub fn std___detail__Prime_rehash_policy__M_need_rehash(
        this: *const std___detail__Prime_rehash_policy,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize>;
}
impl std___detail__Prime_rehash_policy {
    #[inline]
    pub unsafe fn _M_next_bkt(&self, __n: usize) -> usize {
        std___detail__Prime_rehash_policy__M_next_bkt(self, __n)
    }
    #[inline]
    pub unsafe fn _M_need_rehash(
        &self,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize> {
        std___detail__Prime_rehash_policy__M_need_rehash(self, __n_bkt, __n_elt, __n_ins)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mask_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mask_range_hashing_first_argument_type = usize;
pub type std___detail__Mask_range_hashing_second_argument_type = usize;
pub type std___detail__Mask_range_hashing_result_type = usize;
#[test]
fn bindgen_test_layout_std___detail__Mask_range_hashing() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Mask_range_hashing>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Mask_range_hashing))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Mask_range_hashing>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Mask_range_hashing)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Power2_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Power2_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Power2_rehash_policy__State = usize;
pub const std___detail__Power2_rehash_policy__S_growth_factor: usize = 2;
#[test]
fn bindgen_test_layout_std___detail__Power2_rehash_policy() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Power2_rehash_policy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Power2_rehash_policy>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__Power2_rehash_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Power2_rehash_policy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Power2_rehash_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_max_load_factor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Power2_rehash_policy),
            "::",
            stringify!(_M_max_load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next_resize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Power2_rehash_policy),
            "::",
            stringify!(_M_next_resize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Insert_base {
    pub _address: u8,
}
pub type std___detail__Insert_base___hashtable<_RehashPolicy> = std__Hashtable<_RehashPolicy>;
pub type std___detail__Insert_base___hashtable_base = std___detail__Hashtable_base;
pub type std___detail__Insert_base_value_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_iterator = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_const_iterator = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_size_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___unique_keys = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___ireturn_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___node_type = u8;
pub type std___detail__Insert_base___node_alloc_type = std___alloc_rebind;
pub type std___detail__Insert_base___node_gen_type = std___detail__AllocNode;
pub type std___detail___has_load_factor = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Rehash_base {
    pub _address: u8,
}
pub type std___detail___hash_code_for_local_iter = u8;
pub type std___detail__Local_iterator___base_type = u8;
pub type std___detail__Local_iterator___hash_code_base = std___detail__Local_iterator___base_type;
pub type std___detail__Local_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_iterator_pointer = u8;
pub type std___detail__Local_iterator_reference = u8;
pub type std___detail__Local_iterator_difference_type = isize;
pub type std___detail__Local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Local_const_iterator___base_type = u8;
pub type std___detail__Local_const_iterator___hash_code_base =
    std___detail__Local_const_iterator___base_type;
pub type std___detail__Local_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_reference<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_difference_type = isize;
pub type std___detail__Local_const_iterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_base {
    pub _address: u8,
}
pub type std___detail__Hashtable_base_key_type<_Key> = _Key;
pub type std___detail__Hashtable_base_value_type<_Value> = _Value;
pub type std___detail__Hashtable_base_key_equal<_Equal> = _Equal;
pub type std___detail__Hashtable_base_size_type = usize;
pub type std___detail__Hashtable_base_difference_type = isize;
pub type std___detail__Hashtable_base___traits_type<_Traits> = _Traits;
pub type std___detail__Hashtable_base___hash_cached = [u8; 0usize];
pub type std___detail__Hashtable_base___constant_iterators = [u8; 0usize];
pub type std___detail__Hashtable_base___unique_keys = [u8; 0usize];
pub type std___detail__Hashtable_base___hash_code_base = u8;
pub type std___detail__Hashtable_base___hash_code = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base___node_type = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base_iterator = u8;
pub type std___detail__Hashtable_base_const_iterator = u8;
pub type std___detail__Hashtable_base_local_iterator = u8;
pub type std___detail__Hashtable_base_const_local_iterator = u8;
pub type std___detail__Hashtable_base___ireturn_type = u8;
pub type std___detail__Hashtable_base__EqualEBO = u8;
pub type std___detail__Hashtable_base__EqualHelper = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Equality_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Equality_base() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Equality_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Equality_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Equality_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Equality_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_alloc {
    pub _address: u8,
}
pub type std___detail__Hashtable_alloc___ebo_node_alloc = u8;
pub type std___detail__Hashtable_alloc___node_type = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__Hashtable_alloc___node_alloc_traits = __gnu_cxx___alloc_traits;
pub type std___detail__Hashtable_alloc___value_alloc_traits = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_base = std___detail__Hash_node_base;
pub type std___detail__Hashtable_alloc___bucket_type =
    *mut std___detail__Hashtable_alloc___node_base;
pub type std___detail__Hashtable_alloc___bucket_alloc_type = std___alloc_rebind;
pub type std___detail__Hashtable_alloc___bucket_alloc_traits = std_allocator_traits;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_wstring = std_basic_string<u32>;
pub type std_u16string = std_basic_string<u16>;
pub type std_u32string = std_basic_string<u32>;
pub type std_streamoff = ::std::os::raw::c_long;
pub type std_streamsize = isize;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_wstreampos = std_fpos<__mbstate_t>;
pub type std_u16streampos = std_fpos<__mbstate_t>;
pub type std_u32streampos = std_fpos<__mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios<::std::os::raw::c_char>;
pub type std_streambuf = std_basic_streambuf<::std::os::raw::c_char>;
pub type std_istream = std_basic_istream<::std::os::raw::c_char>;
pub type std_ostream = std_basic_ostream<::std::os::raw::c_char>;
pub type std_iostream = std_basic_iostream<::std::os::raw::c_char>;
pub type std_stringbuf = std_basic_stringbuf<::std::os::raw::c_char>;
pub type std_istringstream = std_basic_istringstream<::std::os::raw::c_char>;
pub type std_ostringstream = std_basic_ostringstream<::std::os::raw::c_char>;
pub type std_stringstream = std_basic_stringstream<::std::os::raw::c_char>;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wios = std_basic_ios<u32>;
pub type std_wstreambuf = std_basic_streambuf<u32>;
pub type std_wistream = std_basic_istream<u32>;
pub type std_wostream = std_basic_ostream<u32>;
pub type std_wiostream = std_basic_iostream<u32>;
pub type std_wstringbuf = std_basic_stringbuf<u32>;
pub type std_wistringstream = std_basic_istringstream<u32>;
pub type std_wostringstream = std_basic_ostringstream<u32>;
pub type std_wstringstream = std_basic_stringstream<u32>;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
pub type std___c_locale = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base {
    _unused: [u8; 0],
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_transparent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_plus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_plus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_plus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_plus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_plus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_minus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_minus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_minus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_minus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_minus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_multiplies_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_multiplies>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_multiplies)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_multiplies>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_multiplies)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_divides_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_divides>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_divides))
    );
    assert_eq!(
        ::std::mem::align_of::<std_divides>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_divides)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_modulus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_modulus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_modulus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_modulus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_modulus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_negate_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_negate>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_negate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_negate>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_negate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_equal_to_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_not_equal_to_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_not_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_not_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_not_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_not_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_greater_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_greater>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_greater))
    );
    assert_eq!(
        ::std::mem::align_of::<std_greater>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_greater)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_less_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_less>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_less))
    );
    assert_eq!(
        ::std::mem::align_of::<std_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_less)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_greater_equal_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_greater_equal>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_greater_equal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_greater_equal>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_greater_equal)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_less_equal_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_less_equal>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_less_equal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_less_equal>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_less_equal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_logical_and_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_and>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_and)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_and>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_and)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_logical_or_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_or>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_or)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_or>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_or)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_logical_not_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_not>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_not)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_not>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_not)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_bit_and_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_and>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_and))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_and>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_and)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_or_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_or>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_or))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_or>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_or)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_xor_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_xor>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_xor))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_xor>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_xor)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_not_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_not>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_not))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_not>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_not)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
pub struct std_binder1st<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
}
#[repr(C)]
pub struct std_binder2nd<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_valarray {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_alloc_insertable_impl {
    pub _base: std_false_type,
}
#[repr(C)]
pub struct std___is_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _base: std_false_type,
}
pub type std__RequireAllocator = u8;
pub type std__RequireNotAllocator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type<_Result> = _Result;
pub type std___hash_base_argument_type<_Arg> = _Arg;
#[repr(C)]
#[derive(Debug)]
pub struct std___poison_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_hash {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_hash_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Hash_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Fnv_hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Fnv_hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Fnv_hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Fnv_hash_impl))
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_fast_hash {
    pub _base: std_true_type,
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_long_double_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub _M_len: usize,
    pub _M_str: *const _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_pointer<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_reference<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_reference<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_iterator<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = usize;
pub type std_basic_string_view_difference_type = isize;
pub type std_string_view = std_basic_string_view<::std::os::raw::c_char>;
pub type std_wstring_view = std_basic_string_view<u32>;
pub type std_u16string_view = std_basic_string_view<u16>;
pub type std_u32string_view = std_basic_string_view<u32>;
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char_std_char_traits_open3_char_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_wchar_t_std_char_traits_open3_wchar_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char16_t_std_char_traits_open2_char16_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char16_t_std_char_traits_open3_char16_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char32_t_std_char_traits_open2_char32_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char32_t_std_char_traits_open3_char32_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline(
        __in: *mut std_basic_istream<::std::os::raw::c_char>,
        __str: *mut std_basic_string<::std::os::raw::c_char>,
        __delim: ::std::os::raw::c_char,
    ) -> *mut std_basic_istream<::std::os::raw::c_char>;
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIwSt11char_traitsIwESaIwEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline1(
        __in: *mut std_basic_istream<u32>,
        __str: *mut std_basic_string<u32>,
        __delim: u32,
    ) -> *mut std_basic_istream<u32>;
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_wchar_t_std_char_traits_open3_wchar_t_close3_std_allocator_open3_wchar_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char16_t_std_char_traits_open3_char16_t_close3_std_allocator_open3_char16_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char32_t_std_char_traits_open3_char32_t_close3_std_allocator_open3_char32_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}npos"]
    pub static std_npos: std_basic_string_size_type;
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
pub type std_size_type = size_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pmr_polymorphic_allocator {
    pub _address: u8,
}
pub type std_pmr_basic_string<_CharT> = std_basic_string<_CharT>;
pub type std_pmr_string = std_basic_string<::std::os::raw::c_char>;
pub type std_pmr_u16string = std_basic_string<u16>;
pub type std_pmr_u32string = std_basic_string<u32>;
pub type std_pmr_wstring = std_basic_string<u32>;
pub type std_pmr_unordered_map = std_unordered_map;
pub type std_pmr_unordered_multimap = std_unordered_multimap;
pub type std_pmr_vector = std_vector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_string_base {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_pmr_polymorphic_allocator_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_pmr_polymorphic_allocator_open2_char16_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_pmr_polymorphic_allocator_open2_char32_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_pmr_polymorphic_allocator_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale {
    pub _M_impl: *mut std_locale__Impl,
}
pub type std_locale_category = ::std::os::raw::c_int;
pub const std_locale__S_categories_size: std_locale__bindgen_ty_1 = 12;
pub type std_locale__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_ctype: std_locale_category = 1;
pub const std_locale_numeric: std_locale_category = 2;
pub const std_locale_collate: std_locale_category = 4;
pub const std_locale_time: std_locale_category = 8;
pub const std_locale_monetary: std_locale_category = 16;
pub const std_locale_messages: std_locale_category = 32;
pub const std_locale_all: std_locale_category = 63;
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale10_S_classicE"]
    pub static mut std_locale__S_classic: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale9_S_globalE"]
    pub static mut std_locale__S_global: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale13_S_categoriesE"]
    pub static std_locale__S_categories: *const *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7_S_onceE"]
    pub static mut std_locale__S_once: __gthread_once_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE"]
    pub static std_locale__S_twinned_facets: [*const std_locale_id; 0usize];
}
#[test]
fn bindgen_test_layout_std_locale() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_impl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale),
            "::",
            stringify!(_M_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale6globalERKS_"]
    pub fn std_locale_global(__loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7classicEv"]
    pub fn std_locale_classic() -> *const std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1Ev"]
    pub fn std_locale_locale(this: *mut std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_"]
    pub fn std_locale_locale1(this: *mut std_locale, __other: *const std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1EPKc"]
    pub fn std_locale_locale2(this: *mut std_locale, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_PKci"]
    pub fn std_locale_locale3(
        this: *mut std_locale,
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i"]
    pub fn std_locale_locale4(
        this: *mut std_locale,
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeD1Ev"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        std_locale_name(self)
    }
    #[inline]
    pub unsafe fn global(__loc: *const std_locale) -> std_locale {
        std_locale_global(__loc)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale {
        std_locale_classic()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__other: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale1(__bindgen_tmp.as_mut_ptr(), __other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale2(__bindgen_tmp.as_mut_ptr(), __s);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale3(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale4(__bindgen_tmp.as_mut_ptr(), __base, __add, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_locale_locale_destructor(self)
    }
}
#[repr(C)]
pub struct std_locale_facet__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_locale_facet {
    pub vtable_: *const std_locale_facet__bindgen_vtable,
    pub _M_refcount: _Atomic_word,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_facet___shim {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE"]
    pub static mut std_locale_facet__S_c_locale: std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE"]
    pub static std_locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet7_S_onceE"]
    pub static mut std_locale_facet__S_once: __gthread_once_t;
}
#[test]
fn bindgen_test_layout_std_locale_facet() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale_facet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale_facet>(),
        16usize,
        concat!("Size of: ", stringify!(std_locale_facet))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_facet>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_facet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale_facet),
            "::",
            stringify!(_M_refcount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_"]
    pub fn std_locale_facet__S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_destroy_c_locale(__cloc: *mut std___c_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc"]
    pub fn std_locale_facet__S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv"]
    pub fn std_locale_facet__S_get_c_locale() -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv"]
    pub fn std_locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
}
impl std_locale_facet {
    #[inline]
    pub unsafe fn _S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    ) {
        std_locale_facet__S_create_c_locale(__cloc, __s, __old)
    }
    #[inline]
    pub unsafe fn _S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale {
        std_locale_facet__S_clone_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_destroy_c_locale(__cloc: *mut std___c_locale) {
        std_locale_facet__S_destroy_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale {
        std_locale_facet__S_lc_ctype_c_locale(__cloc, __s)
    }
    #[inline]
    pub unsafe fn _S_get_c_locale() -> std___c_locale {
        std_locale_facet__S_get_c_locale()
    }
    #[inline]
    pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
        std_locale_facet__S_get_c_name()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facetD1Ev"]
    pub fn std_locale_facet_facet_destructor(this: *mut std_locale_facet);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_id {
    pub _M_index: usize,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale2id11_S_refcountE"]
    pub static mut std_locale_id__S_refcount: _Atomic_word;
}
#[test]
fn bindgen_test_layout_std_locale_id() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale_id>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale_id),
            "::",
            stringify!(_M_index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale2id5_M_idEv"]
    pub fn std_locale_id__M_id(this: *const std_locale_id) -> usize;
}
impl std_locale_id {
    #[inline]
    pub unsafe fn _M_id(&self) -> usize {
        std_locale_id__M_id(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale__Impl {
    pub _M_refcount: _Atomic_word,
    pub _M_facets: *mut *const std_locale_facet,
    pub _M_facets_size: usize,
    pub _M_caches: *mut *const std_locale_facet,
    pub _M_names: *mut *mut ::std::os::raw::c_char,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE"]
    pub static std_locale__Impl__S_id_ctype: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE"]
    pub static std_locale__Impl__S_id_numeric: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE"]
    pub static std_locale__Impl__S_id_collate: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE"]
    pub static std_locale__Impl__S_id_time: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE"]
    pub static std_locale__Impl__S_id_monetary: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE"]
    pub static std_locale__Impl__S_id_messages: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE"]
    pub static std_locale__Impl__S_facet_categories: [*const *const std_locale_id; 0usize];
}
#[test]
fn bindgen_test_layout_std_locale__Impl() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale__Impl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale__Impl>(),
        40usize,
        concat!("Size of: ", stringify!(std_locale__Impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale__Impl>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale__Impl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_facets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_facets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_facets_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_facets_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_caches) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_caches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_names) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_names)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
pub const std_errc_address_family_not_supported: std_errc = 97;
pub const std_errc_address_in_use: std_errc = 98;
pub const std_errc_address_not_available: std_errc = 99;
pub const std_errc_already_connected: std_errc = 106;
pub const std_errc_argument_list_too_long: std_errc = 7;
pub const std_errc_argument_out_of_domain: std_errc = 33;
pub const std_errc_bad_address: std_errc = 14;
pub const std_errc_bad_file_descriptor: std_errc = 9;
pub const std_errc_bad_message: std_errc = 74;
pub const std_errc_broken_pipe: std_errc = 32;
pub const std_errc_connection_aborted: std_errc = 103;
pub const std_errc_connection_already_in_progress: std_errc = 114;
pub const std_errc_connection_refused: std_errc = 111;
pub const std_errc_connection_reset: std_errc = 104;
pub const std_errc_cross_device_link: std_errc = 18;
pub const std_errc_destination_address_required: std_errc = 89;
pub const std_errc_device_or_resource_busy: std_errc = 16;
pub const std_errc_directory_not_empty: std_errc = 39;
pub const std_errc_executable_format_error: std_errc = 8;
pub const std_errc_file_exists: std_errc = 17;
pub const std_errc_file_too_large: std_errc = 27;
pub const std_errc_filename_too_long: std_errc = 36;
pub const std_errc_function_not_supported: std_errc = 38;
pub const std_errc_host_unreachable: std_errc = 113;
pub const std_errc_identifier_removed: std_errc = 43;
pub const std_errc_illegal_byte_sequence: std_errc = 84;
pub const std_errc_inappropriate_io_control_operation: std_errc = 25;
pub const std_errc_interrupted: std_errc = 4;
pub const std_errc_invalid_argument: std_errc = 22;
pub const std_errc_invalid_seek: std_errc = 29;
pub const std_errc_io_error: std_errc = 5;
pub const std_errc_is_a_directory: std_errc = 21;
pub const std_errc_message_size: std_errc = 90;
pub const std_errc_network_down: std_errc = 100;
pub const std_errc_network_reset: std_errc = 102;
pub const std_errc_network_unreachable: std_errc = 101;
pub const std_errc_no_buffer_space: std_errc = 105;
pub const std_errc_no_child_process: std_errc = 10;
pub const std_errc_no_link: std_errc = 67;
pub const std_errc_no_lock_available: std_errc = 37;
pub const std_errc_no_message_available: std_errc = 61;
pub const std_errc_no_message: std_errc = 42;
pub const std_errc_no_protocol_option: std_errc = 92;
pub const std_errc_no_space_on_device: std_errc = 28;
pub const std_errc_no_stream_resources: std_errc = 63;
pub const std_errc_no_such_device_or_address: std_errc = 6;
pub const std_errc_no_such_device: std_errc = 19;
pub const std_errc_no_such_file_or_directory: std_errc = 2;
pub const std_errc_no_such_process: std_errc = 3;
pub const std_errc_not_a_directory: std_errc = 20;
pub const std_errc_not_a_socket: std_errc = 88;
pub const std_errc_not_a_stream: std_errc = 60;
pub const std_errc_not_connected: std_errc = 107;
pub const std_errc_not_enough_memory: std_errc = 12;
pub const std_errc_not_supported: std_errc = 95;
pub const std_errc_operation_canceled: std_errc = 125;
pub const std_errc_operation_in_progress: std_errc = 115;
pub const std_errc_operation_not_permitted: std_errc = 1;
pub const std_errc_operation_not_supported: std_errc = 95;
pub const std_errc_operation_would_block: std_errc = 11;
pub const std_errc_owner_dead: std_errc = 130;
pub const std_errc_permission_denied: std_errc = 13;
pub const std_errc_protocol_error: std_errc = 71;
pub const std_errc_protocol_not_supported: std_errc = 93;
pub const std_errc_read_only_file_system: std_errc = 30;
pub const std_errc_resource_deadlock_would_occur: std_errc = 35;
pub const std_errc_resource_unavailable_try_again: std_errc = 11;
pub const std_errc_result_out_of_range: std_errc = 34;
pub const std_errc_state_not_recoverable: std_errc = 131;
pub const std_errc_stream_timeout: std_errc = 62;
pub const std_errc_text_file_busy: std_errc = 26;
pub const std_errc_timed_out: std_errc = 110;
pub const std_errc_too_many_files_open_in_system: std_errc = 23;
pub const std_errc_too_many_files_open: std_errc = 24;
pub const std_errc_too_many_links: std_errc = 31;
pub const std_errc_too_many_symbolic_link_levels: std_errc = 40;
pub const std_errc_value_too_large: std_errc = 75;
pub const std_errc_wrong_protocol_type: std_errc = 91;
pub type std_errc = ::std::os::raw::c_int;
#[repr(C)]
pub struct std___cow_string {
    pub __bindgen_anon_1: std___cow_string__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___cow_string__bindgen_ty_1 {
    pub _M_p: *const ::std::os::raw::c_char,
    pub _M_bytes: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_std___cow_string__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<std___cow_string__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___cow_string__bindgen_ty_1),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___cow_string__bindgen_ty_1),
            "::",
            stringify!(_M_bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_std___cow_string() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
    pub fn std___cow_string___cow_string(this: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___cow_string___cow_string1(this: *mut std___cow_string, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcm"]
    pub fn std___cow_string___cow_string2(
        this: *mut std___cow_string,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
    pub fn std___cow_string___cow_string3(
        this: *mut std___cow_string,
        arg1: *const std___cow_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
    pub fn std___cow_string___cow_string4(this: *mut std___cow_string, arg1: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
    pub fn std___cow_string___cow_string_destructor(this: *mut std___cow_string);
}
impl std___cow_string {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *mut std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___cow_string___cow_string_destructor(self)
    }
}
pub type std___sso_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
pub struct std_logic_error {
    pub _base: std_exception,
    pub _M_msg: std___cow_string,
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_logic_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_logic_error),
            "::",
            stringify!(_M_msg)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EOS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error3(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1EPKc"]
    pub fn std_domain_error_domain_error1(
        this: *mut std_domain_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        16usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_invalid_argument_invalid_argument(
        this: *mut std_invalid_argument,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1EPKc"]
    pub fn std_invalid_argument_invalid_argument1(
        this: *mut std_invalid_argument,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_length_error_length_error(this: *mut std_length_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1EPKc"]
    pub fn std_length_error_length_error1(
        this: *mut std_length_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        8usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1EPKc"]
    pub fn std_out_of_range_out_of_range1(
        this: *mut std_out_of_range,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
pub struct std_runtime_error {
    pub _base: std_exception,
    pub _M_msg: std___cow_string,
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_runtime_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_runtime_error),
            "::",
            stringify!(_M_msg)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EOS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *mut std_runtime_error,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error3(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_range_error_range_error(this: *mut std_range_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1EPKc"]
    pub fn std_range_error_range_error1(
        this: *mut std_range_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_overflow_error_overflow_error(
        this: *mut std_overflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1EPKc"]
    pub fn std_overflow_error_overflow_error1(
        this: *mut std_overflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_underflow_error_underflow_error(
        this: *mut std_underflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1EPKc"]
    pub fn std_underflow_error_underflow_error1(
        this: *mut std_underflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_is_error_condition_enum_open0_std_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
}
#[repr(C)]
pub struct std_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_error_category {
    pub vtable_: *const std_error_category__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std_error_category>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_category>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V215system_categoryEv"]
    pub fn std_system_category() -> *const std_error_category;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V216generic_categoryEv"]
    pub fn std_generic_category() -> *const std_error_category;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_code() {
    const UNINIT: ::std::mem::MaybeUninit<std_error_code> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_cat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_condition() {
    const UNINIT: ::std::mem::MaybeUninit<std_error_condition> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_cat)
        )
    );
}
#[repr(C)]
pub struct std_system_error {
    pub _base: std_runtime_error,
    pub _M_code: std_error_code,
}
#[test]
fn bindgen_test_layout_std_system_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_system_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_system_error>(),
        32usize,
        concat!("Size of: ", stringify!(std_system_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_system_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_system_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_system_error),
            "::",
            stringify!(_M_code)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_code_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_condition_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
pub const std__Ios_Fmtflags__S_boolalpha: std__Ios_Fmtflags = 1;
pub const std__Ios_Fmtflags__S_dec: std__Ios_Fmtflags = 2;
pub const std__Ios_Fmtflags__S_fixed: std__Ios_Fmtflags = 4;
pub const std__Ios_Fmtflags__S_hex: std__Ios_Fmtflags = 8;
pub const std__Ios_Fmtflags__S_internal: std__Ios_Fmtflags = 16;
pub const std__Ios_Fmtflags__S_left: std__Ios_Fmtflags = 32;
pub const std__Ios_Fmtflags__S_oct: std__Ios_Fmtflags = 64;
pub const std__Ios_Fmtflags__S_right: std__Ios_Fmtflags = 128;
pub const std__Ios_Fmtflags__S_scientific: std__Ios_Fmtflags = 256;
pub const std__Ios_Fmtflags__S_showbase: std__Ios_Fmtflags = 512;
pub const std__Ios_Fmtflags__S_showpoint: std__Ios_Fmtflags = 1024;
pub const std__Ios_Fmtflags__S_showpos: std__Ios_Fmtflags = 2048;
pub const std__Ios_Fmtflags__S_skipws: std__Ios_Fmtflags = 4096;
pub const std__Ios_Fmtflags__S_unitbuf: std__Ios_Fmtflags = 8192;
pub const std__Ios_Fmtflags__S_uppercase: std__Ios_Fmtflags = 16384;
pub const std__Ios_Fmtflags__S_adjustfield: std__Ios_Fmtflags = 176;
pub const std__Ios_Fmtflags__S_basefield: std__Ios_Fmtflags = 74;
pub const std__Ios_Fmtflags__S_floatfield: std__Ios_Fmtflags = 260;
pub const std__Ios_Fmtflags__S_ios_fmtflags_end: std__Ios_Fmtflags = 65536;
pub const std__Ios_Fmtflags__S_ios_fmtflags_max: std__Ios_Fmtflags = 2147483647;
pub const std__Ios_Fmtflags__S_ios_fmtflags_min: std__Ios_Fmtflags = -2147483648;
pub type std__Ios_Fmtflags = ::std::os::raw::c_int;
pub const std__Ios_Openmode__S_app: std__Ios_Openmode = 1;
pub const std__Ios_Openmode__S_ate: std__Ios_Openmode = 2;
pub const std__Ios_Openmode__S_bin: std__Ios_Openmode = 4;
pub const std__Ios_Openmode__S_in: std__Ios_Openmode = 8;
pub const std__Ios_Openmode__S_out: std__Ios_Openmode = 16;
pub const std__Ios_Openmode__S_trunc: std__Ios_Openmode = 32;
pub const std__Ios_Openmode__S_ios_openmode_end: std__Ios_Openmode = 65536;
pub const std__Ios_Openmode__S_ios_openmode_max: std__Ios_Openmode = 2147483647;
pub const std__Ios_Openmode__S_ios_openmode_min: std__Ios_Openmode = -2147483648;
pub type std__Ios_Openmode = ::std::os::raw::c_int;
pub const std__Ios_Iostate__S_goodbit: std__Ios_Iostate = 0;
pub const std__Ios_Iostate__S_badbit: std__Ios_Iostate = 1;
pub const std__Ios_Iostate__S_eofbit: std__Ios_Iostate = 2;
pub const std__Ios_Iostate__S_failbit: std__Ios_Iostate = 4;
pub const std__Ios_Iostate__S_ios_iostate_end: std__Ios_Iostate = 65536;
pub const std__Ios_Iostate__S_ios_iostate_max: std__Ios_Iostate = 2147483647;
pub const std__Ios_Iostate__S_ios_iostate_min: std__Ios_Iostate = -2147483648;
pub type std__Ios_Iostate = ::std::os::raw::c_int;
pub const std__Ios_Seekdir__S_beg: std__Ios_Seekdir = 0;
pub const std__Ios_Seekdir__S_cur: std__Ios_Seekdir = 1;
pub const std__Ios_Seekdir__S_end: std__Ios_Seekdir = 2;
pub const std__Ios_Seekdir__S_ios_seekdir_end: std__Ios_Seekdir = 65536;
pub type std__Ios_Seekdir = ::std::os::raw::c_uint;
pub const std_io_errc_stream: std_io_errc = 1;
pub type std_io_errc = ::std::os::raw::c_int;
#[test]
fn __bindgen_test_layout_std_is_error_code_enum_open0_std_io_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt17iostream_categoryv"]
    pub fn std_iostream_category() -> *const std_error_category;
}
#[repr(C)]
pub struct std_ios_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base {
    pub vtable_: *const std_ios_base__bindgen_vtable,
    pub _M_precision: std_streamsize,
    pub _M_width: std_streamsize,
    pub _M_flags: std_ios_base_fmtflags,
    pub _M_exception: std_ios_base_iostate,
    pub _M_streambuf_state: std_ios_base_iostate,
    pub _M_callbacks: *mut std_ios_base__Callback_list,
    pub _M_word_zero: std_ios_base__Words,
    pub _M_local_word: [std_ios_base__Words; 8usize],
    pub _M_word_size: ::std::os::raw::c_int,
    pub _M_word: *mut std_ios_base__Words,
    pub _M_ios_locale: std_locale,
}
#[repr(C)]
pub struct std_ios_base_failure {
    pub _base: std_system_error,
}
#[test]
fn bindgen_test_layout_std_ios_base_failure() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_failure>(),
        32usize,
        concat!("Size of: ", stringify!(std_ios_base_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_failure>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base_failure))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_ios_base_failure_failure(this: *mut std_ios_base_failure, __str: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code"]
    pub fn std_ios_base_failure_failure1(
        this: *mut std_ios_base_failure,
        arg1: *const std_string,
        arg2: *const std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code"]
    pub fn std_ios_base_failure_failure2(
        this: *mut std_ios_base_failure,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_error_code,
    );
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__str: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
}
pub use self::std__Ios_Fmtflags as std_ios_base_fmtflags;
pub use self::std__Ios_Iostate as std_ios_base_iostate;
pub use self::std__Ios_Openmode as std_ios_base_openmode;
pub use self::std__Ios_Seekdir as std_ios_base_seekdir;
pub const std_ios_base_event_erase_event: std_ios_base_event = 0;
pub const std_ios_base_event_imbue_event: std_ios_base_event = 1;
pub const std_ios_base_event_copyfmt_event: std_ios_base_event = 2;
pub type std_ios_base_event = ::std::os::raw::c_uint;
pub type std_ios_base_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        __e: std_ios_base_event,
        __b: *mut std_ios_base,
        __i: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Callback_list {
    pub _M_next: *mut std_ios_base__Callback_list,
    pub _M_fn: std_ios_base_event_callback,
    pub _M_index: ::std::os::raw::c_int,
    pub _M_refcount: _Atomic_word,
}
#[test]
fn bindgen_test_layout_std_ios_base__Callback_list() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base__Callback_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Callback_list>(),
        24usize,
        concat!("Size of: ", stringify!(std_ios_base__Callback_list))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Callback_list>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base__Callback_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Words {
    pub _M_pword: *mut ::std::os::raw::c_void,
    pub _M_iword: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std_ios_base__Words() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base__Words> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Words>(),
        16usize,
        concat!("Size of: ", stringify!(std_ios_base__Words))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Words>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base__Words))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_pword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Words),
            "::",
            stringify!(_M_pword)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_iword) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Words),
            "::",
            stringify!(_M_iword)
        )
    );
}
pub const std_ios_base__S_local_word_size: std_ios_base__bindgen_ty_1 = 8;
pub type std_ios_base__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_Init {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE"]
    pub static mut std_ios_base_Init__S_refcount: _Atomic_word;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
    pub static mut std_ios_base_Init__S_synced_with_stdio: bool;
}
#[test]
fn bindgen_test_layout_std_ios_base_Init() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_Init>(),
        1usize,
        concat!("Size of: ", stringify!(std_ios_base_Init))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_Init>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ios_base_Init))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitC1Ev"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitD1Ev"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9boolalphaE"]
    pub static std_ios_base_boolalpha: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3decE"]
    pub static std_ios_base_dec: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5fixedE"]
    pub static std_ios_base_fixed: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3hexE"]
    pub static std_ios_base_hex: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8internalE"]
    pub static std_ios_base_internal: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4leftE"]
    pub static std_ios_base_left: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3octE"]
    pub static std_ios_base_oct: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5rightE"]
    pub static std_ios_base_right: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10scientificE"]
    pub static std_ios_base_scientific: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8showbaseE"]
    pub static std_ios_base_showbase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9showpointE"]
    pub static std_ios_base_showpoint: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7showposE"]
    pub static std_ios_base_showpos: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6skipwsE"]
    pub static std_ios_base_skipws: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7unitbufE"]
    pub static std_ios_base_unitbuf: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9uppercaseE"]
    pub static std_ios_base_uppercase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11adjustfieldE"]
    pub static std_ios_base_adjustfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9basefieldE"]
    pub static std_ios_base_basefield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10floatfieldE"]
    pub static std_ios_base_floatfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6badbitE"]
    pub static std_ios_base_badbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6eofbitE"]
    pub static std_ios_base_eofbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failbitE"]
    pub static std_ios_base_failbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7goodbitE"]
    pub static std_ios_base_goodbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3appE"]
    pub static std_ios_base_app: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3ateE"]
    pub static std_ios_base_ate: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6binaryE"]
    pub static std_ios_base_binary: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base2inE"]
    pub static std_ios_base_in: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3outE"]
    pub static std_ios_base_out: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5truncE"]
    pub static std_ios_base_trunc: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3begE"]
    pub static std_ios_base_beg: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3curE"]
    pub static std_ios_base_cur: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3endE"]
    pub static std_ios_base_end: std_ios_base_seekdir;
}
#[test]
fn bindgen_test_layout_std_ios_base() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base>(),
        216usize,
        concat!("Size of: ", stringify!(std_ios_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_precision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_exception) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_streambuf_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_streambuf_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_callbacks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word_zero) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word_zero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_local_word) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_local_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_ios_locale) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_ios_locale)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
    pub fn std_ios_base_register_callback(
        this: *mut std_ios_base,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
    pub fn std_ios_base__M_call_callbacks(this: *mut std_ios_base, __ev: std_ios_base_event);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv"]
    pub fn std_ios_base__M_dispose_callbacks(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib"]
    pub fn std_ios_base__M_grow_words(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_initEv"]
    pub fn std_ios_base__M_init(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base, __loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6xallocEv"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_"]
    pub fn std_ios_base__M_move(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_"]
    pub fn std_ios_base__M_swap(this: *mut std_ios_base, __rhs: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseC1Ev"]
    pub fn std_ios_base_ios_base(this: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn register_callback(
        &mut self,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    ) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn _M_call_callbacks(&mut self, __ev: std_ios_base_event) {
        std_ios_base__M_call_callbacks(self, __ev)
    }
    #[inline]
    pub unsafe fn _M_dispose_callbacks(&mut self) {
        std_ios_base__M_dispose_callbacks(self)
    }
    #[inline]
    pub unsafe fn _M_grow_words(
        &mut self,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words {
        std_ios_base__M_grow_words(self, __index, __iword)
    }
    #[inline]
    pub unsafe fn _M_init(&mut self) {
        std_ios_base__M_init(self)
    }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int {
        std_ios_base_xalloc()
    }
    #[inline]
    pub unsafe fn _M_move(&mut self, arg1: *mut std_ios_base) {
        std_ios_base__M_move(self, arg1)
    }
    #[inline]
    pub unsafe fn _M_swap(&mut self, __rhs: *mut std_ios_base) {
        std_ios_base__M_swap(self, __rhs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_ios_base(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev"]
    pub fn std_ios_base_failure_failure_destructor(this: *mut std_ios_base_failure);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv"]
    pub fn std_ios_base_failure_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseD1Ev"]
    pub fn std_ios_base_ios_base_destructor(this: *mut std_ios_base);
}
#[repr(C)]
pub struct std_basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_streambuf<_CharT> {
    pub vtable_: *const std_basic_streambuf__bindgen_vtable,
    pub _M_in_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_buf_locale: std_locale,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_streambuf_char_type<_CharT> = _CharT;
pub type std_basic_streambuf_traits_type<_Traits> = _Traits;
pub type std_basic_streambuf_int_type = [u8; 0usize];
pub type std_basic_streambuf_pos_type = [u8; 0usize];
pub type std_basic_streambuf_off_type = [u8; 0usize];
pub type std_basic_streambuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_streambuf_char_type<_CharT>>;
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIcSt11char_traitsIcEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof(
        __sbin: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __sbout: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIwSt11char_traitsIwEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof1(
        __sbin: *mut std_basic_streambuf<u32>,
        __sbout: *mut std_basic_streambuf<u32>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_base {
    pub _address: u8,
}
pub type std_ctype_base___to_type = *const ::std::os::raw::c_int;
pub type std_ctype_base_mask = ::std::os::raw::c_ushort;
pub const std_ctype_base_upper: std_ctype_base_mask = 256;
pub const std_ctype_base_lower: std_ctype_base_mask = 512;
pub const std_ctype_base_alpha: std_ctype_base_mask = 1024;
pub const std_ctype_base_digit: std_ctype_base_mask = 2048;
pub const std_ctype_base_xdigit: std_ctype_base_mask = 4096;
pub const std_ctype_base_space: std_ctype_base_mask = 8192;
pub const std_ctype_base_print: std_ctype_base_mask = 16384;
pub const std_ctype_base_graph: std_ctype_base_mask = 3076;
pub const std_ctype_base_cntrl: std_ctype_base_mask = 2;
pub const std_ctype_base_punct: std_ctype_base_mask = 4;
pub const std_ctype_base_alnum: std_ctype_base_mask = 3072;
pub const std_ctype_base_blank: std_ctype_base_mask = 1;
#[test]
fn bindgen_test_layout_std_ctype_base() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_base>(),
        1usize,
        concat!("Size of: ", stringify!(std_ctype_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ctype_base))
    );
}
#[repr(C)]
pub struct std_istreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _M_c: std_istreambuf_iterator_int_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = [u8; 0usize];
pub type std_istreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_istreambuf_iterator_istream_type<_CharT> = std_basic_istream<_CharT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_ostreambuf_iterator_streambuf_type<_CharT>,
    pub _M_failed: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_ostreambuf_iterator_ostream_type<_CharT> = std_basic_ostream<_CharT>;
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f32,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v1(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f64,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v2(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut u128,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___pad {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___ctype_abstract_base {
    pub _base: std_locale_facet,
}
pub type std___ctype_abstract_base_char_type<_CharT> = _CharT;
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype {
    pub _base: std___ctype_abstract_base,
}
pub type std_ctype_char_type<_CharT> = _CharT;
pub type std_ctype_mask = std___ctype_abstract_base;
#[test]
fn __bindgen_test_layout_std_ctype_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        576usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        1344usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype_byname {
    pub _base: std_ctype,
}
pub type std_ctype_byname_mask = std_ctype;
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        576usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        1344usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_base {
    pub _address: u8,
}
pub const std___num_base__S_ominus: std___num_base__bindgen_ty_1 = 0;
pub const std___num_base__S_oplus: std___num_base__bindgen_ty_1 = 1;
pub const std___num_base__S_ox: std___num_base__bindgen_ty_1 = 2;
pub const std___num_base__S_oX: std___num_base__bindgen_ty_1 = 3;
pub const std___num_base__S_odigits: std___num_base__bindgen_ty_1 = 4;
pub const std___num_base__S_odigits_end: std___num_base__bindgen_ty_1 = 20;
pub const std___num_base__S_oudigits: std___num_base__bindgen_ty_1 = 20;
pub const std___num_base__S_oudigits_end: std___num_base__bindgen_ty_1 = 36;
pub const std___num_base__S_oe: std___num_base__bindgen_ty_1 = 18;
pub const std___num_base__S_oE: std___num_base__bindgen_ty_1 = 34;
pub const std___num_base__S_oend: std___num_base__bindgen_ty_1 = 36;
pub type std___num_base__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const std___num_base__S_iminus: std___num_base__bindgen_ty_2 = 0;
pub const std___num_base__S_iplus: std___num_base__bindgen_ty_2 = 1;
pub const std___num_base__S_ix: std___num_base__bindgen_ty_2 = 2;
pub const std___num_base__S_iX: std___num_base__bindgen_ty_2 = 3;
pub const std___num_base__S_izero: std___num_base__bindgen_ty_2 = 4;
pub const std___num_base__S_ie: std___num_base__bindgen_ty_2 = 18;
pub const std___num_base__S_iE: std___num_base__bindgen_ty_2 = 24;
pub const std___num_base__S_iend: std___num_base__bindgen_ty_2 = 26;
pub type std___num_base__bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base12_S_atoms_outE"]
    pub static mut std___num_base__S_atoms_out: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base11_S_atoms_inE"]
    pub static mut std___num_base__S_atoms_in: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_std___num_base() {
    assert_eq!(
        ::std::mem::size_of::<std___num_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___num_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___num_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___num_base))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base15_S_format_floatERKSt8ios_basePcc"]
    pub fn std___num_base__S_format_float(
        __io: *const std_ios_base,
        __fptr: *mut ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    );
}
impl std___num_base {
    #[inline]
    pub unsafe fn _S_format_float(
        __io: *const std_ios_base,
        __fptr: *mut ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    ) {
        std___num_base__S_format_float(__io, __fptr, __mod)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std___numpunct_cache<_CharT> {
    pub _base: std_locale_facet,
    pub _M_grouping: *const ::std::os::raw::c_char,
    pub _M_grouping_size: usize,
    pub _M_use_grouping: bool,
    pub _M_truename: *const _CharT,
    pub _M_truename_size: usize,
    pub _M_falsename: *const _CharT,
    pub _M_falsename_size: usize,
    pub _M_decimal_point: _CharT,
    pub _M_thousands_sep: _CharT,
    pub _M_atoms_out: [_CharT; 36usize],
    pub _M_atoms_in: [_CharT; 26usize],
    pub _M_allocated: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_num_get {
    pub _base: std_locale_facet,
}
pub type std_num_get_char_type<_CharT> = _CharT;
pub type std_num_get_iter_type<_InIter> = _InIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_num_put {
    pub _base: std_locale_facet,
}
pub type std_num_put_char_type<_CharT> = _CharT;
pub type std_num_put_iter_type<_OutIter> = _OutIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___use_cache {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__verify_groupingPKcmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___verify_grouping(
        __grouping: *const ::std::os::raw::c_char,
        __grouping_size: usize,
        __grouping_tmp: *const std_string,
    ) -> bool;
}
#[test]
fn __bindgen_test_layout_std_numpunct_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct<::std::os::raw::c_char>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct_byname<::std::os::raw::c_char>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct_byname<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct_byname<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct_byname<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_get>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_get))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_put>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_put))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_put)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numpunct_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct<u32>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numpunct_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numpunct_byname<u32>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numpunct_byname<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numpunct_byname<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numpunct_byname<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_get>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_get))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_get>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_get)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_num_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_num_put>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(std_num_put))
    );
    assert_eq!(
        ::std::mem::align_of::<std_num_put>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_num_put)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ios<_CharT> {
    pub _base: std_ios_base,
    pub _M_tie: *mut std_basic_ostream<_CharT>,
    pub _M_fill: std_basic_ios_char_type<_CharT>,
    pub _M_fill_init: bool,
    pub _M_streambuf: *mut std_basic_streambuf<_CharT>,
    pub _M_ctype: *const std_basic_ios___ctype_type,
    pub _M_num_put: *const std_basic_ios___num_put_type,
    pub _M_num_get: *const std_basic_ios___num_get_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_ios_char_type<_CharT> = _CharT;
pub type std_basic_ios_int_type = [u8; 0usize];
pub type std_basic_ios_pos_type = [u8; 0usize];
pub type std_basic_ios_off_type = [u8; 0usize];
pub type std_basic_ios_traits_type<_Traits> = _Traits;
pub type std_basic_ios___ctype_type = std_ctype;
pub type std_basic_ios___num_put_type = std_num_put;
pub type std_basic_ios___num_get_type = std_num_get;
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios<::std::os::raw::c_char>>(),
        264usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios<u32>>(),
        264usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios<u32>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_ostream_char_type<_CharT> = _CharT;
pub type std_basic_ostream_int_type = [u8; 0usize];
pub type std_basic_ostream_pos_type = [u8; 0usize];
pub type std_basic_ostream_off_type = [u8; 0usize];
pub type std_basic_ostream_traits_type<_Traits> = _Traits;
pub type std_basic_ostream___streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_basic_ostream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_ostream___ostream_type<_CharT> = std_basic_ostream<_CharT>;
pub type std_basic_ostream___num_put_type = std_num_put;
pub type std_basic_ostream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream_sentry {
    pub _M_ok: bool,
    pub _M_os: *mut std_basic_ostream<_CharT>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_ostream_impl {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_ostream_impl___ostream_type = ::std::os::raw::c_void;
pub type std___do_is_convertible_to_basic_ostream_impl = std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_ostream {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_ostream_type = std___not_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_insertable {
    pub _base: std_false_type,
}
pub type std___rvalue_ostream_type = std___is_convertible_to_basic_ostream;
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream<::std::os::raw::c_char>>(),
        272usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream<u32>>(),
        272usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream<u32>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_istream<_CharT> {
    pub _M_gcount: std_streamsize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_istream_char_type<_CharT> = _CharT;
pub type std_basic_istream_int_type = [u8; 0usize];
pub type std_basic_istream_pos_type = [u8; 0usize];
pub type std_basic_istream_off_type = [u8; 0usize];
pub type std_basic_istream_traits_type<_Traits> = _Traits;
pub type std_basic_istream___streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_basic_istream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_istream___istream_type<_CharT> = std_basic_istream<_CharT>;
pub type std_basic_istream___num_get_type = std_num_get;
pub type std_basic_istream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _M_ok: bool,
}
pub type std_basic_istream_sentry_traits_type = _Traits;
pub type std_basic_istream_sentry___streambuf_type = std_basic_streambuf<_CharT>;
pub type std_basic_istream_sentry___istream_type = std_basic_istream<_CharT>;
pub type std_basic_istream_sentry___ctype_type = std_basic_istream___ctype_type;
pub type std_basic_istream_sentry___int_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_iostream<_CharT> {
    pub _base: std_basic_istream<_CharT>,
    pub _base_1: std_basic_ostream<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_iostream_char_type<_CharT> = _CharT;
pub type std_basic_iostream_int_type = [u8; 0usize];
pub type std_basic_iostream_pos_type = [u8; 0usize];
pub type std_basic_iostream_off_type = [u8; 0usize];
pub type std_basic_iostream_traits_type<_Traits> = _Traits;
pub type std_basic_iostream___istream_type<_CharT> = std_basic_istream<_CharT>;
pub type std_basic_iostream___ostream_type<_CharT> = std_basic_ostream<_CharT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_istream_impl {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_istream_impl___istream_type = ::std::os::raw::c_void;
pub type std___do_is_convertible_to_basic_istream_impl = std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_istream {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_istream_type = std___not_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_extractable {
    pub _base: std_false_type,
}
pub type std___rvalue_istream_type = std___is_convertible_to_basic_istream;
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream<::std::os::raw::c_char>>(),
        288usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<u32>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream<u32>>(),
        288usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringbuf<::std::os::raw::c_char>>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringbuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringbuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringbuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istringstream<::std::os::raw::c_char>>(),
        384usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostringstream<::std::os::raw::c_char>>(),
        376usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringstream<::std::os::raw::c_char>>(),
        392usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringbuf<u32>>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringbuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringbuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringbuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istringstream<u32>>(),
        384usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istringstream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostringstream<u32>>(),
        376usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostringstream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringstream<u32>>(),
        392usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringstream<u32>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_complex<_Tp> {
    pub _M_real: _Tp,
    pub _M_imag: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_complex_value_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
pub type std_byte = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___byte_operand {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___byte_operand_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___byte_operand>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___byte_operand)
        )
    );
}
pub type std___byte_op_t = std___byte_operand;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type<_Tp> = _Tp;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_in_place_t() {
    assert_eq!(
        ::std::mem::size_of::<std_in_place_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_in_place_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_in_place_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_in_place_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt8in_place"]
    pub static std_in_place: std_in_place_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_type_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_in_place_type_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_in_place_type {
    pub _base: std___is_in_place_type_impl,
}
pub type std___array_traits__Type<_Tp> = *mut _Tp;
pub type std___array_traits__Is_swappable = std___is_swappable;
pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable;
pub type std_array_value_type<_Tp> = _Tp;
pub type std_array_pointer<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_pointer<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_reference<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_reference<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_iterator<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_iterator<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_size_type = usize;
pub type std_array_difference_type = isize;
pub type std_array_reverse_iterator<_Tp> = std_reverse_iterator<std_array_iterator<_Tp>>;
pub type std_array_const_reverse_iterator<_Tp> =
    std_reverse_iterator<std_array_const_iterator<_Tp>>;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___erased_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___erased_type() {
    assert_eq!(
        ::std::mem::size_of::<std___erased_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___erased_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___erased_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___erased_type))
    );
}
pub type std___is_erased_or_convertible = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_allocator_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_allocator_arg_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt13allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc_base() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0 {
    pub _M_a: std___uses_alloc0__Sink,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0__Sink {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc0__Sink() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0__Sink))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0__Sink))
    );
}
#[test]
fn bindgen_test_layout_std___uses_alloc0() {
    const UNINIT: ::std::mem::MaybeUninit<std___uses_alloc0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___uses_alloc0),
            "::",
            stringify!(_M_a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___uses_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_predicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__TC2 {
    pub _address: u8,
}
pub type std_tuple__TCC = u8;
pub type std_tuple__TMC = u8;
pub type std_tuple__TMCT = u8;
pub type std_tuple__TNTC = u8;
#[test]
fn __bindgen_test_layout_std_tuple_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_tuple>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_tuple))
    );
    assert_eq!(
        ::std::mem::align_of::<std_tuple>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_tuple)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___combine_tuples_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___combine_tuples>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___combine_tuples)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___combine_tuples>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___combine_tuples)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = std___combine_tuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___make_1st_indices_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_1st_indices>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_1st_indices)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_1st_indices>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_1st_indices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Swallow_assign {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Swallow_assign() {
    assert_eq!(
        ::std::mem::size_of::<std__Swallow_assign>(),
        1usize,
        concat!("Size of: ", stringify!(std__Swallow_assign))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Swallow_assign>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Swallow_assign))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt6ignore"]
    pub static std_ignore: std__Swallow_assign;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits_base {
    pub _address: u8,
}
pub type std__Mem_fn_traits_base___result_type<_Res> = _Res;
pub type std__Mem_fn_traits_base___maybe_type = std__Maybe_unary_or_binary_function;
pub type std__Mem_fn_traits_base___arity = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_get_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub _M_data: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_reference_wrapper___not_same = u8;
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_function_call>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_function_call))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_function_call>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_function_call))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt17bad_function_callD1Ev"]
    pub fn std_bad_function_call_bad_function_call_destructor(this: *mut std_bad_function_call);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt17bad_function_call4whatEv"]
    pub fn std_bad_function_call_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_location_invariant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Undefined_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Nocopy_types {
    pub _M_object: *mut ::std::os::raw::c_void,
    pub _M_const_object: *const ::std::os::raw::c_void,
    pub _M_function_pointer: ::std::option::Option<unsafe extern "C" fn()>,
    pub _M_member_pointer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_std__Nocopy_types() {
    const UNINIT: ::std::mem::MaybeUninit<std__Nocopy_types> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Nocopy_types>(),
        16usize,
        concat!("Size of: ", stringify!(std__Nocopy_types))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Nocopy_types>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Nocopy_types))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_const_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_const_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_function_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_function_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_member_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_member_pointer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Any_data {
    pub _M_unused: std__Nocopy_types,
    pub _M_pod_data: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_std__Any_data() {
    const UNINIT: ::std::mem::MaybeUninit<std__Any_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Any_data>(),
        16usize,
        concat!("Size of: ", stringify!(std__Any_data))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Any_data>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Any_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Any_data),
            "::",
            stringify!(_M_unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_pod_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Any_data),
            "::",
            stringify!(_M_pod_data)
        )
    );
}
pub const std__Manager_operation___get_type_info: std__Manager_operation = 0;
pub const std__Manager_operation___get_functor_ptr: std__Manager_operation = 1;
pub const std__Manager_operation___clone_functor: std__Manager_operation = 2;
pub const std__Manager_operation___destroy_functor: std__Manager_operation = 3;
pub type std__Manager_operation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Simple_type_wrapper<_Tp> {
    pub __value: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Function_base {
    pub _M_functor: std__Any_data,
    pub _M_manager: std__Function_base__Manager_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_base__Base_manager {
    pub _address: u8,
}
pub type std__Function_base__Base_manager__Local_storage = u8;
pub type std__Function_base__Manager_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut std__Any_data,
        arg2: *const std__Any_data,
        arg3: std__Manager_operation,
    ) -> bool,
>;
pub const std__Function_base__M_max_size: usize = 16;
pub const std__Function_base__M_max_align: usize = 8;
#[test]
fn bindgen_test_layout_std__Function_base() {
    const UNINIT: ::std::mem::MaybeUninit<std__Function_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Function_base>(),
        24usize,
        concat!("Size of: ", stringify!(std__Function_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Function_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Function_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_functor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Function_base),
            "::",
            stringify!(_M_functor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_manager) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Function_base),
            "::",
            stringify!(_M_manager)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function_guide_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Enable_default_constructor_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Enable_default_constructor_tag() {
    assert_eq!(
        ::std::mem::size_of::<std__Enable_default_constructor_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std__Enable_default_constructor_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Enable_default_constructor_tag>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std__Enable_default_constructor_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullopt_t {
    pub _address: u8,
}
pub const std_nullopt_t__Construct__Token: std_nullopt_t__Construct = 0;
pub type std_nullopt_t__Construct = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_std_nullopt_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nullopt_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nullopt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullopt_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nullopt_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7nullopt"]
    pub static std_nullopt: std_nullopt_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_optional_access {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_optional_access() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_optional_access>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_optional_access))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_optional_access>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_optional_access))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Optional_payload_base {
    pub _M_payload: u8,
    pub _M_engaged: bool,
}
pub type std__Optional_payload_base__Stored_type = std_remove_const_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Optional_payload_base__Empty_byte {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Optional_base_impl {
    pub _address: u8,
}
pub type std__Optional_base_impl__Stored_type = std_remove_const_t;
pub type std___converts_from_optional = std___or_;
pub type std___assigns_from_optional = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional__Base = u8;
pub type std_optional___not_self = std___not_;
pub type std_optional___not_tag = std___not_;
pub type std_optional__Requires = std_enable_if_t;
pub type std_optional_value_type<_Tp> = _Tp;
pub type std___optional_relop_t = std_enable_if_t;
#[repr(C)]
#[derive(Debug)]
pub struct std__Node_handle_common {
    pub _M_ptr: std__Node_handle_common__AllocTraits,
    pub _M_alloc: std_optional,
}
pub type std__Node_handle_common__AllocTraits = std_allocator_traits;
pub type std__Node_handle_common_allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug)]
pub struct std__Node_handle {
    pub _base: std__Node_handle_common,
    pub _M_pkey: std__Node_handle___pointer,
    pub _M_pmapped: std__Node_handle___pointer,
}
pub type std__Node_handle_key_type<_Key> = _Key;
pub type std__Node_handle_mapped_type = [u8; 0usize];
pub type std__Node_handle__AllocTraits = std_allocator_traits;
pub type std__Node_handle___pointer = std___ptr_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Node_insert_return<_Iterator, _NodeHandle> {
    pub position: _Iterator,
    pub inserted: bool,
    pub node: _NodeHandle,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
}
pub type std___cache_default = std___not_;
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable<_RehashPolicy> {
    pub _M_buckets: *mut std__Hashtable___bucket_type,
    pub _M_bucket_count: std__Hashtable_size_type,
    pub _M_before_begin: std__Hashtable___node_base,
    pub _M_element_count: std__Hashtable_size_type,
    pub _M_rehash_policy: _RehashPolicy,
    pub _M_single_bucket: std__Hashtable___bucket_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RehashPolicy>>,
}
pub type std__Hashtable___traits_type<_Traits> = _Traits;
pub type std__Hashtable___hash_cached = [u8; 0usize];
pub type std__Hashtable___node_type = u8;
pub type std__Hashtable___node_alloc_type = std___alloc_rebind;
pub type std__Hashtable___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std__Hashtable___value_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_base = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___bucket_type = std__Hashtable___hashtable_alloc;
pub type std__Hashtable_key_type<_Key> = _Key;
pub type std__Hashtable_value_type<_Value> = _Value;
pub type std__Hashtable_allocator_type<_Alloc> = _Alloc;
pub type std__Hashtable_key_equal<_Equal> = _Equal;
pub type std__Hashtable_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_const_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_reference<_Value> = *mut std__Hashtable_value_type<_Value>;
pub type std__Hashtable_const_reference<_Value> = *const std__Hashtable_value_type<_Value>;
pub type std__Hashtable___rehash_type<_RehashPolicy> = _RehashPolicy;
pub type std__Hashtable___rehash_state = [u8; 0usize];
pub type std__Hashtable___constant_iterators = [u8; 0usize];
pub type std__Hashtable___unique_keys = [u8; 0usize];
pub type std__Hashtable___key_extract = u8;
pub type std__Hashtable___hashtable_base = std___detail__Hashtable_base;
pub type std__Hashtable___hash_code_base = std__Hashtable___hashtable_base;
pub type std__Hashtable___hash_code = std__Hashtable___hashtable_base;
pub type std__Hashtable___ireturn_type = std__Hashtable___hashtable_base;
pub type std__Hashtable___map_base = u8;
pub type std__Hashtable___rehash_base = std___detail__Rehash_base;
pub type std__Hashtable___eq_base = u8;
pub type std__Hashtable___reuse_or_alloc_node_type = std___detail__ReuseOrAllocNode;
pub type std__Hashtable___if_hash_cached = std___or_;
pub type std__Hashtable___if_hash_not_cached = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hashtable___hash_code_base_access {
    pub _address: u8,
}
pub type std__Hashtable_size_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_difference_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_local_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_local_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_node_type = std__Node_handle;
pub type std__Hashtable_insert_return_type =
    std__Node_insert_return<std__Hashtable_iterator, std__Hashtable_node_type>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_merge_helper {
    pub _address: u8,
}
pub type std__RequireNotAllocatorOrIntegral = std___enable_if_t;
pub type std___umap_traits = u8;
pub type std___umap_hashtable = std__Hashtable<_RehashPolicy>;
pub type std___ummap_traits = u8;
pub type std___ummap_hashtable = std__Hashtable<_RehashPolicy>;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_map {
    pub _M_h: std_unordered_map__Hashtable,
}
pub type std_unordered_map__Hashtable = std___umap_hashtable;
pub type std_unordered_map_key_type = std_unordered_map__Hashtable;
pub type std_unordered_map_value_type = std_unordered_map__Hashtable;
pub type std_unordered_map_mapped_type = std_unordered_map__Hashtable;
pub type std_unordered_map_hasher = std_unordered_map__Hashtable;
pub type std_unordered_map_key_equal = std_unordered_map__Hashtable;
pub type std_unordered_map_allocator_type = std_unordered_map__Hashtable;
pub type std_unordered_map_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_const_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_const_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_size_type = std_unordered_map__Hashtable;
pub type std_unordered_map_difference_type = std_unordered_map__Hashtable;
pub type std_unordered_map_node_type = std_unordered_map__Hashtable;
pub type std_unordered_map_insert_return_type = std_unordered_map__Hashtable;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_multimap {
    pub _M_h: std_unordered_multimap__Hashtable,
}
pub type std_unordered_multimap__Hashtable = std___ummap_hashtable;
pub type std_unordered_multimap_key_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_value_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_mapped_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_hasher = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_key_equal = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_allocator_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_size_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_difference_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_node_type = std_unordered_multimap__Hashtable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bitwise_relocatable {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = usize;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
pub type std__Bit_type = ::std::os::raw::c_ulong;
pub const _S_word_bit: std__bindgen_ty_1 = 64;
pub type std__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_reference {
    pub _M_p: *mut std__Bit_type,
    pub _M_mask: std__Bit_type,
}
#[test]
fn bindgen_test_layout_std__Bit_reference() {
    const UNINIT: ::std::mem::MaybeUninit<std__Bit_reference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Bit_reference>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_reference))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_reference>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_reference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_reference),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_reference),
            "::",
            stringify!(_M_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator_base {
    pub _M_p: *mut std__Bit_type,
    pub _M_offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_std__Bit_iterator_base() {
    const UNINIT: ::std::mem::MaybeUninit<std__Bit_iterator_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator_base>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_iterator_base),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_iterator_base),
            "::",
            stringify!(_M_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_iterator_reference = std__Bit_reference;
pub type std__Bit_iterator_pointer = *mut std__Bit_reference;
#[test]
fn bindgen_test_layout_std__Bit_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_const_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_const_iterator_reference = bool;
pub type std__Bit_const_iterator_const_reference = bool;
pub type std__Bit_const_iterator_pointer = *const bool;
#[test]
fn bindgen_test_layout_std__Bit_const_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_const_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_const_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_const_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_const_iterator))
    );
}
#[repr(C)]
pub struct std__Bvector_base {
    pub _M_impl: std__Bvector_base__Bvector_impl,
}
pub type std__Bvector_base__Bit_alloc_type = [u8; 0usize];
pub type std__Bvector_base__Bit_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Bvector_base__Bit_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl_data {
    pub _M_start: std__Bit_iterator,
    pub _M_finish: std__Bit_iterator,
    pub _M_end_of_storage: std__Bvector_base__Bit_pointer,
}
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl {
    pub _base_1: std__Bvector_base__Bvector_impl_data,
}
pub type std__Bvector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_buffer<_Tp> {
    pub _M_original_len: std__Temporary_buffer_size_type,
    pub _M_len: std__Temporary_buffer_size_type,
    pub _M_buffer: std__Temporary_buffer_pointer<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std__Temporary_buffer_value_type<_Tp> = _Tp;
pub type std__Temporary_buffer_pointer<_Tp> = *mut std__Temporary_buffer_value_type<_Tp>;
pub type std__Temporary_buffer_iterator<_Tp> = std__Temporary_buffer_pointer<_Tp>;
pub type std__Temporary_buffer_size_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub _M_param: std_uniform_int_distribution_param_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub _M_a: _IntType,
    pub _M_b: _IntType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
pub const _S_threshold: std__bindgen_ty_2 = 16;
pub type std__bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _S_chunk_size: std__bindgen_ty_3 = 7;
pub type std__bindgen_ty_3 = ::std::os::raw::c_uint;
pub type std__Mem_fn_base__Traits = std__Mem_fn_traits;
pub type std__Mem_fn_base__Arity = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base__Varargs = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base_result_type = std__Mem_fn_base__Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_bind_expression {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_placeholder {
    pub _base: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_1E"]
    pub static std_placeholders__1: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_2E"]
    pub static std_placeholders__2: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_3E"]
    pub static std_placeholders__3: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_4E"]
    pub static std_placeholders__4: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_5E"]
    pub static std_placeholders__5: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_6E"]
    pub static std_placeholders__6: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_7E"]
    pub static std_placeholders__7: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_8E"]
    pub static std_placeholders__8: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_9E"]
    pub static std_placeholders__9: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_10E"]
    pub static std_placeholders__10: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_11E"]
    pub static std_placeholders__11: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_12E"]
    pub static std_placeholders__12: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_13E"]
    pub static std_placeholders__13: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_14E"]
    pub static std_placeholders__14: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_15E"]
    pub static std_placeholders__15: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_16E"]
    pub static std_placeholders__16: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_17E"]
    pub static std_placeholders__17: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_18E"]
    pub static std_placeholders__18: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_19E"]
    pub static std_placeholders__19: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_20E"]
    pub static std_placeholders__20: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_21E"]
    pub static std_placeholders__21: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_22E"]
    pub static std_placeholders__22: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_23E"]
    pub static std_placeholders__23: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_24E"]
    pub static std_placeholders__24: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_25E"]
    pub static std_placeholders__25: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_26E"]
    pub static std_placeholders__26: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_27E"]
    pub static std_placeholders__27: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_28E"]
    pub static std_placeholders__28: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_29E"]
    pub static std_placeholders__29: u8;
}
pub type std__Safe_tuple_element_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_result {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_check_arity {
    pub _address: u8,
}
pub type std___is_socketlike = std___or_;
pub type std__Bind_helper___func_type = std_decay;
pub type std__Bind_helper_type = std__Bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bindres_helper {
    pub _address: u8,
}
pub type std__Bindres_helper___functor_type = std_decay;
pub type std__Bindres_helper_type = std__Bind_result;
#[repr(C)]
#[derive(Debug)]
pub struct std__Not_fn<_Fn> {
    pub _M_fn: _Fn,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
pub type std__Not_fn___inv_res_t = std___invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte_like {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_byte_like_open0_std_byte_std_equal_to_open1_std_byte_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_like_open0_std_byte_std_equal_to_open1_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_searcher {
    pub _M_m: std_tuple,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___boyer_moore_map_base {
    pub _M_bad_char: std_unordered_map,
}
pub type std___boyer_moore_map_base___diff_type<_Tp> = _Tp;
pub type std___boyer_moore_array_base___diff_type<_Tp> = _Tp;
pub type std___boyer_moore_base_t = std_conditional_t;
#[repr(C)]
pub struct std_boyer_moore_searcher<_RAIter> {
    pub _M_pat: _RAIter,
    pub _M_pat_end: _RAIter,
    pub _M_good_suffix: std_vector,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RAIter>>,
}
pub type std_boyer_moore_searcher__Base = std___boyer_moore_base_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_boyer_moore_horspool_searcher<_RAIter> {
    pub _M_pat: _RAIter,
    pub _M_pat_end: _RAIter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RAIter>>,
}
pub type std_boyer_moore_horspool_searcher__Base = std___boyer_moore_base_t;
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_Eigen_half_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_Eigen_half_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_Eigen_half_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_Eigen_half_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_Eigen_half_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub _M_iter: _OutputIterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutputIterator>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub _M_t: std___uniq_ptr_impl,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__MakeUniq {
    pub _address: u8,
}
pub type std__MakeUniq___single_object = std_unique_ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std___allocated_ptr<_Alloc> {
    pub _M_alloc: *mut _Alloc,
    pub _M_ptr: std___allocated_ptr_pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocated_ptr_pointer = std_allocator_traits;
pub type std___allocated_ptr_value_type = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt12bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
pub const std__Mutex_base__S_need_barriers: std__Mutex_base__bindgen_ty_1 = 0;
pub type std__Mutex_base__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock"]
    pub fn std__Sp_counted_base__M_add_ref_lock(this: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock_nothrow"]
    pub fn std__Sp_counted_base__M_add_ref_lock_nothrow(this: *mut u8) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_deleter__Impl<_Ptr> {
    pub _M_ptr: _Ptr,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ptr>>,
}
pub type std__Sp_counted_deleter__Impl__Del_base = u8;
pub type std__Sp_counted_deleter__Impl__Alloc_base = u8;
pub type std__Sp_counted_deleter___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_make_shared_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Sp_make_shared_tag() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std__Sp_make_shared_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_make_shared_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_alloc_shared_tag<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_ptr_inplace__Impl {
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std__Sp_counted_ptr_inplace__Impl__A_base = u8;
pub type std__Sp_counted_ptr_inplace___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_array_delete {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___sp_array_delete() {
    assert_eq!(
        ::std::mem::size_of::<std___sp_array_delete>(),
        1usize,
        concat!("Size of: ", stringify!(std___sp_array_delete))
    );
    assert_eq!(
        ::std::mem::align_of::<std___sp_array_delete>(),
        1usize,
        concat!("Alignment of ", stringify!(std___sp_array_delete))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_count___not_alloc_shared_tag {
    pub _address: u8,
}
pub type std___shared_count___not_alloc_shared_tag_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_compatible_with {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible_arr {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible {
    pub _address: u8,
}
pub type std___shared_ptr_access_element_type<_Tp> = _Tp;
pub type std___shared_ptr_element_type = std_remove_extent;
pub type std___shared_ptr__SafeConv = u8;
pub type std___shared_ptr__Compatible = u8;
pub type std___shared_ptr__Assignable = std___shared_ptr__Compatible;
pub type std___shared_ptr__UniqCompatible = u8;
pub type std___shared_ptr__UniqAssignable = std___shared_ptr__UniqCompatible;
pub type std___shared_ptr_weak_type = u8;
pub type std___shared_ptr___esft_base_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr___has_esft_base {
    pub _base: std_false_type,
}
pub type std___weak_ptr__Compatible = u8;
pub type std___weak_ptr__Assignable = std___weak_ptr__Compatible;
pub type std___weak_ptr_element_type = std_remove_extent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_owner_less {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std__Sp_owner_less_open0_void_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_owner_less>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std__Sp_owner_less)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_owner_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std__Sp_owner_less)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = std_weak_ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr {
    pub _address: u8,
}
pub type std_weak_ptr__Constructible = u8;
pub type std_weak_ptr__Assignable = u8;
#[test]
fn __bindgen_test_layout_std_owner_less_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_owner_less>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_owner_less)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_owner_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_owner_less)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this {
    pub _M_weak_this: std_weak_ptr,
}
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
pub const std___memory_order_modifier___memory_order_mask: std___memory_order_modifier = 65535;
pub const std___memory_order_modifier___memory_order_modifier_mask: std___memory_order_modifier =
    4294901760;
pub const std___memory_order_modifier___memory_order_hle_acquire: std___memory_order_modifier =
    65536;
pub const std___memory_order_modifier___memory_order_hle_release: std___memory_order_modifier =
    131072;
pub type std___memory_order_modifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std___atomic_flag_data_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___atomic_flag_base {
    pub _M_i: std___atomic_flag_data_type,
}
#[test]
fn bindgen_test_layout_std___atomic_flag_base() {
    const UNINIT: ::std::mem::MaybeUninit<std___atomic_flag_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___atomic_flag_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___atomic_flag_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___atomic_flag_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___atomic_flag_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___atomic_flag_base),
            "::",
            stringify!(_M_i)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic_flag {
    pub _base: std___atomic_flag_base,
}
#[test]
fn bindgen_test_layout_std_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_atomic_flag))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___atomic_base<_ITp> {
    pub _M_i: std___atomic_base___int_type<_ITp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_ITp>>,
}
pub type std___atomic_base_value_type<_ITp> = _ITp;
pub type std___atomic_base_difference_type<_ITp> = std___atomic_base_value_type<_ITp>;
pub type std___atomic_base___int_type<_ITp> = _ITp;
#[repr(C)]
#[derive(Debug)]
pub struct std__Sp_locker {
    pub _M_key1: ::std::os::raw::c_uchar,
    pub _M_key2: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_std__Sp_locker() {
    const UNINIT: ::std::mem::MaybeUninit<std__Sp_locker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Sp_locker>(),
        2usize,
        concat!("Size of: ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_locker>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_key1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Sp_locker),
            "::",
            stringify!(_M_key1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_key2) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Sp_locker),
            "::",
            stringify!(_M_key2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKv"]
    pub fn std__Sp_locker__Sp_locker(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKvS1_"]
    pub fn std__Sp_locker__Sp_locker1(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerD1Ev"]
    pub fn std__Sp_locker__Sp_locker_destructor(this: *mut std__Sp_locker);
}
impl std__Sp_locker {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Sp_locker__Sp_locker_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp1> {
    pub _M_ptr: *mut _Tp1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp1>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub _M_ptr: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_auto_ptr_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
}
pub const std_pointer_safety_relaxed: std_pointer_safety = 0;
pub const std_pointer_safety_preferred: std_pointer_safety = 1;
pub const std_pointer_safety_strict: std_pointer_safety = 2;
pub type std_pointer_safety = ::std::os::raw::c_int;
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        576usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype>(),
        1344usize,
        concat!("Size of template specialization: ", stringify!(std_ctype))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        576usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_ctype_byname_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_ctype_byname>(),
        1344usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_ctype_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_ctype_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx27__verbose_terminate_handlerEv"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type = __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___is_integer_nonstrict {
    pub _address: u8,
}
pub const __gnu_cxx___is_integer_nonstrict___width: __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 =
    0;
pub type __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_integer {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__min"]
    pub static __gnu_cxx___min: _Value;
}
extern "C" {
    #[link_name = "\u{1}__max"]
    pub static __gnu_cxx___max: _Value;
}
extern "C" {
    #[link_name = "\u{1}__is_signed"]
    pub static __gnu_cxx___is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}__digits"]
    pub static __gnu_cxx___digits: ::std::os::raw::c_int;
}
pub type __gnu_cxx___int_traits = __gnu_cxx___numeric_traits_integer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_floating {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__max_digits10"]
    pub static __gnu_cxx___max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__digits10"]
    pub static __gnu_cxx___digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__max_exponent10"]
    pub static __gnu_cxx___max_exponent10: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Val_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_iter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_val<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_val<_Value> {
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_iter<_Iterator1> {
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_pred<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_val<_Compare, _Value> {
    pub _M_comp: _Compare,
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_iter<_Compare, _Iterator1> {
    pub _M_comp: _Compare,
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
extern "C" {
    #[link_name = "\u{1}__uselocale"]
    pub fn __gnu_cxx___uselocale(arg1: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx_new_allocator_difference_type = ::std::os::raw::c_long;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf {
    pub _M_storage: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf__Tp2<_Tp> {
    pub _M_t: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_buffer {
    pub _M_storage: u8,
}
pub const __gnu_cxx__Lock_policy__S_single: __gnu_cxx__Lock_policy = 0;
pub const __gnu_cxx__Lock_policy__S_mutex: __gnu_cxx__Lock_policy = 1;
pub const __gnu_cxx__Lock_policy__S_atomic: __gnu_cxx__Lock_policy = 2;
pub type __gnu_cxx__Lock_policy = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxxL21__default_lock_policyE"]
    pub static __gnu_cxx___default_lock_policy: __gnu_cxx__Lock_policy;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_lock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_lock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_lock_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_lock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_unlock_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_unlock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_broadcast_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_broadcast_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_wait_error {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_wait_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_wait_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_wait_error)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___mutex {
    pub _M_mutex: __gthread_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___mutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___mutex>(),
        40usize,
        concat!("Size of: ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___recursive_mutex {
    pub _M_mutex: __gthread_recursive_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___recursive_mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___recursive_mutex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___recursive_mutex>(),
        40usize,
        concat!("Size of: ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___recursive_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___recursive_mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___scoped_lock {
    pub _M_device: *mut __gnu_cxx___scoped_lock___mutex_type,
}
pub type __gnu_cxx___scoped_lock___mutex_type = __gnu_cxx___mutex;
#[test]
fn bindgen_test_layout___gnu_cxx___scoped_lock() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___scoped_lock> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___scoped_lock),
            "::",
            stringify!(_M_device)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___cond {
    pub _M_cond: __gthread_cond_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___cond() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___cond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___cond>(),
        48usize,
        concat!("Size of: ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___cond>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cond) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___cond),
            "::",
            stringify!(_M_cond)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___cxa_refcounted_exception {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}__cxa_allocate_exception"]
    pub fn __cxxabiv1___cxa_allocate_exception(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}__cxa_free_exception"]
    pub fn __cxxabiv1___cxa_free_exception(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__cxa_init_primary_exception"]
    pub fn __cxxabiv1___cxa_init_primary_exception(
        object: *mut ::std::os::raw::c_void,
        tinfo: *mut std_type_info,
        dest: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut __cxxabiv1___cxa_refcounted_exception;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct __cxxabiv1___forced_unwind__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct __cxxabiv1___forced_unwind {
    pub vtable_: *const __cxxabiv1___forced_unwind__bindgen_vtable,
}
#[test]
fn bindgen_test_layout___cxxabiv1___forced_unwind() {
    assert_eq!(
        ::std::mem::size_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Size of: ", stringify!(__cxxabiv1___forced_unwind))
    );
    assert_eq!(
        ::std::mem::align_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Alignment of ", stringify!(__cxxabiv1___forced_unwind))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_IndexBased {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_IndexBased() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_IndexBased>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_IndexBased))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_IndexBased>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_IndexBased))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_IteratorBased {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_IteratorBased() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_IteratorBased>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_IteratorBased))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_IteratorBased>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_IteratorBased))
    );
}
pub const Eigen_internal_ComparisonName_cmp_EQ: Eigen_internal_ComparisonName = 0;
pub const Eigen_internal_ComparisonName_cmp_LT: Eigen_internal_ComparisonName = 1;
pub const Eigen_internal_ComparisonName_cmp_LE: Eigen_internal_ComparisonName = 2;
pub const Eigen_internal_ComparisonName_cmp_UNORD: Eigen_internal_ComparisonName = 3;
pub const Eigen_internal_ComparisonName_cmp_NEQ: Eigen_internal_ComparisonName = 4;
pub const Eigen_internal_ComparisonName_cmp_GT: Eigen_internal_ComparisonName = 5;
pub const Eigen_internal_ComparisonName_cmp_GE: Eigen_internal_ComparisonName = 6;
#[doc = " \\internal\n Constants for comparison functors"]
pub type Eigen_internal_ComparisonName = ::std::os::raw::c_uint;
pub type Eigen_internal_IntPtr = isize;
pub type Eigen_internal_UIntPtr = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_true_type {
    pub _address: u8,
}
pub const Eigen_internal_true_type_value: Eigen_internal_true_type__bindgen_ty_1 = 1;
pub type Eigen_internal_true_type__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Eigen_internal_true_type() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_true_type>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_true_type))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_true_type>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_true_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_false_type {
    pub _address: u8,
}
pub const Eigen_internal_false_type_value: Eigen_internal_false_type__bindgen_ty_1 = 0;
pub type Eigen_internal_false_type__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Eigen_internal_false_type() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_false_type>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_false_type))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_false_type>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_false_type))
    );
}
pub type Eigen_internal_conditional_type<Then> = Then;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_same {
    pub _address: u8,
}
pub const Eigen_internal_is_same_value: Eigen_internal_is_same__bindgen_ty_1 = 0;
pub type Eigen_internal_is_same__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_remove_reference {
    pub _address: u8,
}
pub type Eigen_internal_remove_reference_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_remove_pointer {
    pub _address: u8,
}
pub type Eigen_internal_remove_pointer_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_remove_const {
    pub _address: u8,
}
pub type Eigen_internal_remove_const_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_remove_all {
    pub _address: u8,
}
pub type Eigen_internal_remove_all_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_arithmetic {
    pub _address: u8,
}
pub const Eigen_internal_is_arithmetic_value: Eigen_internal_is_arithmetic__bindgen_ty_1 = 0;
pub type Eigen_internal_is_arithmetic__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_integral {
    pub _address: u8,
}
pub const Eigen_internal_is_integral_value: Eigen_internal_is_integral__bindgen_ty_1 = 0;
pub type Eigen_internal_is_integral__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_integral_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_integral)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_add_const {
    pub _address: u8,
}
pub type Eigen_internal_add_const_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_const {
    pub _address: u8,
}
pub const Eigen_internal_is_const_value: Eigen_internal_is_const__bindgen_ty_1 = 0;
pub type Eigen_internal_is_const__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_add_const_on_value_type {
    pub _address: u8,
}
pub type Eigen_internal_add_const_on_value_type_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_convertible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_convertible_impl_any_conversion {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_convertible_impl_yes {
    pub a: [::std::os::raw::c_int; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_convertible_impl_no {
    pub a: [::std::os::raw::c_int; 2usize],
}
pub const Eigen_internal_is_convertible_impl_value:
    Eigen_internal_is_convertible_impl__bindgen_ty_1 = 0;
pub type Eigen_internal_is_convertible_impl__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_convertible {
    pub _address: u8,
}
pub const Eigen_internal_is_convertible_value: Eigen_internal_is_convertible__bindgen_ty_1 = 0;
pub type Eigen_internal_is_convertible__bindgen_ty_1 = i32;
#[doc = " \\internal\n A base class do disable default copy ctor and copy assignement operator."]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_noncopyable {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_noncopyable() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_noncopyable>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_noncopyable))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_noncopyable>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_noncopyable))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_result_of {
    pub _address: u8,
}
pub type Eigen_internal_result_of_type1 = std_result_of;
pub type Eigen_internal_result_of_type = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_meta_yes {
    pub a: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_Eigen_internal_meta_yes() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_internal_meta_yes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_meta_yes>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_meta_yes))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_meta_yes>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_meta_yes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_meta_yes),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_meta_no {
    pub a: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_Eigen_internal_meta_no() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_internal_meta_no> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_meta_no>(),
        2usize,
        concat!("Size of: ", stringify!(Eigen_internal_meta_no))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_meta_no>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_meta_no))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_meta_no),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_has_ReturnType {
    pub _address: u8,
}
pub const Eigen_internal_has_ReturnType_value: Eigen_internal_has_ReturnType__bindgen_ty_1 = 0;
pub type Eigen_internal_has_ReturnType__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_has_nullary_operator {
    pub _address: u8,
}
pub const Eigen_internal_has_nullary_operator_value:
    Eigen_internal_has_nullary_operator__bindgen_ty_1 = 0;
pub type Eigen_internal_has_nullary_operator__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_has_unary_operator {
    pub _address: u8,
}
pub const Eigen_internal_has_unary_operator_value: Eigen_internal_has_unary_operator__bindgen_ty_1 =
    0;
pub type Eigen_internal_has_unary_operator__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_has_binary_operator {
    pub _address: u8,
}
pub const Eigen_internal_has_binary_operator_value:
    Eigen_internal_has_binary_operator__bindgen_ty_1 = 0;
pub type Eigen_internal_has_binary_operator__bindgen_ty_1 = i32;
pub const Eigen_internal_meta_sqrt_MidX: Eigen_internal_meta_sqrt__bindgen_ty_1 = 0;
pub const Eigen_internal_meta_sqrt_TakeInf: Eigen_internal_meta_sqrt__bindgen_ty_1 = 0;
pub const Eigen_internal_meta_sqrt_NewInf: Eigen_internal_meta_sqrt__bindgen_ty_1 = 0;
pub const Eigen_internal_meta_sqrt_NewSup: Eigen_internal_meta_sqrt__bindgen_ty_1 = 0;
pub type Eigen_internal_meta_sqrt__bindgen_ty_1 = i32;
pub const Eigen_internal_meta_sqrt_ret: Eigen_internal_meta_sqrt__bindgen_ty_2 = 0;
pub type Eigen_internal_meta_sqrt__bindgen_ty_2 = i32;
pub const Eigen_internal_meta_least_common_multiple_ret:
    Eigen_internal_meta_least_common_multiple__bindgen_ty_1 = 0;
pub type Eigen_internal_meta_least_common_multiple__bindgen_ty_1 = i32;
#[doc = " \\internal determines whether the product of two numeric types is allowed and what the return type is"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_product_traits {
    pub _address: u8,
}
pub const Eigen_internal_scalar_product_traits_Defined:
    Eigen_internal_scalar_product_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_scalar_product_traits__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_has_direct_access {
    pub _address: u8,
}
pub const Eigen_internal_has_direct_access_ret: Eigen_internal_has_direct_access__bindgen_ty_1 = 0;
pub type Eigen_internal_has_direct_access__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_accessors_level {
    pub _address: u8,
}
pub const Eigen_internal_accessors_level_has_direct_access:
    Eigen_internal_accessors_level__bindgen_ty_1 = 0;
pub const Eigen_internal_accessors_level_has_write_access:
    Eigen_internal_accessors_level__bindgen_ty_1 = 0;
pub const Eigen_internal_accessors_level_value: Eigen_internal_accessors_level__bindgen_ty_1 = 0;
pub type Eigen_internal_accessors_level__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_kernel_retval {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_image_retval {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_hypot_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_lgamma_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_digamma_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_erf_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_erfc_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_igamma_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_igammac_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_zeta_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_betainc_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_inverse_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_stem_function {
    pub _address: u8,
}
pub type Eigen_internal_stem_function_ComplexScalar = std_complex<_Tp>;
pub type Eigen_internal_stem_function_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: Eigen_internal_stem_function_ComplexScalar,
        arg2: ::std::os::raw::c_int,
    ) -> Eigen_internal_stem_function_ComplexScalar,
>;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_no_assignment_operator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_no_assignment_operator() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_no_assignment_operator>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_no_assignment_operator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_no_assignment_operator>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_no_assignment_operator)
        )
    );
}
#[doc = " \\internal return the index type with the largest number of bits"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_promote_index_type {
    pub _address: u8,
}
pub type Eigen_internal_promote_index_type_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_functor_traits {
    pub _address: u8,
}
pub const Eigen_internal_functor_traits_Cost: Eigen_internal_functor_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_functor_traits_PacketAccess: Eigen_internal_functor_traits__bindgen_ty_1 =
    0;
pub const Eigen_internal_functor_traits_IsRepeatable: Eigen_internal_functor_traits__bindgen_ty_1 =
    0;
pub type Eigen_internal_functor_traits__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_unpacket_traits {
    pub _address: u8,
}
pub type Eigen_internal_unpacket_traits_type<T> = T;
pub type Eigen_internal_unpacket_traits_half<T> = T;
pub const Eigen_internal_unpacket_traits_size: Eigen_internal_unpacket_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_unpacket_traits_alignment: Eigen_internal_unpacket_traits__bindgen_ty_1 =
    0;
pub type Eigen_internal_unpacket_traits__bindgen_ty_1 = i32;
pub type Eigen_internal_find_best_packet_type = u8;
pub const Eigen_internal_compute_default_alignment_helper_value:
    Eigen_internal_compute_default_alignment_helper__bindgen_ty_1 = 0;
pub type Eigen_internal_compute_default_alignment_helper__bindgen_ty_1 = i32;
pub const Eigen_internal_compute_default_alignment_value:
    Eigen_internal_compute_default_alignment__bindgen_ty_1 = 0;
pub type Eigen_internal_compute_default_alignment__bindgen_ty_1 = i32;
pub const Eigen_internal_make_proper_matrix_type_IsColVector:
    Eigen_internal_make_proper_matrix_type__bindgen_ty_1 = 0;
pub const Eigen_internal_make_proper_matrix_type_IsRowVector:
    Eigen_internal_make_proper_matrix_type__bindgen_ty_1 = 0;
pub const Eigen_internal_make_proper_matrix_type_Options:
    Eigen_internal_make_proper_matrix_type__bindgen_ty_1 = 0;
pub type Eigen_internal_make_proper_matrix_type__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_make_proper_matrix_type_type = u8;
pub const Eigen_internal_compute_matrix_flags_row_major_bit:
    Eigen_internal_compute_matrix_flags__bindgen_ty_1 = 0;
pub type Eigen_internal_compute_matrix_flags__bindgen_ty_1 = i32;
pub const Eigen_internal_compute_matrix_flags_ret:
    Eigen_internal_compute_matrix_flags__bindgen_ty_2 = 0;
pub type Eigen_internal_compute_matrix_flags__bindgen_ty_2 = i32;
pub const Eigen_internal_size_at_compile_time_ret:
    Eigen_internal_size_at_compile_time__bindgen_ty_1 = 0;
pub type Eigen_internal_size_at_compile_time__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_size_of_xpr_at_compile_time {
    pub _address: u8,
}
pub const Eigen_internal_size_of_xpr_at_compile_time_ret:
    Eigen_internal_size_of_xpr_at_compile_time__bindgen_ty_1 = 0;
pub type Eigen_internal_size_of_xpr_at_compile_time__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_matrix_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_eval {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_object_eval {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_matrix_type_column_major {
    pub _address: u8,
}
pub const Eigen_internal_plain_matrix_type_column_major_Rows:
    Eigen_internal_plain_matrix_type_column_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_column_major_Cols:
    Eigen_internal_plain_matrix_type_column_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_column_major_MaxRows:
    Eigen_internal_plain_matrix_type_column_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_column_major_MaxCols:
    Eigen_internal_plain_matrix_type_column_major__bindgen_ty_1 = 0;
pub type Eigen_internal_plain_matrix_type_column_major__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_matrix_type_column_major_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_matrix_type_row_major {
    pub _address: u8,
}
pub const Eigen_internal_plain_matrix_type_row_major_Rows:
    Eigen_internal_plain_matrix_type_row_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_row_major_Cols:
    Eigen_internal_plain_matrix_type_row_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_row_major_MaxRows:
    Eigen_internal_plain_matrix_type_row_major__bindgen_ty_1 = 0;
pub const Eigen_internal_plain_matrix_type_row_major_MaxCols:
    Eigen_internal_plain_matrix_type_row_major__bindgen_ty_1 = 0;
pub type Eigen_internal_plain_matrix_type_row_major__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_matrix_type_row_major_type = u8;
#[doc = " \\internal The reference selector for template expressions. The idea is that we don't\n need to use references for expressions since they are light weight proxy\n objects which should generate no copying overhead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_ref_selector {
    pub _address: u8,
}
pub type Eigen_internal_ref_selector_type = u8;
pub type Eigen_internal_ref_selector_non_const_type = u8;
#[doc = " \\internal Adds the const qualifier on the value-type of T2 if and only if T1 is a const type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_transfer_constness {
    pub _address: u8,
}
pub type Eigen_internal_transfer_constness_type = u8;
pub const Eigen_internal_nested_eval_ScalarReadCost: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub const Eigen_internal_nested_eval_CoeffReadCost: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub const Eigen_internal_nested_eval_NAsInteger: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub const Eigen_internal_nested_eval_CostEval: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub const Eigen_internal_nested_eval_CostNoEval: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub const Eigen_internal_nested_eval_Evaluate: Eigen_internal_nested_eval__bindgen_ty_1 = 0;
pub type Eigen_internal_nested_eval__bindgen_ty_1 = i32;
pub type Eigen_internal_nested_eval_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_dense_xpr_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_generic_xpr_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_cast_return_type {
    pub _address: u8,
}
pub type Eigen_internal_cast_return_type_CurrentScalarType = [u8; 0usize];
pub type Eigen_internal_cast_return_type__CastType = Eigen_internal_remove_all;
pub type Eigen_internal_cast_return_type_NewScalarType = Eigen_internal_cast_return_type__CastType;
pub type Eigen_internal_cast_return_type_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_promote_storage_type {
    pub _address: u8,
}
#[doc = " \\internal Specify the \"storage kind\" of applying a coefficient-wise\n binary operations between two expressions of kinds A and B respectively.\n The template parameter Functor permits to specialize the resulting storage kind wrt to\n the functor.\n The default rules are as follows:\n \\code\n A      op A      -> A\n A      op dense  -> dense\n dense  op B      -> dense\n sparse op dense  -> sparse\n dense  op sparse -> sparse\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_cwise_promote_storage_type {
    pub _address: u8,
}
pub const Eigen_internal_cwise_promote_storage_order_value:
    Eigen_internal_cwise_promote_storage_order__bindgen_ty_1 = 0;
pub type Eigen_internal_cwise_promote_storage_order__bindgen_ty_1 = i32;
#[doc = " \\internal gives the plain matrix or array type to store a row/column/diagonal of a matrix type.\n \\tparam Scalar optional parameter allowing to pass a different scalar type than the one of the MatrixType."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_row_type {
    pub _address: u8,
}
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_row_type_MatrixRowType = u8;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_internal_plain_row_type_ArrayRowType = u8;
pub type Eigen_internal_plain_row_type_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_col_type {
    pub _address: u8,
}
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_col_type_MatrixColType = u8;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_internal_plain_col_type_ArrayColType = u8;
pub type Eigen_internal_plain_col_type_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_diag_type {
    pub _address: u8,
}
pub const Eigen_internal_plain_diag_type_diag_size: Eigen_internal_plain_diag_type__bindgen_ty_1 =
    0;
pub const Eigen_internal_plain_diag_type_max_diag_size:
    Eigen_internal_plain_diag_type__bindgen_ty_1 = 0;
pub type Eigen_internal_plain_diag_type__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_diag_type_MatrixDiagType = u8;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_internal_plain_diag_type_ArrayDiagType = u8;
pub type Eigen_internal_plain_diag_type_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_plain_constant_type {
    pub _address: u8,
}
pub const Eigen_internal_plain_constant_type_Options:
    Eigen_internal_plain_constant_type__bindgen_ty_1 = 0;
pub type Eigen_internal_plain_constant_type__bindgen_ty_1 = i32;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_internal_plain_constant_type_array_type = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_plain_constant_type_matrix_type = u8;
#[doc = " \\class CwiseNullaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression of a matrix where all coefficients are defined by a functor\n\n \\tparam NullaryOp template functor implementing the operator\n \\tparam PlainObjectType the underlying plain matrix/array type\n\n This class represents an expression of a generic nullary operator.\n It is the return type of the Ones(), Zero(), Constant(), Identity() and Random() methods,\n and most of the time this is the only way it is used.\n\n However, if you want to write a function returning such an expression, you\n will need to use this class.\n\n The functor NullaryOp must expose one of the following method:\n<table class=\"manual\">\n<tr            ><td>\\c operator()() </td><td>if the procedural generation does not depend on the coefficient entries (e.g., random numbers)</td></tr>\n<tr class=\"alt\"><td>\\c operator()(Index i)</td><td>if the procedural generation makes sense for vectors only and that it depends on the coefficient index \\c i (e.g., linspace) </td></tr>\n<tr            ><td>\\c operator()(Index i,Index j)</td><td>if the procedural generation depends on the matrix coordinates \\c i, \\c j (e.g., to generate a checkerboard with 0 and 1)</td></tr>\n</table>\n It is also possible to expose the last two operators if the generation makes sense for matrices but can be optimized for vectors.\n\n See DenseBase::NullaryExpr(Index,const CustomNullaryOp&) for an example binding\n C++11 random number generators.\n\n A nullary expression can also be used to implement custom sophisticated matrix manipulations\n that cannot be covered by the existing set of natively supported matrix manipulations.\n See this \\ref TopicCustomizing_NullaryExpr \"page\" for some examples and additional explanations\n on the behavior of CwiseNullaryOp.\n\n \\sa class CwiseUnaryOp, class CwiseBinaryOp, DenseBase::NullaryExpr"]
pub type Eigen_internal_plain_constant_type_type = Eigen_CwiseNullaryOp<NullaryOp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_lvalue {
    pub _address: u8,
}
pub const Eigen_internal_is_lvalue_value: Eigen_internal_is_lvalue__bindgen_ty_1 = 0;
pub type Eigen_internal_is_lvalue__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_is_diagonal {
    pub _address: u8,
}
pub const Eigen_internal_is_diagonal_ret: Eigen_internal_is_diagonal__bindgen_ty_1 = 0;
pub type Eigen_internal_is_diagonal__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_glue_shapes {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Eigen_internal_glue_shapes_open0_Eigen_DenseShape_Eigen_TriangularShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_glue_shapes>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_glue_shapes)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_glue_shapes>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_glue_shapes)
        )
    );
}
pub const Eigen_internal_scalar_div_cost_value: Eigen_internal_scalar_div_cost__bindgen_ty_1 = 0;
pub type Eigen_internal_scalar_div_cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_aligned_stack_memory_handler<T> {
    pub m_ptr: *mut T,
    pub m_size: usize,
    pub m_deallocate: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_scoped_array<T> {
    pub m_ptr: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " \\internal \\class global_math_functions_filtering_base\n\n What it does:\n Defines a typedef 'type' as follows:\n - if type T has a member typedef Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl, then\n   global_math_functions_filtering_base<T>::type is a typedef for it.\n - otherwise, global_math_functions_filtering_base<T>::type is a typedef for T.\n\n How it's used:\n To allow to defined the global math functions (like sin...) in certain cases, like the Array expressions.\n When you do sin(array1+array2), the object array1+array2 has a complicated expression type, all what you want to know\n is that it inherits ArrayBase. So we implement a partial specialization of sin_impl for ArrayBase<Derived>.\n So we must make sure to use sin_impl<ArrayBase<Derived> > and not sin_impl<Derived>, otherwise our partial specialization\n won't be used. How does sin know that? That's exactly what global_math_functions_filtering_base tells it.\n\n How it's implemented:\n SFINAE in the style of enable_if. Highly susceptible of breaking compilers. With GCC, it sure does work, but if you replace\n the typename dummy by an integer template parameter, it doesn't work anymore!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_global_math_functions_filtering_base {
    pub _address: u8,
}
pub type Eigen_internal_global_math_functions_filtering_base_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_always_void {
    pub _address: u8,
}
pub type Eigen_internal_always_void_type = ::std::os::raw::c_void;
pub type Eigen_internal_real_default_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_real_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_real_retval {
    pub _address: u8,
}
pub type Eigen_internal_real_retval_type = Eigen_NumTraits;
pub type Eigen_internal_imag_default_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_imag_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_imag_retval {
    pub _address: u8,
}
pub type Eigen_internal_imag_retval_type = Eigen_NumTraits;
#[doc = " Implementation of real_ref                                             *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_real_ref_impl {
    pub _address: u8,
}
pub type Eigen_internal_real_ref_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_real_ref_retval {
    pub _address: u8,
}
pub type Eigen_internal_real_ref_retval_type = *mut Eigen_NumTraits;
pub type Eigen_internal_imag_ref_default_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_imag_ref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_imag_ref_retval {
    pub _address: u8,
}
pub type Eigen_internal_imag_ref_retval_type = *mut Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_conj_retval {
    pub _address: u8,
}
pub type Eigen_internal_conj_retval_type<Scalar> = Scalar;
pub type Eigen_internal_abs2_impl_default_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_abs2_impl {
    pub _address: u8,
}
pub type Eigen_internal_abs2_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_abs2_retval {
    pub _address: u8,
}
pub type Eigen_internal_abs2_retval_type = Eigen_NumTraits;
pub type Eigen_internal_norm1_default_impl_RealScalar = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_norm1_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_norm1_retval {
    pub _address: u8,
}
pub type Eigen_internal_norm1_retval_type = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_hypot_retval {
    pub _address: u8,
}
pub type Eigen_internal_hypot_retval_type = Eigen_NumTraits;
#[doc = " Implementation of cast                                                 *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_cast_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_round_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_round_retval {
    pub _address: u8,
}
pub type Eigen_internal_round_retval_type<Scalar> = Scalar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_arg_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_arg_retval {
    pub _address: u8,
}
pub type Eigen_internal_arg_retval_type = Eigen_NumTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_log1p_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_log1p_retval {
    pub _address: u8,
}
pub type Eigen_internal_log1p_retval_type<Scalar> = Scalar;
pub type Eigen_internal_pow_impl_result_type = Eigen_ScalarBinaryOpTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_random_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_random_retval {
    pub _address: u8,
}
pub type Eigen_internal_random_retval_type<Scalar> = Scalar;
pub const meta_floor_log2_terminate: Eigen_internal__bindgen_ty_1 = 0;
pub const meta_floor_log2_move_up: Eigen_internal__bindgen_ty_1 = 1;
pub const meta_floor_log2_move_down: Eigen_internal__bindgen_ty_1 = 2;
pub const meta_floor_log2_bogus: Eigen_internal__bindgen_ty_1 = 3;
pub type Eigen_internal__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const Eigen_internal_meta_floor_log2_selector_middle:
    Eigen_internal_meta_floor_log2_selector__bindgen_ty_1 = 0;
pub const Eigen_internal_meta_floor_log2_selector_value:
    Eigen_internal_meta_floor_log2_selector__bindgen_ty_1 = 0;
pub type Eigen_internal_meta_floor_log2_selector__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_fuzzy_impl {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Eigen_internal_random_impl_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_random_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_random_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_random_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_random_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_fuzzy_impl_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_fuzzy_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_fuzzy_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_fuzzy_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_fuzzy_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_default_packet_traits {
    pub _address: u8,
}
pub const Eigen_internal_default_packet_traits_HasHalfPacket:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasAdd:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasSub:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasMul:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasNegate:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasAbs:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasArg:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasAbs2:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasMin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasMax:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasConj:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasSetLinear:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasBlend:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasDiv:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSqrt:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasRsqrt:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasExp:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog1p:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog10:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasPow:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCos:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasTan:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasASin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasACos:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasATan:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSinh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCosh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasTanh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasDiGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasZeta:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasPolygamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasErf:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasErfc:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasIGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasIGammac:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasBetaInc:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasRound:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasFloor:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCeil:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSign:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_default_packet_traits__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Eigen_internal_default_packet_traits() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_default_packet_traits>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_default_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_default_packet_traits>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_default_packet_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_packet_traits {
    pub _address: u8,
}
pub type Eigen_internal_packet_traits_type<T> = T;
pub type Eigen_internal_packet_traits_half<T> = T;
pub const Eigen_internal_packet_traits_Vectorizable: Eigen_internal_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_packet_traits_size: Eigen_internal_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_packet_traits_AlignedOnScalar: Eigen_internal_packet_traits__bindgen_ty_1 =
    0;
pub const Eigen_internal_packet_traits_HasHalfPacket: Eigen_internal_packet_traits__bindgen_ty_1 =
    0;
pub type Eigen_internal_packet_traits__bindgen_ty_1 = i32;
pub const Eigen_internal_packet_traits_HasAdd: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasSub: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMul: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasNegate: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasAbs: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasAbs2: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMin: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMax: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasConj: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasSetLinear: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub type Eigen_internal_packet_traits__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_type_casting_traits {
    pub _address: u8,
}
pub const Eigen_internal_type_casting_traits_VectorizedCast:
    Eigen_internal_type_casting_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_type_casting_traits_SrcCoeffRatio:
    Eigen_internal_type_casting_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_type_casting_traits_TgtCoeffRatio:
    Eigen_internal_type_casting_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_type_casting_traits__bindgen_ty_1 = i32;
#[doc = " Implementation of hypot                                                *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_hypot_impl {
    pub _address: u8,
}
pub type Eigen_internal_hypot_impl_RealScalar = Eigen_NumTraits;
pub type Eigen_internal_Packet4f = __m128;
pub type Eigen_internal_Packet4i = __m128i;
pub type Eigen_internal_Packet2d = __m128d;
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0__bindgen_ty_id_97248_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0__bindgen_ty_id_97251_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0__bindgen_ty_id_97254_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_packet_traits_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_packet_traits_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_packet_traits_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_unpacket_traits_open0__bindgen_ty_id_97257_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_unpacket_traits_open0__bindgen_ty_id_97260_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_unpacket_traits_open0__bindgen_ty_id_97263_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
}
pub type Eigen_internal_SsePrefetchPtrType = *const ::std::os::raw::c_char;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Packet2cf {
    pub v: __m128,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Packet2cf() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_internal_Packet2cf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Packet2cf>(),
        16usize,
        concat!("Size of: ", stringify!(Eigen_internal_Packet2cf))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Packet2cf>(),
        16usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Packet2cf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_Packet2cf),
            "::",
            stringify!(v)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_packet_traits_open0_std_complex_open1_float_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_unpacket_traits_open0_Eigen_internal_Packet2cf_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Packet1cd {
    pub v: __m128d,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Packet1cd() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_internal_Packet1cd> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Packet1cd>(),
        16usize,
        concat!("Size of: ", stringify!(Eigen_internal_Packet1cd))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Packet1cd>(),
        16usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Packet1cd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_Packet1cd),
            "::",
            stringify!(v)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_packet_traits_open0_std_complex_open1_double_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_packet_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_packet_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_unpacket_traits_open0_Eigen_internal_Packet1cd_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_unpacket_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_unpacket_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_type_casting_traits_open0_float_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_type_casting_traits_open0_int_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_type_casting_traits_open0_double_float_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_type_casting_traits_open0_float_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_type_casting_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_type_casting_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_is_arithmetic_open0_Eigen_half_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_is_arithmetic>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_is_arithmetic)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_float_Eigen_half_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_cast_op_open1_float_Eigen_half_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_int_Eigen_half_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_cast_op_open1_int_Eigen_half_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_Eigen_half_float_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_cast_op_open1_Eigen_half_float_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_binary_op_base {
    pub _address: u8,
}
pub type Eigen_internal_binary_op_base_first_argument_type<Arg1> = Arg1;
pub type Eigen_internal_binary_op_base_second_argument_type<Arg2> = Arg2;
#[doc = " \\internal\n \\brief Template functor to compute the sum of two scalars\n\n \\sa class CwiseBinaryOp, MatrixBase::operator+, class VectorwiseOp, DenseBase::sum()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_sum_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_sum_op_result_type = Eigen_ScalarBinaryOpTraits;
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_sum_op_open0_bool__bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_sum_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_sum_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_sum_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_sum_op)
        )
    );
}
#[doc = " \\internal\n \\brief Template functor to compute the product of two scalars\n\n \\sa class CwiseBinaryOp, Cwise::operator*(), class VectorwiseOp, MatrixBase::redux()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_product_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_product_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the conjugate product of two scalars\n\n This is a short cut for conj(x) * y which is needed for optimization purpose; in Eigen2 support mode, this becomes x * conj(y)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_conj_product_op {
    pub _address: u8,
}
pub const Eigen_internal_scalar_conj_product_op_Conj:
    Eigen_internal_scalar_conj_product_op__bindgen_ty_1 = 0;
pub type Eigen_internal_scalar_conj_product_op__bindgen_ty_1 = i32;
pub type Eigen_internal_scalar_conj_product_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the min of two scalars\n\n \\sa class CwiseBinaryOp, MatrixBase::cwiseMin, class VectorwiseOp, MatrixBase::minCoeff()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_min_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_min_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the max of two scalars\n\n \\sa class CwiseBinaryOp, MatrixBase::cwiseMax, class VectorwiseOp, MatrixBase::maxCoeff()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_max_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_max_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the pow of two scalars"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_pow_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_pow_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the difference of two scalars\n\n \\sa class CwiseBinaryOp, MatrixBase::operator-"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_difference_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_difference_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the quotient of two scalars\n\n \\sa class CwiseBinaryOp, Cwise::operator/()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_quotient_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_quotient_op_result_type = Eigen_ScalarBinaryOpTraits;
#[doc = " \\internal\n \\brief Template functor to compute the and of two booleans\n\n \\sa class CwiseBinaryOp, ArrayBase::operator&&"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_boolean_and_op {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_scalar_boolean_and_op() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_boolean_and_op>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_scalar_boolean_and_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_boolean_and_op>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_scalar_boolean_and_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_boolean_and_op_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[doc = " \\internal\n \\brief Template functor to compute the or of two booleans\n\n \\sa class CwiseBinaryOp, ArrayBase::operator||"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_boolean_or_op {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_scalar_boolean_or_op() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_boolean_or_op>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_scalar_boolean_or_op))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_boolean_or_op>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_scalar_boolean_or_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_boolean_or_op_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[doc = " \\internal\n \\brief Template functor to compute the xor of two booleans\n\n \\sa class CwiseBinaryOp, ArrayBase::operator^"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_boolean_xor_op {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_scalar_boolean_xor_op() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_boolean_xor_op>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_scalar_boolean_xor_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_boolean_xor_op>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_scalar_boolean_xor_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_functor_traits_open0_Eigen_internal_scalar_boolean_xor_op_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_functor_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_functor_traits)
        )
    );
}
#[repr(C)]
pub struct Eigen_internal_bind1st_op<BinaryOp> {
    pub _base: BinaryOp,
    pub m_value: Eigen_internal_bind1st_op_first_argument_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BinaryOp>>,
}
pub type Eigen_internal_bind1st_op_first_argument_type = [u8; 0usize];
pub type Eigen_internal_bind1st_op_second_argument_type = [u8; 0usize];
pub type Eigen_internal_bind1st_op_result_type = [u8; 0usize];
#[repr(C)]
pub struct Eigen_internal_bind2nd_op<BinaryOp> {
    pub _base: BinaryOp,
    pub m_value: Eigen_internal_bind2nd_op_second_argument_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BinaryOp>>,
}
pub type Eigen_internal_bind2nd_op_first_argument_type = [u8; 0usize];
pub type Eigen_internal_bind2nd_op_second_argument_type = [u8; 0usize];
pub type Eigen_internal_bind2nd_op_result_type = [u8; 0usize];
#[doc = " \\internal\n \\brief Template functor to compute the opposite of a scalar\n\n \\sa class CwiseUnaryOp, MatrixBase::operator-"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_opposite_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the absolute value of a scalar\n\n \\sa class CwiseUnaryOp, Cwise::abs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_abs_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_abs_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to compute the score of a scalar, to chose a pivot\n\n \\sa class CwiseUnaryOp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_score_coeff_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_score_coeff_op_Score_is_abs = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_abs_knowing_score {
    pub _address: u8,
}
pub type Eigen_internal_abs_knowing_score_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to compute the squared absolute value of a scalar\n\n \\sa class CwiseUnaryOp, Cwise::abs2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_abs2_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_abs2_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to compute the conjugate of a complex value\n\n \\sa class CwiseUnaryOp, MatrixBase::conjugate()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_conjugate_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the phase angle of a complex\n\n \\sa class CwiseUnaryOp, Cwise::arg"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_arg_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_arg_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to cast a scalar to another type\n\n \\sa class CwiseUnaryOp, MatrixBase::cast()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_cast_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_cast_op_result_type<NewType> = NewType;
#[doc = " \\internal\n \\brief Template functor to extract the real part of a complex\n\n \\sa class CwiseUnaryOp, MatrixBase::real()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_real_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_real_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to extract the imaginary part of a complex\n\n \\sa class CwiseUnaryOp, MatrixBase::imag()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_imag_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_imag_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to extract the real part of a complex as a reference\n\n \\sa class CwiseUnaryOp, MatrixBase::real()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_real_ref_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_real_ref_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n \\brief Template functor to extract the imaginary part of a complex as a reference\n\n \\sa class CwiseUnaryOp, MatrixBase::imag()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_imag_ref_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_imag_ref_op_result_type = Eigen_NumTraits;
#[doc = " \\internal\n\n \\brief Template functor to compute the exponential of a scalar\n\n \\sa class CwiseUnaryOp, Cwise::exp()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_exp_op {
    pub _address: u8,
}
#[doc = " \\internal\n\n \\brief Template functor to compute the logarithm of a scalar\n\n \\sa class CwiseUnaryOp, ArrayBase::log()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_log_op {
    pub _address: u8,
}
#[doc = " \\internal\n\n \\brief Template functor to compute the logarithm of 1 plus a scalar value\n\n \\sa class CwiseUnaryOp, ArrayBase::log1p()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_log1p_op {
    pub _address: u8,
}
#[doc = " \\internal\n\n \\brief Template functor to compute the base-10 logarithm of a scalar\n\n \\sa class CwiseUnaryOp, Cwise::log10()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_log10_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the square root of a scalar\n \\sa class CwiseUnaryOp, Cwise::sqrt()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_sqrt_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the reciprocal square root of a scalar\n \\sa class CwiseUnaryOp, Cwise::rsqrt()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_rsqrt_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the cosine of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::cos()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_cos_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the sine of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::sin()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_sin_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the tan of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::tan()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_tan_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the arc cosine of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::acos()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_acos_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the arc sine of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::asin()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_asin_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the atan of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::atan()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_atan_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the tanh of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::tanh()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_tanh_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the sinh of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::sinh()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_sinh_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the cosh of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::cosh()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_cosh_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the inverse of a scalar\n \\sa class CwiseUnaryOp, Cwise::inverse()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_inverse_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the square of a scalar\n \\sa class CwiseUnaryOp, Cwise::square()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_square_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the cube of a scalar\n \\sa class CwiseUnaryOp, Cwise::cube()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_cube_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the rounded value of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::round()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_round_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the floor of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::floor()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_floor_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute the ceil of a scalar\n \\sa class CwiseUnaryOp, ArrayBase::ceil()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_ceil_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor to compute whether a scalar is NaN\n \\sa class CwiseUnaryOp, ArrayBase::isnan()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_isnan_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_isnan_op_result_type = bool;
#[doc = " \\internal\n \\brief Template functor to check whether a scalar is +/-inf\n \\sa class CwiseUnaryOp, ArrayBase::isinf()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_isinf_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_isinf_op_result_type = bool;
#[doc = " \\internal\n \\brief Template functor to check whether a scalar has a finite value\n \\sa class CwiseUnaryOp, ArrayBase::isfinite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_isfinite_op {
    pub _address: u8,
}
pub type Eigen_internal_scalar_isfinite_op_result_type = bool;
#[doc = " \\internal\n \\brief Template functor to compute the logical not of a boolean\n\n \\sa class CwiseUnaryOp, ArrayBase::operator!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_boolean_not_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_constant_op<Scalar> {
    pub m_other: Scalar,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Scalar>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_identity_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_linspaced_op {
    pub impl_: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_functor_has_linear_access {
    pub _address: u8,
}
pub const Eigen_internal_functor_has_linear_access_ret:
    Eigen_internal_functor_has_linear_access__bindgen_ty_1 = 0;
pub type Eigen_internal_functor_has_linear_access__bindgen_ty_1 = i32;
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_assign_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment with addition\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_add_assign_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment with subtraction\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_sub_assign_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment with multiplication\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_mul_assign_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment with diviving\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_div_assign_op {
    pub _address: u8,
}
#[doc = " \\internal\n \\brief Template functor for scalar/packet assignment with swapping\n\n It works as follow. For a non-vectorized evaluation loop, we have:\n   for(i) func(A.coeffRef(i), B.coeff(i));\n where B is a SwapWrapper expression. The trick is to make SwapWrapper::coeff behaves like a non-const coeffRef.\n Actually, SwapWrapper might not even be needed since even if B is a plain expression, since it has to be writable\n B.coeff already returns a const reference to the underlying scalar value.\n\n The case of a vectorized loop is more tricky:\n   for(i,j) func.assignPacket<A_Align>(&A.coeffRef(i,j), B.packet<B_Align>(i,j));\n Here, B must be a SwapWrapper whose packet function actually returns a proxy object holding a Scalar*,\n the actual alignment and Packet type.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_swap_assign_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_significant_decimals_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_add_const_on_value_type_if_arithmetic {
    pub _address: u8,
}
pub type Eigen_internal_add_const_on_value_type_if_arithmetic_type = u8;
pub const Eigen_internal_inner_stride_at_compile_time_ret:
    Eigen_internal_inner_stride_at_compile_time__bindgen_ty_1 = 0;
pub type Eigen_internal_inner_stride_at_compile_time__bindgen_ty_1 = i32;
pub const Eigen_internal_outer_stride_at_compile_time_ret:
    Eigen_internal_outer_stride_at_compile_time__bindgen_ty_1 = 0;
pub type Eigen_internal_outer_stride_at_compile_time__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_storage_kind_to_evaluator_kind {
    pub _address: u8,
}
pub type Eigen_internal_storage_kind_to_evaluator_kind_Kind = Eigen_internal_IndexBased;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_storage_kind_to_shape {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Eigen_internal_storage_kind_to_shape_open0_Eigen_Dense_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_storage_kind_to_shape_open0_Eigen_SolverStorage_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_storage_kind_to_shape_open0_Eigen_PermutationStorage_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_storage_kind_to_shape_open0_Eigen_TranspositionsStorage_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_ternary_evaluator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_binary_evaluator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_unary_evaluator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_evaluator_traits_base {
    pub _address: u8,
}
pub type Eigen_internal_evaluator_traits_base_Kind = Eigen_internal_storage_kind_to_evaluator_kind;
pub type Eigen_internal_evaluator_traits_base_Shape = Eigen_internal_storage_kind_to_shape;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_evaluator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_evaluator_assume_aliasing {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_evaluator {
    pub _address: u8,
}
pub type Eigen_internal_evaluator_Base = Eigen_internal_unary_evaluator;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_evaluator_base {
    pub _address: u8,
}
pub type Eigen_internal_evaluator_base_ExpressionTraits = Eigen_internal_traits;
pub const Eigen_internal_evaluator_base_Alignment: Eigen_internal_evaluator_base__bindgen_ty_1 = 0;
pub type Eigen_internal_evaluator_base__bindgen_ty_1 = i32;
#[repr(C)]
pub struct Eigen_internal_mapbase_evaluator {
    pub m_data: Eigen_internal_mapbase_evaluator_PointerType,
    pub m_innerStride: u8,
    pub m_outerStride: u8,
}
pub type Eigen_internal_mapbase_evaluator_XprType<Derived> = Derived;
pub type Eigen_internal_mapbase_evaluator_PointerType = [u8; 0usize];
pub type Eigen_internal_mapbase_evaluator_Scalar = [u8; 0usize];
pub type Eigen_internal_mapbase_evaluator_CoeffReturnType = [u8; 0usize];
pub const Eigen_internal_mapbase_evaluator_IsRowMajor:
    Eigen_internal_mapbase_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_mapbase_evaluator_ColsAtCompileTime:
    Eigen_internal_mapbase_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_mapbase_evaluator_CoeffReadCost:
    Eigen_internal_mapbase_evaluator__bindgen_ty_1 = 0;
pub type Eigen_internal_mapbase_evaluator__bindgen_ty_1 = i32;
#[repr(C)]
pub struct Eigen_internal_evaluator_wrapper_base {
    pub m_argImpl: Eigen_internal_evaluator,
}
pub type Eigen_internal_evaluator_wrapper_base_ArgType = [u8; 0usize];
pub const Eigen_internal_evaluator_wrapper_base_CoeffReadCost:
    Eigen_internal_evaluator_wrapper_base__bindgen_ty_1 = 0;
pub const Eigen_internal_evaluator_wrapper_base_Flags:
    Eigen_internal_evaluator_wrapper_base__bindgen_ty_1 = 0;
pub const Eigen_internal_evaluator_wrapper_base_Alignment:
    Eigen_internal_evaluator_wrapper_base__bindgen_ty_1 = 0;
pub type Eigen_internal_evaluator_wrapper_base__bindgen_ty_1 = i32;
pub type Eigen_internal_evaluator_wrapper_base_Scalar = [u8; 0usize];
pub type Eigen_internal_evaluator_wrapper_base_CoeffReturnType = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_EvalToTemp<ArgType> {
    pub m_arg: *const ArgType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ArgType>>,
}
pub type Eigen_internal_EvalToTemp_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_internal_EvalToTemp_Scalar = Eigen_internal_traits;
pub type Eigen_internal_EvalToTemp_RealScalar = Eigen_NumTraits;
pub type Eigen_internal_EvalToTemp_CoeffReturnType = Eigen_internal_EvalToTemp_Base;
pub type Eigen_internal_EvalToTemp_Nested = Eigen_internal_ref_selector;
pub type Eigen_internal_EvalToTemp_StorageKind = Eigen_internal_traits;
pub type Eigen_internal_EvalToTemp_StorageIndex = Eigen_internal_traits;
pub const Eigen_internal_EvalToTemp_RowsAtCompileTime: Eigen_internal_EvalToTemp__bindgen_ty_1 = 0;
pub const Eigen_internal_EvalToTemp_ColsAtCompileTime: Eigen_internal_EvalToTemp__bindgen_ty_1 = 0;
pub const Eigen_internal_EvalToTemp_Flags: Eigen_internal_EvalToTemp__bindgen_ty_1 = 0;
pub const Eigen_internal_EvalToTemp_SizeAtCompileTime: Eigen_internal_EvalToTemp__bindgen_ty_1 = 0;
pub const Eigen_internal_EvalToTemp_MaxSizeAtCompileTime: Eigen_internal_EvalToTemp__bindgen_ty_1 =
    0;
pub const Eigen_internal_EvalToTemp_IsVectorAtCompileTime: Eigen_internal_EvalToTemp__bindgen_ty_1 =
    0;
pub type Eigen_internal_EvalToTemp__bindgen_ty_1 = i32;
#[doc = " Part 1 : the logic deciding a strategy for traversal and unrolling       *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_copy_using_evaluator_traits {
    pub _address: u8,
}
pub type Eigen_internal_copy_using_evaluator_traits_Dst = [u8; 0usize];
pub type Eigen_internal_copy_using_evaluator_traits_DstScalar = [u8; 0usize];
pub const Eigen_internal_copy_using_evaluator_traits_DstFlags:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_SrcFlags:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_1 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_DstAlignment:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_SrcAlignment:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_DstHasDirectAccess:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_JointAlignment:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_2 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_2 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_InnerSize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_3 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_InnerMaxSize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_3 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_OuterStride:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_3 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MaxSizeAtCompileTime:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_3 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_3 = i32;
pub type Eigen_internal_copy_using_evaluator_traits_LinearPacketType = [u8; 0usize];
pub type Eigen_internal_copy_using_evaluator_traits_InnerPacketType = [u8; 0usize];
pub const Eigen_internal_copy_using_evaluator_traits_LinearPacketSize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_4 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_InnerPacketSize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_4 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_4 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_LinearRequiredAlignment:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_5 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_InnerRequiredAlignment:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_5 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_5 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_DstIsRowMajor:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_SrcIsRowMajor:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_StorageOrdersAgree:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MightVectorize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MayInnerVectorize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MayLinearize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MayLinearVectorize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MaySliceVectorize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_6 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_Traversal:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_7 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_Vectorized:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_7 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_7 = i32;
pub type Eigen_internal_copy_using_evaluator_traits_PacketType = [u8; 0usize];
pub const Eigen_internal_copy_using_evaluator_traits_ActualPacketSize:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_8 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_UnrollingLimit:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_8 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MayUnrollCompletely:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_8 = 0;
pub const Eigen_internal_copy_using_evaluator_traits_MayUnrollInner:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_8 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_8 = i32;
pub const Eigen_internal_copy_using_evaluator_traits_Unrolling:
    Eigen_internal_copy_using_evaluator_traits__bindgen_ty_9 = 0;
pub type Eigen_internal_copy_using_evaluator_traits__bindgen_ty_9 = i32;
pub type Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling_DstEvaluatorType =
    [u8; 0usize];
pub type Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling_DstXprType =
    [u8; 0usize];
pub const Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling_outer:
    Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling__bindgen_ty_1 = 0;
pub const Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling_inner:
    Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling__bindgen_ty_1 = 0;
pub type Eigen_internal_copy_using_evaluator_DefaultTraversal_CompleteUnrolling__bindgen_ty_1 = i32;
pub type Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_DstEvaluatorType =
    [u8; 0usize];
pub type Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_DstXprType = [u8; 0usize];
pub type Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_PacketType = [u8; 0usize];
pub const Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_outer:
    Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling__bindgen_ty_1 = 0;
pub const Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_inner:
    Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling__bindgen_ty_1 = 0;
pub const Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_SrcAlignment:
    Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling__bindgen_ty_1 = 0;
pub const Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling_DstAlignment:
    Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling__bindgen_ty_1 = 0;
pub type Eigen_internal_copy_using_evaluator_innervec_CompleteUnrolling__bindgen_ty_1 = i32;
pub type Eigen_internal_copy_using_evaluator_innervec_InnerUnrolling_PacketType = [u8; 0usize];
pub type Eigen_internal_generic_dense_assignment_kernel_DstXprType = [u8; 0usize];
pub type Eigen_internal_generic_dense_assignment_kernel_SrcXprType = [u8; 0usize];
pub type Eigen_internal_generic_dense_assignment_kernel_DstEvaluatorType<DstEvaluatorTypeT> =
    DstEvaluatorTypeT;
pub type Eigen_internal_generic_dense_assignment_kernel_SrcEvaluatorType<SrcEvaluatorTypeT> =
    SrcEvaluatorTypeT;
pub type Eigen_internal_generic_dense_assignment_kernel_Scalar = [u8; 0usize];
#[doc = " Part 1 : the logic deciding a strategy for traversal and unrolling       *"]
pub type Eigen_internal_generic_dense_assignment_kernel_AssignmentTraits =
    Eigen_internal_copy_using_evaluator_traits;
pub type Eigen_internal_generic_dense_assignment_kernel_PacketType =
    Eigen_internal_generic_dense_assignment_kernel_AssignmentTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Dense2Dense {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Dense2Dense() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Dense2Dense>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_Dense2Dense))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Dense2Dense>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Dense2Dense))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_EigenBase2EigenBase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_EigenBase2EigenBase() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_EigenBase2EigenBase>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_EigenBase2EigenBase))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_EigenBase2EigenBase>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_EigenBase2EigenBase)
        )
    );
}
#[doc = " Part 6 : Generic assignment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_AssignmentKind {
    pub _address: u8,
}
pub type Eigen_internal_AssignmentKind_Kind = Eigen_internal_EigenBase2EigenBase;
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_DenseShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Assignment {
    pub _address: u8,
}
pub type Eigen_internal_conj_helper_Scalar = Eigen_ScalarBinaryOpTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_get_factor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_BlasVectorMapper<Scalar> {
    pub m_data: *mut Scalar,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Scalar>>,
}
pub type Eigen_internal_BlasLinearMapper_Packet = Eigen_internal_packet_traits;
pub type Eigen_internal_BlasLinearMapper_HalfPacket = Eigen_internal_packet_traits;
pub type Eigen_internal_blas_data_mapper_Packet = Eigen_internal_packet_traits;
pub type Eigen_internal_blas_data_mapper_HalfPacket = Eigen_internal_packet_traits;
pub type Eigen_internal_blas_data_mapper_LinearMapper = u8;
pub type Eigen_internal_blas_data_mapper_VectorMapper<Scalar> =
    Eigen_internal_BlasVectorMapper<Scalar>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_blas_traits {
    pub _address: u8,
}
pub type Eigen_internal_blas_traits_Scalar = Eigen_internal_traits;
pub type Eigen_internal_blas_traits_ExtractType<XprType> = *const XprType;
pub type Eigen_internal_blas_traits__ExtractType<XprType> = XprType;
pub const Eigen_internal_blas_traits_IsComplex: Eigen_internal_blas_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_blas_traits_IsTransposed: Eigen_internal_blas_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_blas_traits_NeedToConjugate: Eigen_internal_blas_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_blas_traits_HasUsableDirectAccess:
    Eigen_internal_blas_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_blas_traits__bindgen_ty_1 = i32;
pub type Eigen_internal_blas_traits_DirectLinearAccessType = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_constructor_without_unaligned_array_assert {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_constructor_without_unaligned_array_assert() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_constructor_without_unaligned_array_assert>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_constructor_without_unaligned_array_assert)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_constructor_without_unaligned_array_assert>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_constructor_without_unaligned_array_assert)
        )
    );
}
#[doc = " \\internal\n \\brief Template functor to compute the conjugate product of two scalars\n\n This is a short cut for conj(x) * y which is needed for optimization purpose; in Eigen2 support mode, this becomes x * conj(y)"]
pub type Eigen_internal_dot_nocheck_conj_prod = Eigen_internal_scalar_conj_product_op;
pub type Eigen_internal_dot_nocheck_ResScalar = Eigen_internal_dot_nocheck_conj_prod;
pub type Eigen_internal_lpNorm_selector_RealScalar = Eigen_NumTraits;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_internal_BlockImpl_dense_BlockType = u8;
pub type Eigen_internal_BlockImpl_dense_XprTypeNested = Eigen_internal_ref_selector;
pub type Eigen_internal_BlockImpl_dense_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_internal_BlockImpl_dense_Scalar = Eigen_internal_traits;
pub type Eigen_internal_BlockImpl_dense_RealScalar = Eigen_NumTraits;
pub type Eigen_internal_BlockImpl_dense_CoeffReturnType = Eigen_internal_BlockImpl_dense_Base;
pub type Eigen_internal_BlockImpl_dense_Nested = Eigen_internal_ref_selector;
pub type Eigen_internal_BlockImpl_dense_StorageKind = Eigen_internal_traits;
pub type Eigen_internal_BlockImpl_dense_StorageIndex = Eigen_internal_traits;
pub const Eigen_internal_BlockImpl_dense_RowsAtCompileTime:
    Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub const Eigen_internal_BlockImpl_dense_ColsAtCompileTime:
    Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub const Eigen_internal_BlockImpl_dense_Flags: Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub const Eigen_internal_BlockImpl_dense_SizeAtCompileTime:
    Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub const Eigen_internal_BlockImpl_dense_MaxSizeAtCompileTime:
    Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub const Eigen_internal_BlockImpl_dense_IsVectorAtCompileTime:
    Eigen_internal_BlockImpl_dense__bindgen_ty_1 = 0;
pub type Eigen_internal_BlockImpl_dense__bindgen_ty_1 = i32;
pub type Eigen_internal_BlockImpl_dense_PacketScalar = Eigen_internal_BlockImpl_dense_Base;
pub type Eigen_internal_TransposeImpl_base_type = Eigen_internal_dense_xpr_base;
pub const Eigen_internal_check_transpose_aliasing_compile_time_selector_ret:
    Eigen_internal_check_transpose_aliasing_compile_time_selector__bindgen_ty_1 = 0;
pub type Eigen_internal_check_transpose_aliasing_compile_time_selector__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_Eigen_internal_storage_kind_to_shape_open0_Eigen_DiagonalShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_storage_kind_to_shape>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_storage_kind_to_shape)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Diagonal2Dense {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Diagonal2Dense() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Diagonal2Dense>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_Diagonal2Dense))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Diagonal2Dense>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Diagonal2Dense))
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_DiagonalShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[doc = " Part 1 : the logic deciding a strategy for vectorization and unrolling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_redux_traits {
    pub _address: u8,
}
pub type Eigen_internal_redux_traits_PacketType = [u8; 0usize];
pub const Eigen_internal_redux_traits_PacketSize: Eigen_internal_redux_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_traits_InnerMaxSize: Eigen_internal_redux_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_redux_traits__bindgen_ty_1 = i32;
pub const Eigen_internal_redux_traits_MightVectorize: Eigen_internal_redux_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_redux_traits_MayLinearVectorize:
    Eigen_internal_redux_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_redux_traits_MaySliceVectorize: Eigen_internal_redux_traits__bindgen_ty_2 =
    0;
pub type Eigen_internal_redux_traits__bindgen_ty_2 = i32;
pub const Eigen_internal_redux_traits_Traversal: Eigen_internal_redux_traits__bindgen_ty_3 = 0;
pub type Eigen_internal_redux_traits__bindgen_ty_3 = i32;
pub const Eigen_internal_redux_traits_Cost: Eigen_internal_redux_traits__bindgen_ty_4 = 0;
pub const Eigen_internal_redux_traits_UnrollingLimit: Eigen_internal_redux_traits__bindgen_ty_4 = 0;
pub type Eigen_internal_redux_traits__bindgen_ty_4 = i32;
pub const Eigen_internal_redux_traits_Unrolling: Eigen_internal_redux_traits__bindgen_ty_5 = 0;
pub type Eigen_internal_redux_traits__bindgen_ty_5 = i32;
pub const Eigen_internal_redux_novec_unroller_HalfLength:
    Eigen_internal_redux_novec_unroller__bindgen_ty_1 = 0;
pub type Eigen_internal_redux_novec_unroller__bindgen_ty_1 = i32;
pub type Eigen_internal_redux_novec_unroller_Scalar = [u8; 0usize];
pub const Eigen_internal_redux_vec_unroller_PacketSize:
    Eigen_internal_redux_vec_unroller__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_vec_unroller_HalfLength:
    Eigen_internal_redux_vec_unroller__bindgen_ty_1 = 0;
pub type Eigen_internal_redux_vec_unroller__bindgen_ty_1 = i32;
pub type Eigen_internal_redux_vec_unroller_Scalar = [u8; 0usize];
pub type Eigen_internal_redux_vec_unroller_PacketScalar = Eigen_internal_redux_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_redux_evaluator<_XprType> {
    pub m_evaluator: Eigen_internal_evaluator,
    pub m_xpr: *const Eigen_internal_redux_evaluator_XprType<_XprType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_XprType>>,
}
pub type Eigen_internal_redux_evaluator_XprType<_XprType> = _XprType;
pub type Eigen_internal_redux_evaluator_Scalar = [u8; 0usize];
pub type Eigen_internal_redux_evaluator_CoeffReturnType = [u8; 0usize];
pub type Eigen_internal_redux_evaluator_PacketScalar = [u8; 0usize];
pub type Eigen_internal_redux_evaluator_PacketReturnType = [u8; 0usize];
pub const Eigen_internal_redux_evaluator_MaxRowsAtCompileTime:
    Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_MaxColsAtCompileTime:
    Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_Flags: Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_IsRowMajor: Eigen_internal_redux_evaluator__bindgen_ty_1 =
    0;
pub const Eigen_internal_redux_evaluator_SizeAtCompileTime:
    Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_InnerSizeAtCompileTime:
    Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_CoeffReadCost:
    Eigen_internal_redux_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_redux_evaluator_Alignment: Eigen_internal_redux_evaluator__bindgen_ty_1 =
    0;
pub type Eigen_internal_redux_evaluator__bindgen_ty_1 = i32;
pub const Eigen_internal_visitor_impl_col: Eigen_internal_visitor_impl__bindgen_ty_1 = 0;
pub const Eigen_internal_visitor_impl_row: Eigen_internal_visitor_impl__bindgen_ty_1 = 0;
pub type Eigen_internal_visitor_impl__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_visitor_evaluator<XprType> {
    pub m_evaluator: Eigen_internal_evaluator,
    pub m_xpr: *const XprType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<XprType>>,
}
pub type Eigen_internal_visitor_evaluator_Scalar = [u8; 0usize];
pub type Eigen_internal_visitor_evaluator_CoeffReturnType = [u8; 0usize];
pub const Eigen_internal_visitor_evaluator_RowsAtCompileTime:
    Eigen_internal_visitor_evaluator__bindgen_ty_1 = 0;
pub const Eigen_internal_visitor_evaluator_CoeffReadCost:
    Eigen_internal_visitor_evaluator__bindgen_ty_1 = 0;
pub type Eigen_internal_visitor_evaluator__bindgen_ty_1 = i32;
#[doc = " \\internal\n \\brief Base class to implement min and max visitors"]
#[repr(C)]
pub struct Eigen_internal_coeff_visitor {
    pub row: Eigen_Index,
    pub col: Eigen_Index,
    pub res: Eigen_internal_coeff_visitor_Scalar,
}
pub type Eigen_internal_coeff_visitor_Scalar = [u8; 0usize];
#[doc = " \\internal\n \\brief Visitor computing the min coefficient with its value and coordinates\n\n \\sa DenseBase::minCoeff(Index*, Index*)"]
#[repr(C)]
pub struct Eigen_internal_min_coeff_visitor {
    pub _base: Eigen_internal_coeff_visitor,
}
pub type Eigen_internal_min_coeff_visitor_Scalar = [u8; 0usize];
#[doc = " \\internal\n \\brief Visitor computing the max coefficient with its value and coordinates\n\n \\sa DenseBase::maxCoeff(Index*, Index*)"]
#[repr(C)]
pub struct Eigen_internal_max_coeff_visitor {
    pub _base: Eigen_internal_coeff_visitor,
}
pub type Eigen_internal_max_coeff_visitor_Scalar = [u8; 0usize];
pub const Eigen_internal_product_size_category_is_large:
    Eigen_internal_product_size_category__bindgen_ty_1 = 0;
pub const Eigen_internal_product_size_category_value:
    Eigen_internal_product_size_category__bindgen_ty_1 = 0;
pub type Eigen_internal_product_size_category__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_product_type {
    pub _address: u8,
}
pub type Eigen_internal_product_type__Lhs = Eigen_internal_remove_all;
pub type Eigen_internal_product_type__Rhs = Eigen_internal_remove_all;
pub const Eigen_internal_product_type_MaxRows: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub const Eigen_internal_product_type_Rows: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub const Eigen_internal_product_type_MaxCols: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub const Eigen_internal_product_type_Cols: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub const Eigen_internal_product_type_MaxDepth: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub const Eigen_internal_product_type_Depth: Eigen_internal_product_type__bindgen_ty_1 = 0;
pub type Eigen_internal_product_type__bindgen_ty_1 = i32;
pub const Eigen_internal_product_type_rows_select: Eigen_internal_product_type__bindgen_ty_2 = 0;
pub const Eigen_internal_product_type_cols_select: Eigen_internal_product_type__bindgen_ty_2 = 0;
pub const Eigen_internal_product_type_depth_select: Eigen_internal_product_type__bindgen_ty_2 = 0;
pub type Eigen_internal_product_type__bindgen_ty_2 = i32;
pub const Eigen_internal_product_type_value: Eigen_internal_product_type__bindgen_ty_3 = 0;
pub const Eigen_internal_product_type_ret: Eigen_internal_product_type__bindgen_ty_3 = 0;
pub type Eigen_internal_product_type__bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_solve_traits {
    pub _address: u8,
}
pub const Eigen_internal_PermPermProduct_t_PermPermProduct: Eigen_internal_PermPermProduct_t = 0;
pub type Eigen_internal_PermPermProduct_t = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_PermutationShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Triangular2Triangular {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Triangular2Triangular() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Triangular2Triangular>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_Triangular2Triangular)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Triangular2Triangular>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_Triangular2Triangular)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Triangular2Dense {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Triangular2Dense() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Triangular2Dense>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_Triangular2Dense))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Triangular2Dense>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Triangular2Dense))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_Dense2Triangular {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_Dense2Triangular() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_Dense2Triangular>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_Dense2Triangular))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_Dense2Triangular>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_Dense2Triangular))
    );
}
#[doc = " Part 4 : Generic dense assignment kernel"]
pub type Eigen_internal_triangular_dense_assignment_kernel_Base = u8;
pub type Eigen_internal_triangular_dense_assignment_kernel_DstXprType =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
pub type Eigen_internal_triangular_dense_assignment_kernel_SrcXprType =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
pub type Eigen_internal_triangular_dense_assignment_kernel_DstEvaluatorType =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
pub type Eigen_internal_triangular_dense_assignment_kernel_SrcEvaluatorType =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
pub type Eigen_internal_triangular_dense_assignment_kernel_Scalar =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
pub type Eigen_internal_triangular_dense_assignment_kernel_AssignmentTraits =
    Eigen_internal_triangular_dense_assignment_kernel_Base;
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_TriangularShape_Eigen_TriangularShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_TriangularShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_TriangularShape_Eigen_DenseShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
pub type Eigen_internal_triangular_assignment_loop_DstEvaluatorType = [u8; 0usize];
pub type Eigen_internal_triangular_assignment_loop_DstXprType = [u8; 0usize];
pub const Eigen_internal_triangular_assignment_loop_col:
    Eigen_internal_triangular_assignment_loop__bindgen_ty_1 = 0;
pub const Eigen_internal_triangular_assignment_loop_row:
    Eigen_internal_triangular_assignment_loop__bindgen_ty_1 = 0;
pub type Eigen_internal_triangular_assignment_loop__bindgen_ty_1 = i32;
pub type Eigen_internal_triangular_assignment_loop_Scalar = [u8; 0usize];
pub const Eigen_internal_defaultL1CacheSize: isize = 32768;
pub const Eigen_internal_defaultL2CacheSize: isize = 262144;
pub const Eigen_internal_defaultL3CacheSize: isize = 2097152;
#[doc = " \\internal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_CacheSizes {
    pub m_l1: isize,
    pub m_l2: isize,
    pub m_l3: isize,
}
#[test]
fn bindgen_test_layout_Eigen_internal_CacheSizes() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_internal_CacheSizes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_CacheSizes>(),
        24usize,
        concat!("Size of: ", stringify!(Eigen_internal_CacheSizes))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_CacheSizes>(),
        8usize,
        concat!("Alignment of ", stringify!(Eigen_internal_CacheSizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_l1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_CacheSizes),
            "::",
            stringify!(m_l1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_l2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_CacheSizes),
            "::",
            stringify!(m_l2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_l3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_internal_CacheSizes),
            "::",
            stringify!(m_l3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_gebp_madd_selector {
    pub _address: u8,
}
pub type Eigen_internal_gebp_traits_LhsScalar<_LhsScalar> = _LhsScalar;
pub type Eigen_internal_gebp_traits_RhsScalar<_RhsScalar> = _RhsScalar;
pub type Eigen_internal_gebp_traits_ResScalar = Eigen_ScalarBinaryOpTraits;
pub const Eigen_internal_gebp_traits_ConjLhs: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_ConjRhs: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_Vectorizable: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_LhsPacketSize: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_RhsPacketSize: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_ResPacketSize: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_NumberOfRegisters: Eigen_internal_gebp_traits__bindgen_ty_1 =
    0;
pub const Eigen_internal_gebp_traits_nr: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_default_mr: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_mr: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_LhsProgress: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_traits_RhsProgress: Eigen_internal_gebp_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_gebp_traits__bindgen_ty_1 = i32;
pub type Eigen_internal_gebp_traits__LhsPacket = Eigen_internal_packet_traits;
pub type Eigen_internal_gebp_traits__RhsPacket = Eigen_internal_packet_traits;
pub type Eigen_internal_gebp_traits__ResPacket = Eigen_internal_packet_traits;
pub type Eigen_internal_gebp_traits_LhsPacket = u8;
pub type Eigen_internal_gebp_traits_RhsPacket = u8;
pub type Eigen_internal_gebp_traits_ResPacket = u8;
pub type Eigen_internal_gebp_traits_AccPacket = Eigen_internal_gebp_traits_ResPacket;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_DoublePacket<Packet> {
    pub first: Packet,
    pub second: Packet,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Packet>>,
}
pub type Eigen_internal_gebp_kernel_Traits = u8;
pub type Eigen_internal_gebp_kernel_ResScalar = Eigen_internal_gebp_kernel_Traits;
pub type Eigen_internal_gebp_kernel_LhsPacket = Eigen_internal_gebp_kernel_Traits;
pub type Eigen_internal_gebp_kernel_RhsPacket = Eigen_internal_gebp_kernel_Traits;
pub type Eigen_internal_gebp_kernel_ResPacket = Eigen_internal_gebp_kernel_Traits;
pub type Eigen_internal_gebp_kernel_AccPacket = Eigen_internal_gebp_kernel_Traits;
pub type Eigen_internal_gebp_kernel_SwappedTraits = u8;
pub type Eigen_internal_gebp_kernel_SResScalar = Eigen_internal_gebp_kernel_SwappedTraits;
pub type Eigen_internal_gebp_kernel_SLhsPacket = Eigen_internal_gebp_kernel_SwappedTraits;
pub type Eigen_internal_gebp_kernel_SRhsPacket = Eigen_internal_gebp_kernel_SwappedTraits;
pub type Eigen_internal_gebp_kernel_SResPacket = Eigen_internal_gebp_kernel_SwappedTraits;
pub type Eigen_internal_gebp_kernel_SAccPacket = Eigen_internal_gebp_kernel_SwappedTraits;
pub type Eigen_internal_gebp_kernel_LinearMapper = [u8; 0usize];
pub const Eigen_internal_gebp_kernel_Vectorizable: Eigen_internal_gebp_kernel__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_kernel_LhsProgress: Eigen_internal_gebp_kernel__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_kernel_RhsProgress: Eigen_internal_gebp_kernel__bindgen_ty_1 = 0;
pub const Eigen_internal_gebp_kernel_ResPacketSize: Eigen_internal_gebp_kernel__bindgen_ty_1 = 0;
pub type Eigen_internal_gebp_kernel__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_GemmParallelInfo<Index> {
    pub sync: Index,
    pub users: ::std::os::raw::c_int,
    pub lhs_start: Index,
    pub lhs_length: Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Index>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_assignment_from_xpr_op_product {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_generic_product_impl_base {
    pub _address: u8,
}
pub type Eigen_internal_generic_product_impl_base_Scalar = u8;
pub type Eigen_internal_diagonal_product_evaluator_base_Scalar = [u8; 0usize];
pub const Eigen_internal_diagonal_product_evaluator_base_CoeffReadCost:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base_MatrixFlags:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base_DiagFlags:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base__StorageOrder:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base__ScalarAccessOnDiag:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base__SameTypes:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base__Vectorizable:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base__LinearAccessMask:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base_Flags:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base_Alignment:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub const Eigen_internal_diagonal_product_evaluator_base_AsScalarProduct:
    Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = 0;
pub type Eigen_internal_diagonal_product_evaluator_base__bindgen_ty_1 = i32;
pub type Eigen_internal_transposition_matrix_product_MatrixType = u8;
pub type Eigen_internal_transposition_matrix_product_MatrixTypeCleaned = Eigen_internal_remove_all;
#[doc = "  Specialization of generic_product_impl for \"large\" GEMM, i.e.,\n  implementation of the high level wrapper to general_matrix_matrix_product"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_gemm_functor<Scalar, Lhs, Rhs, Dest, BlockingType> {
    pub m_lhs: *const Lhs,
    pub m_rhs: *const Rhs,
    pub m_dest: *mut Dest,
    pub m_actualAlpha: Scalar,
    pub m_blocking: *mut BlockingType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Scalar>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Lhs>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<Rhs>>,
    pub _phantom_3: ::std::marker::PhantomData<::std::cell::UnsafeCell<Dest>>,
    pub _phantom_4: ::std::marker::PhantomData<::std::cell::UnsafeCell<BlockingType>>,
}
pub type Eigen_internal_gemm_functor_Traits = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_level3_blocking<_LhsScalar, _RhsScalar> {
    pub m_blockA: *mut Eigen_internal_level3_blocking_LhsScalar<_LhsScalar>,
    pub m_blockB: *mut Eigen_internal_level3_blocking_RhsScalar<_RhsScalar>,
    pub m_mc: Eigen_Index,
    pub m_nc: Eigen_Index,
    pub m_kc: Eigen_Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_LhsScalar>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RhsScalar>>,
}
pub type Eigen_internal_level3_blocking_LhsScalar<_LhsScalar> = _LhsScalar;
pub type Eigen_internal_level3_blocking_RhsScalar<_RhsScalar> = _RhsScalar;
pub const Eigen_internal_trsolve_traits_RhsIsVectorAtCompileTime:
    Eigen_internal_trsolve_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_trsolve_traits__bindgen_ty_1 = i32;
pub const Eigen_internal_trsolve_traits_Unrolling: Eigen_internal_trsolve_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_trsolve_traits_RhsVectors: Eigen_internal_trsolve_traits__bindgen_ty_2 = 0;
pub type Eigen_internal_trsolve_traits__bindgen_ty_2 = i32;
pub type Eigen_internal_triangular_solve_retval_RhsNestedCleaned = [u8; 0usize];
#[doc = " \\class ReturnByValue\n \\ingroup Core_Module\n"]
pub type Eigen_internal_triangular_solve_retval_Base = Eigen_ReturnByValue;
pub type Eigen_internal_tribb_kernel_Traits = u8;
pub type Eigen_internal_tribb_kernel_ResScalar = Eigen_internal_tribb_kernel_Traits;
pub const Eigen_internal_tribb_kernel_BlockSize: Eigen_internal_tribb_kernel__bindgen_ty_1 = 0;
pub type Eigen_internal_tribb_kernel__bindgen_ty_1 = i32;
pub const Eigen_internal_symm_pack_rhs_PacketSize: Eigen_internal_symm_pack_rhs__bindgen_ty_1 = 0;
pub type Eigen_internal_symm_pack_rhs__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_BandMatrixBase {
    pub _address: u8,
}
pub const Eigen_internal_BandMatrixBase_Flags: Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_CoeffReadCost: Eigen_internal_BandMatrixBase__bindgen_ty_1 =
    0;
pub const Eigen_internal_BandMatrixBase_RowsAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_ColsAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_MaxRowsAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_MaxColsAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_Supers: Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_Subs: Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_Options: Eigen_internal_BandMatrixBase__bindgen_ty_1 = 0;
pub type Eigen_internal_BandMatrixBase__bindgen_ty_1 = i32;
pub type Eigen_internal_BandMatrixBase_Scalar = Eigen_internal_traits;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_BandMatrixBase_DenseMatrixType = u8;
pub type Eigen_internal_BandMatrixBase_StorageIndex = Eigen_internal_BandMatrixBase_DenseMatrixType;
pub type Eigen_internal_BandMatrixBase_CoefficientsType = Eigen_internal_traits;
#[doc = " \\class EigenBase\n \\ingroup Core_Module\n\n Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor MatrixBase(T).\n\n In other words, an EigenBase object is an object that can be copied into a MatrixBase.\n\n Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal matrices, etc.\n\n Notice that this class is trivial, it is only used to disambiguate overloaded functions.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_internal_BandMatrixBase_Base = Eigen_EigenBase;
pub const Eigen_internal_BandMatrixBase_DataRowsAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_2 = 0;
pub const Eigen_internal_BandMatrixBase_SizeAtCompileTime:
    Eigen_internal_BandMatrixBase__bindgen_ty_2 = 0;
pub type Eigen_internal_BandMatrixBase__bindgen_ty_2 = i32;
pub const Eigen_internal_BandMatrixBase_DiagonalIntReturnType_ReturnOpposite:
    Eigen_internal_BandMatrixBase_DiagonalIntReturnType__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_DiagonalIntReturnType_Conjugate:
    Eigen_internal_BandMatrixBase_DiagonalIntReturnType__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_DiagonalIntReturnType_ActualIndex:
    Eigen_internal_BandMatrixBase_DiagonalIntReturnType__bindgen_ty_1 = 0;
pub const Eigen_internal_BandMatrixBase_DiagonalIntReturnType_DiagonalSize:
    Eigen_internal_BandMatrixBase_DiagonalIntReturnType__bindgen_ty_1 = 0;
pub type Eigen_internal_BandMatrixBase_DiagonalIntReturnType__bindgen_ty_1 = i32;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_internal_BandMatrixBase_DiagonalIntReturnType_BuildType = u8;
pub type Eigen_internal_BandMatrixBase_DiagonalIntReturnType_Type = u8;
pub type Eigen_internal_BandMatrix_Scalar = Eigen_internal_traits;
pub type Eigen_internal_BandMatrix_StorageIndex = Eigen_internal_traits;
pub type Eigen_internal_BandMatrix_CoefficientsType = Eigen_internal_traits;
pub type Eigen_internal_BandMatrixWrapper_Scalar = Eigen_internal_traits;
pub type Eigen_internal_BandMatrixWrapper_CoefficientsType = Eigen_internal_traits;
pub type Eigen_internal_BandMatrixWrapper_StorageIndex = Eigen_internal_traits;
pub type Eigen_internal_TridiagonalMatrix_Base = u8;
pub type Eigen_internal_TridiagonalMatrix_StorageIndex = Eigen_internal_TridiagonalMatrix_Base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_BandShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_BandShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_BandShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_internal_BandShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_BandShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_internal_BandShape))
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_internal_BandShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_inner_iterator_selector {
    pub _address: u8,
}
pub type Eigen_internal_all_unroller_Traits = [u8; 0usize];
pub const Eigen_internal_all_unroller_col: Eigen_internal_all_unroller__bindgen_ty_1 = 0;
pub const Eigen_internal_all_unroller_row: Eigen_internal_all_unroller__bindgen_ty_1 = 0;
pub type Eigen_internal_all_unroller__bindgen_ty_1 = i32;
pub type Eigen_internal_any_unroller_Traits = [u8; 0usize];
pub const Eigen_internal_any_unroller_col: Eigen_internal_any_unroller__bindgen_ty_1 = 0;
pub const Eigen_internal_any_unroller_row: Eigen_internal_any_unroller__bindgen_ty_1 = 0;
pub type Eigen_internal_any_unroller__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_squaredNorm {
    pub _address: u8,
}
pub type Eigen_internal_member_squaredNorm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_squaredNorm_Cost_value:
    Eigen_internal_member_squaredNorm_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_squaredNorm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_norm {
    pub _address: u8,
}
pub type Eigen_internal_member_norm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_norm_Cost_value: Eigen_internal_member_norm_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_norm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_stableNorm {
    pub _address: u8,
}
pub type Eigen_internal_member_stableNorm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_stableNorm_Cost_value:
    Eigen_internal_member_stableNorm_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_stableNorm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_blueNorm {
    pub _address: u8,
}
pub type Eigen_internal_member_blueNorm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_blueNorm_Cost_value:
    Eigen_internal_member_blueNorm_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_blueNorm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_hypotNorm {
    pub _address: u8,
}
pub type Eigen_internal_member_hypotNorm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_hypotNorm_Cost_value:
    Eigen_internal_member_hypotNorm_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_hypotNorm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_sum {
    pub _address: u8,
}
pub type Eigen_internal_member_sum_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_sum_Cost_value: Eigen_internal_member_sum_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_sum_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_mean {
    pub _address: u8,
}
pub type Eigen_internal_member_mean_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_mean_Cost_value: Eigen_internal_member_mean_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_mean_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_minCoeff {
    pub _address: u8,
}
pub type Eigen_internal_member_minCoeff_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_minCoeff_Cost_value:
    Eigen_internal_member_minCoeff_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_minCoeff_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_maxCoeff {
    pub _address: u8,
}
pub type Eigen_internal_member_maxCoeff_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_maxCoeff_Cost_value:
    Eigen_internal_member_maxCoeff_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_maxCoeff_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_all {
    pub _address: u8,
}
pub type Eigen_internal_member_all_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_all_Cost_value: Eigen_internal_member_all_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_all_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_any {
    pub _address: u8,
}
pub type Eigen_internal_member_any_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_any_Cost_value: Eigen_internal_member_any_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_any_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_count {
    pub _address: u8,
}
pub type Eigen_internal_member_count_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_count_Cost_value: Eigen_internal_member_count_Cost__bindgen_ty_1 =
    0;
pub type Eigen_internal_member_count_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_prod {
    pub _address: u8,
}
pub type Eigen_internal_member_prod_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_prod_Cost_value: Eigen_internal_member_prod_Cost__bindgen_ty_1 = 0;
pub type Eigen_internal_member_prod_Cost__bindgen_ty_1 = i32;
pub type Eigen_internal_member_lpnorm_result_type<ResultType> = ResultType;
pub const Eigen_internal_member_lpnorm_Cost_value: Eigen_internal_member_lpnorm_Cost__bindgen_ty_1 =
    0;
pub type Eigen_internal_member_lpnorm_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_member_redux<BinaryOp> {
    pub m_functor: BinaryOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BinaryOp>>,
}
pub type Eigen_internal_member_redux_result_type = Eigen_internal_result_of;
pub const Eigen_internal_member_redux_Cost_value: Eigen_internal_member_redux_Cost__bindgen_ty_1 =
    0;
pub type Eigen_internal_member_redux_Cost__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_scalar_random_op {
    pub _address: u8,
}
pub const Eigen_internal_SignMatrix_PositiveSemiDef: Eigen_internal_SignMatrix = 0;
pub const Eigen_internal_SignMatrix_NegativeSemiDef: Eigen_internal_SignMatrix = 1;
pub const Eigen_internal_SignMatrix_ZeroSign: Eigen_internal_SignMatrix = 2;
pub const Eigen_internal_SignMatrix_Indefinite: Eigen_internal_SignMatrix = 3;
pub type Eigen_internal_SignMatrix = ::std::os::raw::c_uint;
pub const Eigen_internal_decrement_size_ret: Eigen_internal_decrement_size__bindgen_ty_1 = 0;
pub type Eigen_internal_decrement_size__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_HouseholderSequenceShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_internal_HouseholderSequenceShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_HouseholderSequenceShape>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_HouseholderSequenceShape)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_HouseholderSequenceShape>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_HouseholderSequenceShape)
        )
    );
}
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_internal_hseq_side_dependent_impl_EssentialVectorType = u8;
pub type Eigen_internal_hseq_side_dependent_impl_HouseholderSequenceType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_matrix_type_times_scalar_type {
    pub _address: u8,
}
pub type Eigen_internal_matrix_type_times_scalar_type_ResultScalar = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_matrix_type_times_scalar_type_Type = u8;
#[doc = " \\ingroup QR_Module\n\n \\brief Expression type for return value of FullPivHouseholderQR::matrixQ()\n\n \\tparam MatrixType type of underlying dense matrix"]
#[repr(C)]
pub struct Eigen_internal_FullPivHouseholderQRMatrixQReturnType {
    pub m_qr: [u8; 0usize],
    pub m_hCoeffs: [u8; 0usize],
    pub m_rowsTranspositions:
        Eigen_internal_FullPivHouseholderQRMatrixQReturnType_IntDiagSizeVectorType,
}
pub type Eigen_internal_FullPivHouseholderQRMatrixQReturnType_IntDiagSizeVectorType =
    Eigen_FullPivHouseholderQR<_MatrixType>;
pub type Eigen_internal_FullPivHouseholderQRMatrixQReturnType_HCoeffsType = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_FullPivHouseholderQRMatrixQReturnType_WorkVectorType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_UpperBidiagonalization<_MatrixType> {
    pub m_householder: Eigen_internal_UpperBidiagonalization_MatrixType<_MatrixType>,
    pub m_bidiagonal: Eigen_internal_UpperBidiagonalization_BidiagonalType,
    pub m_isInitialized: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_internal_UpperBidiagonalization_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_internal_UpperBidiagonalization_RowsAtCompileTime:
    Eigen_internal_UpperBidiagonalization__bindgen_ty_1 = 0;
pub const Eigen_internal_UpperBidiagonalization_ColsAtCompileTime:
    Eigen_internal_UpperBidiagonalization__bindgen_ty_1 = 0;
pub const Eigen_internal_UpperBidiagonalization_ColsAtCompileTimeMinusOne:
    Eigen_internal_UpperBidiagonalization__bindgen_ty_1 = 0;
pub type Eigen_internal_UpperBidiagonalization__bindgen_ty_1 = i32;
pub type Eigen_internal_UpperBidiagonalization_Scalar = [u8; 0usize];
pub type Eigen_internal_UpperBidiagonalization_RealScalar = [u8; 0usize];
pub type Eigen_internal_UpperBidiagonalization_Index = Eigen_Index;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_UpperBidiagonalization_RowVectorType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_UpperBidiagonalization_ColVectorType = u8;
pub type Eigen_internal_UpperBidiagonalization_BidiagonalType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_UpperBidiagonalization_DiagVectorType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_UpperBidiagonalization_SuperDiagVectorType = u8;
pub type Eigen_internal_UpperBidiagonalization_HouseholderUSequenceType = u8;
pub type Eigen_internal_UpperBidiagonalization_HouseholderVSequenceType = u8;
pub const PreconditionIfMoreColsThanRows: Eigen_internal__bindgen_ty_2 = 0;
pub const PreconditionIfMoreRowsThanCols: Eigen_internal__bindgen_ty_2 = 1;
#[doc = " QR preconditioners (R-SVD)\n\n Their role is to reduce the problem of computing the SVD to the case of a square matrix.\n This approach, known as R-SVD, is an optimization for rectangular-enough matrices, and is a requirement for\n JacobiSVD which by itself is only able to work on square matrices."]
pub type Eigen_internal__bindgen_ty_2 = ::std::os::raw::c_uint;
pub const Eigen_internal_qr_preconditioner_should_do_anything_a:
    Eigen_internal_qr_preconditioner_should_do_anything__bindgen_ty_1 = 0;
pub const Eigen_internal_qr_preconditioner_should_do_anything_b:
    Eigen_internal_qr_preconditioner_should_do_anything__bindgen_ty_1 = 0;
pub const Eigen_internal_qr_preconditioner_should_do_anything_ret:
    Eigen_internal_qr_preconditioner_should_do_anything__bindgen_ty_1 = 0;
pub type Eigen_internal_qr_preconditioner_should_do_anything__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_kernel_retval_base<_DecompositionType> {
    pub m_dec: *const Eigen_internal_kernel_retval_base_DecompositionType<_DecompositionType>,
    pub m_rank: Eigen_Index,
    pub m_cols: Eigen_Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_DecompositionType>>,
}
pub type Eigen_internal_kernel_retval_base_DecompositionType<_DecompositionType> =
    _DecompositionType;
#[doc = " \\class ReturnByValue\n \\ingroup Core_Module\n"]
pub type Eigen_internal_kernel_retval_base_Base = Eigen_ReturnByValue;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_internal_image_retval_base<_DecompositionType> {
    pub m_dec: *const Eigen_internal_image_retval_base_DecompositionType<_DecompositionType>,
    pub m_rank: Eigen_Index,
    pub m_cols: Eigen_Index,
    pub m_originalMatrix: *const Eigen_internal_image_retval_base_MatrixType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_DecompositionType>>,
}
pub type Eigen_internal_image_retval_base_DecompositionType<_DecompositionType> =
    _DecompositionType;
pub type Eigen_internal_image_retval_base_MatrixType = [u8; 0usize];
#[doc = " \\class ReturnByValue\n \\ingroup Core_Module\n"]
pub type Eigen_internal_image_retval_base_Base = Eigen_ReturnByValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_enable_if_ref {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_internal_partial_lu_impl_MapLU = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_internal_partial_lu_impl_MatrixType = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_internal_partial_lu_impl_BlockType = u8;
pub type Eigen_internal_partial_lu_impl_RealScalar = Eigen_internal_partial_lu_impl_MatrixType;
pub type Eigen_internal_unitOrthogonal_selector_VectorType = Eigen_internal_plain_matrix_type;
pub type Eigen_internal_unitOrthogonal_selector_Scalar = Eigen_internal_traits;
pub type Eigen_internal_unitOrthogonal_selector_RealScalar = Eigen_NumTraits;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_unitOrthogonal_selector_Vector2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_homogeneous_left_product_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_homogeneous_right_product_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_take_matrix_for_product {
    pub _address: u8,
}
pub type Eigen_internal_take_matrix_for_product_type<MatrixOrTransformType> = MatrixOrTransformType;
#[test]
fn __bindgen_test_layout_Eigen_internal_AssignmentKind_open0_Eigen_DenseShape_Eigen_HomogeneousShape_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_AssignmentKind>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_AssignmentKind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_homogeneous_right_product_refactoring_helper {
    pub _address: u8,
}
pub const Eigen_internal_homogeneous_right_product_refactoring_helper_Dim:
    Eigen_internal_homogeneous_right_product_refactoring_helper__bindgen_ty_1 = 0;
pub const Eigen_internal_homogeneous_right_product_refactoring_helper_Rows:
    Eigen_internal_homogeneous_right_product_refactoring_helper__bindgen_ty_1 = 0;
pub type Eigen_internal_homogeneous_right_product_refactoring_helper__bindgen_ty_1 = i32;
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_LinearBlockConst =
    [u8; 0usize];
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_LinearBlock = [u8; 0usize];
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_ConstantColumn = [u8; 0usize];
#[doc = " \\class Replicate\n \\ingroup Core_Module\n\n \\brief Expression of the multiple replication of a matrix or vector\n\n \\tparam MatrixType the type of the object we are replicating\n \\tparam RowFactor number of repetitions at compile time along the vertical direction, can be Dynamic.\n \\tparam ColFactor number of repetitions at compile time along the horizontal direction, can be Dynamic.\n\n This class represents an expression of the multiple replication of a matrix or vector.\n It is the return type of DenseBase::replicate() and most of the time\n this is the only way it is used.\n\n \\sa DenseBase::replicate()"]
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_ConstantBlock = u8;
#[doc = " \\class Product\n \\ingroup Core_Module\n\n \\brief Expression of the product of two arbitrary matrices or vectors\n\n \\tparam _Lhs the type of the left-hand side expression\n \\tparam _Rhs the type of the right-hand side expression\n\n This class represents an expression of the product of two arbitrary matrices.\n\n The other template parameters are:\n \\tparam Option     can be DefaultProduct, AliasFreeProduct, or LazyProduct\n"]
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_LinearProduct = u8;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_internal_homogeneous_right_product_refactoring_helper_Xpr =
    Eigen_CwiseBinaryOp<BinaryOp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_homogeneous_left_product_refactoring_helper {
    pub _address: u8,
}
pub const Eigen_internal_homogeneous_left_product_refactoring_helper_Dim:
    Eigen_internal_homogeneous_left_product_refactoring_helper__bindgen_ty_1 = 0;
pub const Eigen_internal_homogeneous_left_product_refactoring_helper_Cols:
    Eigen_internal_homogeneous_left_product_refactoring_helper__bindgen_ty_1 = 0;
pub type Eigen_internal_homogeneous_left_product_refactoring_helper__bindgen_ty_1 = i32;
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_LinearBlockConst = [u8; 0usize];
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_LinearBlock = [u8; 0usize];
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_ConstantColumn = [u8; 0usize];
#[doc = " \\class Replicate\n \\ingroup Core_Module\n\n \\brief Expression of the multiple replication of a matrix or vector\n\n \\tparam MatrixType the type of the object we are replicating\n \\tparam RowFactor number of repetitions at compile time along the vertical direction, can be Dynamic.\n \\tparam ColFactor number of repetitions at compile time along the horizontal direction, can be Dynamic.\n\n This class represents an expression of the multiple replication of a matrix or vector.\n It is the return type of DenseBase::replicate() and most of the time\n this is the only way it is used.\n\n \\sa DenseBase::replicate()"]
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_ConstantBlock = u8;
#[doc = " \\class Product\n \\ingroup Core_Module\n\n \\brief Expression of the product of two arbitrary matrices or vectors\n\n \\tparam _Lhs the type of the left-hand side expression\n \\tparam _Rhs the type of the right-hand side expression\n\n This class represents an expression of the product of two arbitrary matrices.\n\n The other template parameters are:\n \\tparam Option     can be DefaultProduct, AliasFreeProduct, or LazyProduct\n"]
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_LinearProduct = u8;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_internal_homogeneous_left_product_refactoring_helper_Xpr =
    Eigen_CwiseBinaryOp<BinaryOp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_transform_traits {
    pub _address: u8,
}
pub const Eigen_internal_transform_traits_Dim: Eigen_internal_transform_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_transform_traits_HDim: Eigen_internal_transform_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_transform_traits_Mode: Eigen_internal_transform_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_transform_traits_IsProjective:
    Eigen_internal_transform_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_transform_traits__bindgen_ty_1 = i32;
#[doc = " Specializations of take affine part            ***"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_transform_take_affine_part {
    pub _address: u8,
}
pub type Eigen_internal_transform_take_affine_part_MatrixType = [u8; 0usize];
pub type Eigen_internal_transform_take_affine_part_AffinePart = [u8; 0usize];
pub type Eigen_internal_transform_take_affine_part_ConstAffinePart = [u8; 0usize];
pub const Eigen_internal_transform_product_result_Mode:
    Eigen_internal_transform_product_result__bindgen_ty_1 = 0;
pub type Eigen_internal_transform_product_result__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_umeyama_transform_matrix_type {
    pub _address: u8,
}
pub const Eigen_internal_umeyama_transform_matrix_type_MinRowsAtCompileTime:
    Eigen_internal_umeyama_transform_matrix_type__bindgen_ty_1 = 0;
pub const Eigen_internal_umeyama_transform_matrix_type_HomogeneousDimension:
    Eigen_internal_umeyama_transform_matrix_type__bindgen_ty_1 = 0;
pub type Eigen_internal_umeyama_transform_matrix_type__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_internal_umeyama_transform_matrix_type_type = u8;
pub type Eigen_dcomplex = std_complex<f64>;
pub type Eigen_scomplex = std_complex<f32>;
pub type Eigen_BlasIndex = ::std::os::raw::c_int;
#[doc = " This value means that a positive quantity (e.g., a size) is not known at compile-time, and that instead the value is\n stored in some runtime variable.\n\n Changing the value of Dynamic breaks the ABI, as Dynamic is often used as a template parameter for Matrix."]
pub const Eigen_Dynamic: ::std::os::raw::c_int = -1;
#[doc = " This value means that a signed quantity (e.g., a signed index) is not known at compile-time, and that instead its value\n has to be specified at runtime."]
pub const Eigen_DynamicIndex: ::std::os::raw::c_int = 16777215;
#[doc = " This value means +Infinity; it is currently used only as the p parameter to MatrixBase::lpNorm<int>().\n The value Infinity there means the L-infinity norm."]
pub const Eigen_Infinity: ::std::os::raw::c_int = -1;
#[doc = " This value means that the cost to evaluate an expression coefficient is either very expensive or\n cannot be known at compile time.\n\n This value has to be positive to (1) simplify cost computation, and (2) allow to distinguish between a very expensive and very very expensive expressions.\n It thus must also be large enough to make sure unrolling won't happen and that sub expressions will be evaluated, but not too large to avoid overflow."]
pub const Eigen_HugeCost: ::std::os::raw::c_int = 10000;
#[doc = " \\ingroup flags\n\n for a matrix, this means that the storage order is row-major.\n If this bit is not set, the storage order is column-major.\n For an expression, this determines the storage order of\n the matrix created by evaluation of that expression.\n \\sa \\blank  \\ref TopicStorageOrders"]
pub const Eigen_RowMajorBit: ::std::os::raw::c_uint = 1;
#[doc = " \\ingroup flags\n means the expression should be evaluated by the calling expression"]
pub const Eigen_EvalBeforeNestingBit: ::std::os::raw::c_uint = 2;
#[doc = " \\ingroup flags\n \\deprecated\n means the expression should be evaluated before any assignment"]
pub const Eigen_EvalBeforeAssigningBit: ::std::os::raw::c_uint = 4;
#[doc = " \\ingroup flags\n\n Short version: means the expression might be vectorized\n\n Long version: means that the coefficients can be handled by packets\n and start at a memory location whose alignment meets the requirements\n of the present CPU architecture for optimized packet access. In the fixed-size\n case, there is the additional condition that it be possible to access all the\n coefficients by packets (this implies the requirement that the size be a multiple of 16 bytes,\n and that any nontrivial strides don't break the alignment). In the dynamic-size case,\n there is no such condition on the total size and strides, so it might not be possible to access\n all coeffs by packets.\n\n \\note This bit can be set regardless of whether vectorization is actually enabled.\n       To check for actual vectorizability, see \\a ActualPacketAccessBit."]
pub const Eigen_PacketAccessBit: ::std::os::raw::c_uint = 8;
#[doc = " \\ingroup flags\n\n If vectorization is enabled (EIGEN_VECTORIZE is defined) this constant\n is set to the value \\a PacketAccessBit.\n\n If vectorization is not enabled (EIGEN_VECTORIZE is not defined) this constant\n is set to the value 0."]
pub const Eigen_ActualPacketAccessBit: ::std::os::raw::c_uint = 8;
#[doc = " \\ingroup flags\n\n Short version: means the expression can be seen as 1D vector.\n\n Long version: means that one can access the coefficients\n of this expression by coeff(int), and coeffRef(int) in the case of a lvalue expression. These\n index-based access methods are guaranteed\n to not have to do any runtime computation of a (row, col)-pair from the index, so that it\n is guaranteed that whenever it is available, index-based access is at least as fast as\n (row,col)-based access. Expressions for which that isn't possible don't have the LinearAccessBit.\n\n If both PacketAccessBit and LinearAccessBit are set, then the\n packets of this expression can be accessed by packet(int), and writePacket(int) in the case of a\n lvalue expression.\n\n Typically, all vector expressions have the LinearAccessBit, but there is one exception:\n Product expressions don't have it, because it would be troublesome for vectorization, even when the\n Product is a vector expression. Thus, vector Product expressions allow index-based coefficient access but\n not index-based packet access, so they don't have the LinearAccessBit."]
pub const Eigen_LinearAccessBit: ::std::os::raw::c_uint = 16;
#[doc = " \\ingroup flags\n\n Means the expression has a coeffRef() method, i.e. is writable as its individual coefficients are directly addressable.\n This rules out read-only expressions.\n\n Note that DirectAccessBit and LvalueBit are mutually orthogonal, as there are examples of expression having one but note\n the other:\n   \\li writable expressions that don't have a very simple memory layout as a strided array, have LvalueBit but not DirectAccessBit\n   \\li Map-to-const expressions, for example Map<const Matrix>, have DirectAccessBit but not LvalueBit\n\n Expressions having LvalueBit also have their coeff() method returning a const reference instead of returning a new value."]
pub const Eigen_LvalueBit: ::std::os::raw::c_uint = 32;
#[doc = " \\ingroup flags\n\n Means that the underlying array of coefficients can be directly accessed as a plain strided array. The memory layout\n of the array of coefficients must be exactly the natural one suggested by rows(), cols(),\n outerStride(), innerStride(), and the RowMajorBit. This rules out expressions such as Diagonal, whose coefficients,\n though referencable, do not have such a regular memory layout.\n\n See the comment on LvalueBit for an explanation of how LvalueBit and DirectAccessBit are mutually orthogonal."]
pub const Eigen_DirectAccessBit: ::std::os::raw::c_uint = 64;
#[doc = " \\deprecated \\ingroup flags\n\n means the first coefficient packet is guaranteed to be aligned.\n An expression cannot has the AlignedBit without the PacketAccessBit flag.\n In other words, this means we are allow to perform an aligned packet access to the first element regardless\n of the expression kind:\n \\code\n expression.packet<Aligned>(0);\n \\endcode"]
pub const Eigen_AlignedBit: ::std::os::raw::c_uint = 128;
pub const Eigen_NestByRefBit: ::std::os::raw::c_uint = 256;
#[doc = " \\ingroup flags\n\n for an expression, this means that the storage order\n can be either row-major or column-major.\n The precise choice will be decided at evaluation time or when\n combined with other expressions.\n \\sa \\blank  \\ref RowMajorBit, \\ref TopicStorageOrders"]
pub const Eigen_NoPreferredStorageOrderBit: ::std::os::raw::c_uint = 512;
#[doc = " \\ingroup flags\n\n Means that the underlying coefficients can be accessed through pointers to the sparse (un)compressed storage format,\n that is, the expression provides:\n \\code\ninline const Scalar* valuePtr() const;\ninline const Index* innerIndexPtr() const;\ninline const Index* outerIndexPtr() const;\ninline const Index* innerNonZeroPtr() const;\n\\endcode"]
pub const Eigen_CompressedAccessBit: ::std::os::raw::c_uint = 1024;
pub const Eigen_HereditaryBits: ::std::os::raw::c_uint = 3;
#[doc = " View matrix as a lower triangular matrix."]
pub const Eigen_UpLoType_Lower: Eigen_UpLoType = 1;
#[doc = " View matrix as an upper triangular matrix."]
pub const Eigen_UpLoType_Upper: Eigen_UpLoType = 2;
#[doc = " %Matrix has ones on the diagonal; to be used in combination with #Lower or #Upper."]
pub const Eigen_UpLoType_UnitDiag: Eigen_UpLoType = 4;
#[doc = " %Matrix has zeros on the diagonal; to be used in combination with #Lower or #Upper."]
pub const Eigen_UpLoType_ZeroDiag: Eigen_UpLoType = 8;
#[doc = " View matrix as a lower triangular matrix with ones on the diagonal."]
pub const Eigen_UpLoType_UnitLower: Eigen_UpLoType = 5;
#[doc = " View matrix as an upper triangular matrix with ones on the diagonal."]
pub const Eigen_UpLoType_UnitUpper: Eigen_UpLoType = 6;
#[doc = " View matrix as a lower triangular matrix with zeros on the diagonal."]
pub const Eigen_UpLoType_StrictlyLower: Eigen_UpLoType = 9;
#[doc = " View matrix as an upper triangular matrix with zeros on the diagonal."]
pub const Eigen_UpLoType_StrictlyUpper: Eigen_UpLoType = 10;
#[doc = " Used in BandMatrix and SelfAdjointView to indicate that the matrix is self-adjoint."]
pub const Eigen_UpLoType_SelfAdjoint: Eigen_UpLoType = 16;
#[doc = " Used to support symmetric, non-selfadjoint, complex matrices."]
pub const Eigen_UpLoType_Symmetric: Eigen_UpLoType = 32;
#[doc = " \\ingroup enums\n Enum containing possible values for the \\c Mode or \\c UpLo parameter of\n MatrixBase::selfadjointView() and MatrixBase::triangularView(), and selfadjoint solvers."]
pub type Eigen_UpLoType = ::std::os::raw::c_uint;
#[doc = "< Data pointer has no specific alignment."]
pub const Eigen_AlignmentType_Unaligned: Eigen_AlignmentType = 0;
#[doc = "< Data pointer is aligned on a 8 bytes boundary."]
pub const Eigen_AlignmentType_Aligned8: Eigen_AlignmentType = 8;
#[doc = "< Data pointer is aligned on a 16 bytes boundary."]
pub const Eigen_AlignmentType_Aligned16: Eigen_AlignmentType = 16;
#[doc = "< Data pointer is aligned on a 32 bytes boundary."]
pub const Eigen_AlignmentType_Aligned32: Eigen_AlignmentType = 32;
#[doc = "< Data pointer is aligned on a 64 bytes boundary."]
pub const Eigen_AlignmentType_Aligned64: Eigen_AlignmentType = 64;
#[doc = "< Data pointer is aligned on a 128 bytes boundary."]
pub const Eigen_AlignmentType_Aligned128: Eigen_AlignmentType = 128;
pub const Eigen_AlignmentType_AlignedMask: Eigen_AlignmentType = 255;
#[doc = "< \\deprecated Synonym for Aligned16."]
pub const Eigen_AlignmentType_Aligned: Eigen_AlignmentType = 16;
pub const Eigen_AlignmentType_AlignedMax: Eigen_AlignmentType = 16;
#[doc = " \\ingroup enums\n Enum for indicating whether a buffer is aligned or not."]
pub type Eigen_AlignmentType = ::std::os::raw::c_uint;
pub const Eigen_CornerType_TopLeft: Eigen_CornerType = 0;
pub const Eigen_CornerType_TopRight: Eigen_CornerType = 1;
pub const Eigen_CornerType_BottomLeft: Eigen_CornerType = 2;
pub const Eigen_CornerType_BottomRight: Eigen_CornerType = 3;
#[doc = " \\ingroup enums\n Enum used by DenseBase::corner() in Eigen2 compatibility mode."]
pub type Eigen_CornerType = ::std::os::raw::c_uint;
#[doc = " For Reverse, all columns are reversed;\n for PartialReduxExpr and VectorwiseOp, act on columns."]
pub const Eigen_DirectionType_Vertical: Eigen_DirectionType = 0;
#[doc = " For Reverse, all rows are reversed;\n for PartialReduxExpr and VectorwiseOp, act on rows."]
pub const Eigen_DirectionType_Horizontal: Eigen_DirectionType = 1;
#[doc = " For Reverse, both rows and columns are reversed;\n not used for PartialReduxExpr and VectorwiseOp."]
pub const Eigen_DirectionType_BothDirections: Eigen_DirectionType = 2;
#[doc = " \\ingroup enums\n Enum containing possible values for the \\p Direction parameter of\n Reverse, PartialReduxExpr and VectorwiseOp."]
pub type Eigen_DirectionType = ::std::os::raw::c_uint;
#[doc = " \\internal Default traversal, no vectorization, no index-based access"]
pub const Eigen_TraversalType_DefaultTraversal: Eigen_TraversalType = 0;
#[doc = " \\internal No vectorization, use index-based access to have only one for loop instead of 2 nested loops"]
pub const Eigen_TraversalType_LinearTraversal: Eigen_TraversalType = 1;
#[doc = " \\internal Equivalent to a slice vectorization for fixed-size matrices having good alignment\n and good size"]
pub const Eigen_TraversalType_InnerVectorizedTraversal: Eigen_TraversalType = 2;
#[doc = " \\internal Vectorization path using a single loop plus scalar loops for the\n unaligned boundaries"]
pub const Eigen_TraversalType_LinearVectorizedTraversal: Eigen_TraversalType = 3;
#[doc = " \\internal Generic vectorization path using one vectorized loop per row/column with some\n scalar loops to handle the unaligned boundaries"]
pub const Eigen_TraversalType_SliceVectorizedTraversal: Eigen_TraversalType = 4;
#[doc = " \\internal Special case to properly handle incompatible scalar types or other defecting cases"]
pub const Eigen_TraversalType_InvalidTraversal: Eigen_TraversalType = 5;
#[doc = " \\internal Evaluate all entries at once"]
pub const Eigen_TraversalType_AllAtOnceTraversal: Eigen_TraversalType = 6;
#[doc = " \\internal \\ingroup enums\n Enum to specify how to traverse the entries of a matrix."]
pub type Eigen_TraversalType = ::std::os::raw::c_uint;
#[doc = " \\internal Do not unroll loops."]
pub const Eigen_UnrollingType_NoUnrolling: Eigen_UnrollingType = 0;
#[doc = " \\internal Unroll only the inner loop, but not the outer loop."]
pub const Eigen_UnrollingType_InnerUnrolling: Eigen_UnrollingType = 1;
#[doc = " \\internal Unroll both the inner and the outer loop. If there is only one loop,\n because linear traversal is used, then unroll that loop."]
pub const Eigen_UnrollingType_CompleteUnrolling: Eigen_UnrollingType = 2;
#[doc = " \\internal \\ingroup enums\n Enum to specify whether to unroll loops when traversing over the entries of a matrix."]
pub type Eigen_UnrollingType = ::std::os::raw::c_uint;
pub const Eigen_SpecializedType_Specialized: Eigen_SpecializedType = 0;
pub const Eigen_SpecializedType_BuiltIn: Eigen_SpecializedType = 1;
#[doc = " \\internal \\ingroup enums\n Enum to specify whether to use the default (built-in) implementation or the specialization."]
pub type Eigen_SpecializedType = ::std::os::raw::c_uint;
#[doc = " Storage order is column major (see \\ref TopicStorageOrders)."]
pub const Eigen_StorageOptions_ColMajor: Eigen_StorageOptions = 0;
#[doc = " Storage order is row major (see \\ref TopicStorageOrders)."]
pub const Eigen_StorageOptions_RowMajor: Eigen_StorageOptions = 1;
#[doc = " Align the matrix itself if it is vectorizable fixed-size"]
pub const Eigen_StorageOptions_AutoAlign: Eigen_StorageOptions = 0;
#[doc = " Don't require alignment for the matrix itself (the array of coefficients, if dynamically allocated, may still be requested to be aligned)"]
pub const Eigen_StorageOptions_DontAlign: Eigen_StorageOptions = 2;
#[doc = " \\ingroup enums\n Enum containing possible values for the \\p _Options template parameter of\n Matrix, Array and BandMatrix."]
pub type Eigen_StorageOptions = ::std::os::raw::c_uint;
#[doc = " Apply transformation on the left."]
pub const Eigen_SideType_OnTheLeft: Eigen_SideType = 1;
#[doc = " Apply transformation on the right."]
pub const Eigen_SideType_OnTheRight: Eigen_SideType = 2;
#[doc = " \\ingroup enums\n Enum for specifying whether to apply or solve on the left or right."]
pub type Eigen_SideType = ::std::os::raw::c_uint;
pub const Eigen_NoChange_t_NoChange: Eigen_NoChange_t = 0;
pub type Eigen_NoChange_t = ::std::os::raw::c_uint;
pub const Eigen_Sequential_t_Sequential: Eigen_Sequential_t = 0;
pub type Eigen_Sequential_t = ::std::os::raw::c_uint;
pub const Eigen_Default_t_Default: Eigen_Default_t = 0;
pub type Eigen_Default_t = ::std::os::raw::c_uint;
pub const Eigen_AmbiVectorMode_IsDense: Eigen_AmbiVectorMode = 0;
pub const Eigen_AmbiVectorMode_IsSparse: Eigen_AmbiVectorMode = 1;
#[doc = " \\internal \\ingroup enums\n Used in AmbiVector."]
pub type Eigen_AmbiVectorMode = ::std::os::raw::c_uint;
#[doc = " Read-only access via a member function."]
pub const Eigen_AccessorLevels_ReadOnlyAccessors: Eigen_AccessorLevels = 0;
#[doc = " Read/write access via member functions."]
pub const Eigen_AccessorLevels_WriteAccessors: Eigen_AccessorLevels = 1;
#[doc = " Direct read-only access to the coefficients."]
pub const Eigen_AccessorLevels_DirectAccessors: Eigen_AccessorLevels = 2;
#[doc = " Direct read/write access to the coefficients."]
pub const Eigen_AccessorLevels_DirectWriteAccessors: Eigen_AccessorLevels = 3;
#[doc = " \\ingroup enums\n Used as template parameter in DenseCoeffBase and MapBase to indicate\n which accessors should be provided."]
pub type Eigen_AccessorLevels = ::std::os::raw::c_uint;
#[doc = " \\internal Not used (meant for LDLT?)."]
pub const Eigen_DecompositionOptions_Pivoting: Eigen_DecompositionOptions = 1;
#[doc = " \\internal Not used (meant for LDLT?)."]
pub const Eigen_DecompositionOptions_NoPivoting: Eigen_DecompositionOptions = 2;
#[doc = " Used in JacobiSVD to indicate that the square matrix U is to be computed."]
pub const Eigen_DecompositionOptions_ComputeFullU: Eigen_DecompositionOptions = 4;
#[doc = " Used in JacobiSVD to indicate that the thin matrix U is to be computed."]
pub const Eigen_DecompositionOptions_ComputeThinU: Eigen_DecompositionOptions = 8;
#[doc = " Used in JacobiSVD to indicate that the square matrix V is to be computed."]
pub const Eigen_DecompositionOptions_ComputeFullV: Eigen_DecompositionOptions = 16;
#[doc = " Used in JacobiSVD to indicate that the thin matrix V is to be computed."]
pub const Eigen_DecompositionOptions_ComputeThinV: Eigen_DecompositionOptions = 32;
#[doc = " Used in SelfAdjointEigenSolver and GeneralizedSelfAdjointEigenSolver to specify\n that only the eigenvalues are to be computed and not the eigenvectors."]
pub const Eigen_DecompositionOptions_EigenvaluesOnly: Eigen_DecompositionOptions = 64;
#[doc = " Used in SelfAdjointEigenSolver and GeneralizedSelfAdjointEigenSolver to specify\n that both the eigenvalues and the eigenvectors are to be computed."]
pub const Eigen_DecompositionOptions_ComputeEigenvectors: Eigen_DecompositionOptions = 128;
#[doc = " \\internal"]
pub const Eigen_DecompositionOptions_EigVecMask: Eigen_DecompositionOptions = 192;
#[doc = " Used in GeneralizedSelfAdjointEigenSolver to indicate that it should\n solve the generalized eigenproblem \\f$ Ax = \\lambda B x \\f$."]
pub const Eigen_DecompositionOptions_Ax_lBx: Eigen_DecompositionOptions = 256;
#[doc = " Used in GeneralizedSelfAdjointEigenSolver to indicate that it should\n solve the generalized eigenproblem \\f$ ABx = \\lambda x \\f$."]
pub const Eigen_DecompositionOptions_ABx_lx: Eigen_DecompositionOptions = 512;
#[doc = " Used in GeneralizedSelfAdjointEigenSolver to indicate that it should\n solve the generalized eigenproblem \\f$ BAx = \\lambda x \\f$."]
pub const Eigen_DecompositionOptions_BAx_lx: Eigen_DecompositionOptions = 1024;
#[doc = " \\internal"]
pub const Eigen_DecompositionOptions_GenEigMask: Eigen_DecompositionOptions = 1792;
#[doc = " \\ingroup enums\n Enum with options to give to various decompositions."]
pub type Eigen_DecompositionOptions = ::std::os::raw::c_uint;
#[doc = " Do not specify what is to be done if the SVD of a non-square matrix is asked for."]
pub const Eigen_QRPreconditioners_NoQRPreconditioner: Eigen_QRPreconditioners = 0;
#[doc = " Use a QR decomposition without pivoting as the first step."]
pub const Eigen_QRPreconditioners_HouseholderQRPreconditioner: Eigen_QRPreconditioners = 1;
#[doc = " Use a QR decomposition with column pivoting as the first step."]
pub const Eigen_QRPreconditioners_ColPivHouseholderQRPreconditioner: Eigen_QRPreconditioners = 2;
#[doc = " Use a QR decomposition with full pivoting as the first step."]
pub const Eigen_QRPreconditioners_FullPivHouseholderQRPreconditioner: Eigen_QRPreconditioners = 3;
#[doc = " \\ingroup enums\n Possible values for the \\p QRPreconditioner template parameter of JacobiSVD."]
pub type Eigen_QRPreconditioners = ::std::os::raw::c_uint;
#[doc = " Computation was successful."]
pub const Eigen_ComputationInfo_Success: Eigen_ComputationInfo = 0;
#[doc = " The provided data did not satisfy the prerequisites."]
pub const Eigen_ComputationInfo_NumericalIssue: Eigen_ComputationInfo = 1;
#[doc = " Iterative procedure did not converge."]
pub const Eigen_ComputationInfo_NoConvergence: Eigen_ComputationInfo = 2;
#[doc = " The inputs are invalid, or the algorithm has been improperly called.\n When assertions are enabled, such errors trigger an assert."]
pub const Eigen_ComputationInfo_InvalidInput: Eigen_ComputationInfo = 3;
#[doc = " \\ingroup enums\n Enum for reporting the status of a computation."]
pub type Eigen_ComputationInfo = ::std::os::raw::c_uint;
#[doc = " Transformation is an isometry."]
pub const Eigen_TransformTraits_Isometry: Eigen_TransformTraits = 1;
#[doc = " Transformation is an affine transformation stored as a (Dim+1)^2 matrix whose last row is\n assumed to be [0 ... 0 1]."]
pub const Eigen_TransformTraits_Affine: Eigen_TransformTraits = 2;
#[doc = " Transformation is an affine transformation stored as a (Dim) x (Dim+1) matrix."]
pub const Eigen_TransformTraits_AffineCompact: Eigen_TransformTraits = 18;
#[doc = " Transformation is a general projective transformation stored as a (Dim+1)^2 matrix."]
pub const Eigen_TransformTraits_Projective: Eigen_TransformTraits = 32;
#[doc = " \\ingroup enums\n Enum used to specify how a particular transformation is stored in a matrix.\n \\sa Transform, Hyperplane::transform()."]
pub type Eigen_TransformTraits = ::std::os::raw::c_uint;
pub const Eigen_Architecture_Type_Generic: Eigen_Architecture_Type = 0;
pub const Eigen_Architecture_Type_SSE: Eigen_Architecture_Type = 1;
pub const Eigen_Architecture_Type_AltiVec: Eigen_Architecture_Type = 2;
pub const Eigen_Architecture_Type_VSX: Eigen_Architecture_Type = 3;
pub const Eigen_Architecture_Type_NEON: Eigen_Architecture_Type = 4;
pub const Eigen_Architecture_Type_Target: Eigen_Architecture_Type = 1;
pub type Eigen_Architecture_Type = ::std::os::raw::c_uint;
pub const Eigen_ProductImplType_DefaultProduct: Eigen_ProductImplType = 0;
pub const Eigen_ProductImplType_LazyProduct: Eigen_ProductImplType = 1;
pub const Eigen_ProductImplType_AliasFreeProduct: Eigen_ProductImplType = 2;
pub const Eigen_ProductImplType_CoeffBasedProductMode: Eigen_ProductImplType = 3;
pub const Eigen_ProductImplType_LazyCoeffBasedProductMode: Eigen_ProductImplType = 4;
pub const Eigen_ProductImplType_OuterProduct: Eigen_ProductImplType = 5;
pub const Eigen_ProductImplType_InnerProduct: Eigen_ProductImplType = 6;
pub const Eigen_ProductImplType_GemvProduct: Eigen_ProductImplType = 7;
pub const Eigen_ProductImplType_GemmProduct: Eigen_ProductImplType = 8;
#[doc = " \\internal \\ingroup enums\n Enum used as template parameter in Product and product evaluators."]
pub type Eigen_ProductImplType = ::std::os::raw::c_uint;
pub const Eigen_Action_GetAction: Eigen_Action = 0;
pub const Eigen_Action_SetAction: Eigen_Action = 1;
#[doc = " \\internal \\ingroup enums\n Enum used in experimental parallel implementation."]
pub type Eigen_Action = ::std::os::raw::c_uint;
#[doc = " The type used to identify a dense storage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Dense {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_Dense() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_Dense>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_Dense))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_Dense>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_Dense))
    );
}
#[doc = " The type used to identify a general sparse storage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Sparse {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_Sparse() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_Sparse>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_Sparse))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_Sparse>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_Sparse))
    );
}
#[doc = " The type used to identify a general solver (factored) storage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SolverStorage {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_SolverStorage() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_SolverStorage>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_SolverStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_SolverStorage>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_SolverStorage))
    );
}
#[doc = " The type used to identify a permutation storage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PermutationStorage {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_PermutationStorage() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_PermutationStorage>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_PermutationStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_PermutationStorage>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_PermutationStorage))
    );
}
#[doc = " The type used to identify a permutation storage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TranspositionsStorage {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_TranspositionsStorage() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_TranspositionsStorage>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_TranspositionsStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_TranspositionsStorage>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_TranspositionsStorage))
    );
}
#[doc = " The type used to identify a matrix expression"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixXpr {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_MatrixXpr() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_MatrixXpr>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_MatrixXpr))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_MatrixXpr>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_MatrixXpr))
    );
}
#[doc = " The type used to identify an array expression"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_ArrayXpr {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_ArrayXpr() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_ArrayXpr>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_ArrayXpr))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_ArrayXpr>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_ArrayXpr))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_DenseShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_DenseShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_DenseShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_DenseShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_DenseShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_DenseShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SolverShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_SolverShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_SolverShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_SolverShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_SolverShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_SolverShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_HomogeneousShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_HomogeneousShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_HomogeneousShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_HomogeneousShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_HomogeneousShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_HomogeneousShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_DiagonalShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_DiagonalShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_DiagonalShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_DiagonalShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_DiagonalShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_DiagonalShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_BandShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_BandShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_BandShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_BandShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_BandShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_BandShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TriangularShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_TriangularShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_TriangularShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_TriangularShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_TriangularShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_TriangularShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SelfAdjointShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_SelfAdjointShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_SelfAdjointShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_SelfAdjointShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_SelfAdjointShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_SelfAdjointShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PermutationShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_PermutationShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_PermutationShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_PermutationShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_PermutationShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_PermutationShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TranspositionsShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_TranspositionsShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_TranspositionsShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_TranspositionsShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_TranspositionsShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_TranspositionsShape))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SparseShape {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Eigen_SparseShape() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_SparseShape>(),
        1usize,
        concat!("Size of: ", stringify!(Eigen_SparseShape))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_SparseShape>(),
        1usize,
        concat!("Alignment of ", stringify!(Eigen_SparseShape))
    );
}
pub type Eigen_DenseIndex = isize;
#[doc = " \\brief The Index type as used for the API.\n \\details To change this, \\c \\#define the preprocessor symbol \\c EIGEN_DEFAULT_DENSE_INDEX_TYPE.\n \\sa \\blank \\ref TopicPreprocessorDirectives, StorageIndex."]
pub type Eigen_Index = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_ForceAlignedAccess {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SwapWrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Conjugate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SparseView {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_LazyProductReturnType {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Cross {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SparseMatrixBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixExponentialReturnValue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixFunctionReturnValue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixSquareRootReturnValue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixLogarithmReturnValue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixPowerReturnValue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixComplexPowerReturnValue {
    pub _address: u8,
}
#[doc = " \\class ScalarBinaryOpTraits\n \\ingroup Core_Module\n\n \\brief Determines whether the given binary operation of two numeric types is allowed and what the scalar return type is.\n\n This class permits to control the scalar return type of any binary operation performed on two different scalar types through (partial) template specializations.\n\n For instance, let \\c U1, \\c U2 and \\c U3 be three user defined scalar types for which most operations between instances of \\c U1 and \\c U2 returns an \\c U3.\n You can let %Eigen knows that by defining:\n\\code\ntemplate<typename BinaryOp>\nstruct ScalarBinaryOpTraits<U1,U2,BinaryOp> { typedef U3 ReturnType;  };\ntemplate<typename BinaryOp>\nstruct ScalarBinaryOpTraits<U2,U1,BinaryOp> { typedef U3 ReturnType;  };\n\\endcode\n You can then explicitly disable some particular operations to get more explicit error messages:\n\\code\ntemplate<>\nstruct ScalarBinaryOpTraits<U1,U2,internal::scalar_max_op<U1,U2> > {};\n\\endcode\n Or customize the return type for individual operation:\n\\code\ntemplate<>\nstruct ScalarBinaryOpTraits<U1,U2,internal::scalar_sum_op<U1,U2> > { typedef U1 ReturnType; };\n\\endcode\n\n By default, the following generic combinations are supported:\n<table class=\"manual\">\n<tr><th>ScalarA</th><th>ScalarB</th><th>BinaryOp</th><th>ReturnType</th><th>Note</th></tr>\n<tr            ><td>\\c T </td><td>\\c T </td><td>\\c * </td><td>\\c T </td><td></td></tr>\n<tr class=\"alt\"><td>\\c NumTraits<T>::Real </td><td>\\c T </td><td>\\c * </td><td>\\c T </td><td>Only if \\c NumTraits<T>::IsComplex </td></tr>\n<tr            ><td>\\c T </td><td>\\c NumTraits<T>::Real </td><td>\\c * </td><td>\\c T </td><td>Only if \\c NumTraits<T>::IsComplex </td></tr>\n</table>\n\n \\sa CwiseBinaryOp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_ScalarBinaryOpTraits {
    pub _address: u8,
}
#[doc = " \\class aligned_allocator\n \\ingroup Core_Module\n\n \\brief STL compatible allocator to use with types requiring a non standrad alignment.\n\n The memory is aligned as for dynamically aligned matrix/array types such as MatrixXd.\n By default, it will thus provide at least 16 bytes alignment and more in following cases:\n  - 32 bytes alignment if AVX is enabled.\n  - 64 bytes alignment if AVX512 is enabled.\n\n This can be controled using the \\c EIGEN_MAX_ALIGN_BYTES macro as documented\n \\link TopicPreprocessorDirectivesPerformance there \\endlink.\n\n Example:\n \\code\n // Matrix4f requires 16 bytes alignment:\n std::map< int, Matrix4f, std::less<int>,\n           aligned_allocator<std::pair<const int, Matrix4f> > > my_map_mat4;\n // Vector3f does not require 16 bytes alignment, no need to use Eigen's allocator:\n std::map< int, Vector3f > my_map_vec3;\n \\endcode\n\n \\sa \\blank \\ref TopicStlContainers."]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_aligned_allocator {
    pub _address: u8,
}
pub type Eigen_aligned_allocator_size_type = usize;
pub type Eigen_aligned_allocator_difference_type = isize;
pub type Eigen_aligned_allocator_pointer<T> = *mut T;
pub type Eigen_aligned_allocator_const_pointer<T> = *const T;
pub type Eigen_aligned_allocator_reference<T> = *mut T;
pub type Eigen_aligned_allocator_const_reference<T> = *const T;
pub type Eigen_aligned_allocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_aligned_allocator_rebind {
    pub _address: u8,
}
#[doc = " \\class NumTraits\n \\ingroup Core_Module\n\n \\brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.\n\n \\tparam T the numeric type at hand\n\n This class stores enums, typedefs and static methods giving information about a numeric type.\n\n The provided data consists of:\n \\li A typedef \\c Real, giving the \"real part\" type of \\a T. If \\a T is already real,\n     then \\c Real is just a typedef to \\a T. If \\a T is \\c std::complex<U> then \\c Real\n     is a typedef to \\a U.\n \\li A typedef \\c NonInteger, giving the type that should be used for operations producing non-integral values,\n     such as quotients, square roots, etc. If \\a T is a floating-point type, then this typedef just gives\n     \\a T again. Note however that many Eigen functions such as internal::sqrt simply refuse to\n     take integers. Outside of a few cases, Eigen doesn't do automatic type promotion. Thus, this typedef is\n     only intended as a helper for code that needs to explicitly promote types.\n \\li A typedef \\c Literal giving the type to use for numeric literals such as \"2\" or \"0.5\". For instance, for \\c std::complex<U>, Literal is defined as \\c U.\n     Of course, this type must be fully compatible with \\a T. In doubt, just use \\a T here.\n \\li A typedef \\a Nested giving the type to use to nest a value inside of the expression tree. If you don't know what\n     this means, just use \\a T here.\n \\li An enum value \\a IsComplex. It is equal to 1 if \\a T is a \\c std::complex\n     type, and to 0 otherwise.\n \\li An enum value \\a IsInteger. It is equal to \\c 1 if \\a T is an integer type such as \\c int,\n     and to \\c 0 otherwise.\n \\li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed\n     to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.\n     Stay vague here. No need to do architecture-specific stuff.\n \\li An enum value \\a IsSigned. It is equal to \\c 1 if \\a T is a signed type and to 0 if \\a T is unsigned.\n \\li An enum value \\a RequireInitialization. It is equal to \\c 1 if the constructor of the numeric type \\a T must\n     be called, and to 0 if it is safe not to call it. Default is 0 if \\a T is an arithmetic type, and 1 otherwise.\n \\li An epsilon() function which, unlike <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon\">std::numeric_limits::epsilon()</a>,\n     it returns a \\a Real instead of a \\a T.\n \\li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default\n     value by the fuzzy comparison operators.\n \\li highest() and lowest() functions returning the highest and lowest possible values respectively.\n \\li digits10() function returning the number of decimal digits that can be represented without change. This is\n     the analogue of <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits10\">std::numeric_limits<T>::digits10</a>\n     which is used as the default implementation if specialized."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_GenericNumTraits {
    pub _address: u8,
}
pub const Eigen_GenericNumTraits_IsInteger: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_IsSigned: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_IsComplex: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_RequireInitialization: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_ReadCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_AddCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_MulCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub type Eigen_GenericNumTraits__bindgen_ty_1 = i32;
pub type Eigen_GenericNumTraits_Real<T> = T;
pub type Eigen_GenericNumTraits_NonInteger = u8;
pub type Eigen_GenericNumTraits_Nested<T> = T;
pub type Eigen_GenericNumTraits_Literal<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_NumTraits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_half_impl___half_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_Eigen_half_impl___half_raw() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_half_impl___half_raw> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_half_impl___half_raw>(),
        2usize,
        concat!("Size of: ", stringify!(Eigen_half_impl___half_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_half_impl___half_raw>(),
        2usize,
        concat!("Alignment of ", stringify!(Eigen_half_impl___half_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_half_impl___half_raw),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_half_impl_half_base {
    pub _base: Eigen_half_impl___half_raw,
}
#[test]
fn bindgen_test_layout_Eigen_half_impl_half_base() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_half_impl_half_base>(),
        2usize,
        concat!("Size of: ", stringify!(Eigen_half_impl_half_base))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_half_impl_half_base>(),
        2usize,
        concat!("Alignment of ", stringify!(Eigen_half_impl_half_base))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Eigen_half_impl_float32_bits {
    pub u: ::std::os::raw::c_uint,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_Eigen_half_impl_float32_bits() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_half_impl_float32_bits> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_half_impl_float32_bits>(),
        4usize,
        concat!("Size of: ", stringify!(Eigen_half_impl_float32_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_half_impl_float32_bits>(),
        4usize,
        concat!("Alignment of ", stringify!(Eigen_half_impl_float32_bits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_half_impl_float32_bits),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_half_impl_float32_bits),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_half {
    pub _base: Eigen_half_impl_half_base,
}
pub type Eigen_half___half_raw = Eigen_half_impl___half_raw;
#[test]
fn bindgen_test_layout_Eigen_half() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_half>(),
        2usize,
        concat!("Size of: ", stringify!(Eigen_half))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_half>(),
        2usize,
        concat!("Alignment of ", stringify!(Eigen_half))
    );
}
#[test]
fn __bindgen_test_layout_Eigen_NumTraits_open0_Eigen_half_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_NumTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_NumTraits)
        )
    );
}
pub const DontAlignCols: Eigen__bindgen_ty_1 = 1;
pub type Eigen__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const StreamPrecision: Eigen__bindgen_ty_2 = -1;
pub const FullPrecision: Eigen__bindgen_ty_2 = -2;
pub type Eigen__bindgen_ty_2 = ::std::os::raw::c_int;
#[doc = " \\class IOFormat\n \\ingroup Core_Module\n\n \\brief Stores a set of parameters controlling the way matrices are printed\n\n List of available parameters:\n  - \\b precision number of digits for floating point values, or one of the special constants \\c StreamPrecision and \\c FullPrecision.\n                 The default is the special value \\c StreamPrecision which means to use the\n                 stream's own precision setting, as set for instance using \\c cout.precision(3). The other special value\n                 \\c FullPrecision means that the number of digits will be computed to match the full precision of each floating-point\n                 type.\n  - \\b flags an OR-ed combination of flags, the default value is 0, the only currently available flag is \\c DontAlignCols which\n             allows to disable the alignment of columns, resulting in faster code.\n  - \\b coeffSeparator string printed between two coefficients of the same row\n  - \\b rowSeparator string printed between two rows\n  - \\b rowPrefix string printed at the beginning of each row\n  - \\b rowSuffix string printed at the end of each row\n  - \\b matPrefix string printed at the beginning of the matrix\n  - \\b matSuffix string printed at the end of the matrix\n\n Example: \\include IOFormat.cpp\n Output: \\verbinclude IOFormat.out\n\n \\sa DenseBase::format(), class WithFormat"]
#[repr(C)]
pub struct Eigen_IOFormat {
    pub matPrefix: std_string,
    pub matSuffix: std_string,
    pub rowPrefix: std_string,
    pub rowSuffix: std_string,
    pub rowSeparator: std_string,
    pub rowSpacer: std_string,
    pub coeffSeparator: std_string,
    pub precision: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Eigen_IOFormat() {
    const UNINIT: ::std::mem::MaybeUninit<Eigen_IOFormat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Eigen_IOFormat>(),
        232usize,
        concat!("Size of: ", stringify!(Eigen_IOFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_IOFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(Eigen_IOFormat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matPrefix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(matPrefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matSuffix) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(matSuffix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowPrefix) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(rowPrefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowSuffix) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(rowSuffix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowSeparator) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(rowSeparator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowSpacer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(rowSpacer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeffSeparator) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(coeffSeparator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(Eigen_IOFormat),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " \\class WithFormat\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing matrix output with given format\n\n \\tparam ExpressionType the type of the object on which IO stream operations are performed\n\n This class represents an expression with stream operators controlled by a given IOFormat.\n It is the return type of DenseBase::format()\n and most of the time this is the only way it is used.\n\n See class IOFormat for some examples.\n\n \\sa DenseBase::format(), class IOFormat"]
#[repr(C)]
pub struct Eigen_WithFormat {
    pub m_matrix: [u8; 0usize],
    pub m_format: Eigen_IOFormat,
}
#[doc = " \\class DenseBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and arrays\n\n This class is the base that is inherited by all dense objects (matrix, vector, arrays,\n and related expression types). The common Eigen API for dense objects is contained in this class.\n\n \\tparam Derived is the derived type, e.g., a matrix type or an expression.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_DENSEBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_DenseBase {
    pub _address: u8,
}
#[doc = " Inner iterator type to iterate over the coefficients of a row or column.\n \\sa class InnerIterator"]
pub type Eigen_DenseBase_InnerIterator = Eigen_InnerIterator;
pub type Eigen_DenseBase_StorageKind = Eigen_internal_traits;
#[doc = " \\brief The type used to store indices\n \\details This typedef is relevant for types that store multiple indices such as\n          PermutationMatrix or Transpositions, otherwise it defaults to Eigen::Index\n \\sa \\blank \\ref TopicPreprocessorDirectives, Eigen::Index, SparseMatrixBase."]
pub type Eigen_DenseBase_StorageIndex = Eigen_internal_traits;
#[doc = " The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc."]
pub type Eigen_DenseBase_Scalar = Eigen_internal_traits;
#[doc = " The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc.\n\n It is an alias for the Scalar type"]
pub type Eigen_DenseBase_value_type = Eigen_DenseBase_Scalar;
pub type Eigen_DenseBase_RealScalar = Eigen_NumTraits;
pub type Eigen_DenseBase_Base = u8;
pub type Eigen_DenseBase_CoeffReturnType = Eigen_DenseBase_Base;
pub const Eigen_DenseBase_RowsAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_ColsAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_SizeAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_MaxRowsAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_MaxColsAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_MaxSizeAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_IsVectorAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_Flags: Eigen_DenseBase__bindgen_ty_1 = 0;
#[doc = "< True if this expression has row-major storage order."]
pub const Eigen_DenseBase_IsRowMajor: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_InnerSizeAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_InnerStrideAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub const Eigen_DenseBase_OuterStrideAtCompileTime: Eigen_DenseBase__bindgen_ty_1 = 0;
pub type Eigen_DenseBase__bindgen_ty_1 = i32;
pub type Eigen_DenseBase_PacketScalar = u8;
pub const Eigen_DenseBase_IsPlainObjectBase: Eigen_DenseBase__bindgen_ty_2 = 0;
pub type Eigen_DenseBase__bindgen_ty_2 = i32;
#[doc = " The plain matrix type corresponding to this expression.\n \\sa PlainObject"]
pub type Eigen_DenseBase_PlainMatrix = u8;
#[doc = " The plain array type corresponding to this expression.\n \\sa PlainObject"]
pub type Eigen_DenseBase_PlainArray = u8;
#[doc = " \\brief The plain matrix or array type corresponding to this expression.\n\n This is not necessarily exactly the return type of eval(). In the case of plain matrices,\n the return type of eval() is a const reference to a matrix, not a matrix! It is however guaranteed\n that the return type of eval() is either PlainObject or const PlainObject&."]
pub type Eigen_DenseBase_PlainObject = u8;
#[doc = " \\internal Represents a matrix with all coefficients equal to one another"]
pub type Eigen_DenseBase_ConstantReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal \\deprecated Represents a vector with linearly spaced coefficients that allows sequential access only."]
pub type Eigen_DenseBase_SequentialLinSpacedReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal Represents a vector with linearly spaced coefficients that allows random access."]
pub type Eigen_DenseBase_RandomAccessLinSpacedReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal the return type of MatrixBase::eigenvalues()"]
pub type Eigen_DenseBase_EigenvaluesReturnType = u8;
#[doc = " \\class Transpose\n \\ingroup Core_Module\n\n \\brief Expression of the transpose of a matrix\n\n \\tparam MatrixType the type of the object of which we are taking the transpose\n\n This class represents an expression of the transpose of a matrix.\n It is the return type of MatrixBase::transpose() and MatrixBase::adjoint()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::transpose(), MatrixBase::adjoint()"]
pub type Eigen_DenseBase_TransposeReturnType = Eigen_Transpose;
pub type Eigen_DenseBase_ConstTransposeReturnType = Eigen_internal_add_const;
pub type Eigen_DenseBase_EvalReturnType = Eigen_internal_add_const_on_value_type;
#[doc = " \\class VectorwiseOp\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing partial reduction operations\n\n \\tparam ExpressionType the type of the object on which to do partial reductions\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents a pseudo expression with partial reduction features.\n It is the return type of DenseBase::colwise() and DenseBase::rowwise()\n and most of the time this is the only way it is used.\n\n Example: \\include MatrixBase_colwise.cpp\n Output: \\verbinclude MatrixBase_colwise.out\n\n \\sa DenseBase::colwise(), DenseBase::rowwise(), class PartialReduxExpr"]
pub type Eigen_DenseBase_RowwiseReturnType = u8;
#[doc = " \\class VectorwiseOp\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing partial reduction operations\n\n \\tparam ExpressionType the type of the object on which to do partial reductions\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents a pseudo expression with partial reduction features.\n It is the return type of DenseBase::colwise() and DenseBase::rowwise()\n and most of the time this is the only way it is used.\n\n Example: \\include MatrixBase_colwise.cpp\n Output: \\verbinclude MatrixBase_colwise.out\n\n \\sa DenseBase::colwise(), DenseBase::rowwise(), class PartialReduxExpr"]
pub type Eigen_DenseBase_ConstRowwiseReturnType = u8;
#[doc = " \\class VectorwiseOp\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing partial reduction operations\n\n \\tparam ExpressionType the type of the object on which to do partial reductions\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents a pseudo expression with partial reduction features.\n It is the return type of DenseBase::colwise() and DenseBase::rowwise()\n and most of the time this is the only way it is used.\n\n Example: \\include MatrixBase_colwise.cpp\n Output: \\verbinclude MatrixBase_colwise.out\n\n \\sa DenseBase::colwise(), DenseBase::rowwise(), class PartialReduxExpr"]
pub type Eigen_DenseBase_ColwiseReturnType = u8;
#[doc = " \\class VectorwiseOp\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing partial reduction operations\n\n \\tparam ExpressionType the type of the object on which to do partial reductions\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents a pseudo expression with partial reduction features.\n It is the return type of DenseBase::colwise() and DenseBase::rowwise()\n and most of the time this is the only way it is used.\n\n Example: \\include MatrixBase_colwise.cpp\n Output: \\verbinclude MatrixBase_colwise.out\n\n \\sa DenseBase::colwise(), DenseBase::rowwise(), class PartialReduxExpr"]
pub type Eigen_DenseBase_ConstColwiseReturnType = u8;
#[doc = " \\class CwiseNullaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression of a matrix where all coefficients are defined by a functor\n\n \\tparam NullaryOp template functor implementing the operator\n \\tparam PlainObjectType the underlying plain matrix/array type\n\n This class represents an expression of a generic nullary operator.\n It is the return type of the Ones(), Zero(), Constant(), Identity() and Random() methods,\n and most of the time this is the only way it is used.\n\n However, if you want to write a function returning such an expression, you\n will need to use this class.\n\n The functor NullaryOp must expose one of the following method:\n<table class=\"manual\">\n<tr            ><td>\\c operator()() </td><td>if the procedural generation does not depend on the coefficient entries (e.g., random numbers)</td></tr>\n<tr class=\"alt\"><td>\\c operator()(Index i)</td><td>if the procedural generation makes sense for vectors only and that it depends on the coefficient index \\c i (e.g., linspace) </td></tr>\n<tr            ><td>\\c operator()(Index i,Index j)</td><td>if the procedural generation depends on the matrix coordinates \\c i, \\c j (e.g., to generate a checkerboard with 0 and 1)</td></tr>\n</table>\n It is also possible to expose the last two operators if the generation makes sense for matrices but can be optimized for vectors.\n\n See DenseBase::NullaryExpr(Index,const CustomNullaryOp&) for an example binding\n C++11 random number generators.\n\n A nullary expression can also be used to implement custom sophisticated matrix manipulations\n that cannot be covered by the existing set of natively supported matrix manipulations.\n See this \\ref TopicCustomizing_NullaryExpr \"page\" for some examples and additional explanations\n on the behavior of CwiseNullaryOp.\n\n \\sa class CwiseUnaryOp, class CwiseBinaryOp, DenseBase::NullaryExpr"]
pub type Eigen_DenseBase_RandomReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\class Reverse\n \\ingroup Core_Module\n\n \\brief Expression of the reverse of a vector or matrix\n\n \\tparam MatrixType the type of the object of which we are taking the reverse\n \\tparam Direction defines the direction of the reverse operation, can be Vertical, Horizontal, or BothDirections\n\n This class represents an expression of the reverse of a vector.\n It is the return type of MatrixBase::reverse() and VectorwiseOp::reverse()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::reverse(), VectorwiseOp::reverse()"]
pub type Eigen_DenseBase_ReverseReturnType = u8;
#[doc = " \\class Reverse\n \\ingroup Core_Module\n\n \\brief Expression of the reverse of a vector or matrix\n\n \\tparam MatrixType the type of the object of which we are taking the reverse\n \\tparam Direction defines the direction of the reverse operation, can be Vertical, Horizontal, or BothDirections\n\n This class represents an expression of the reverse of a vector.\n It is the return type of MatrixBase::reverse() and VectorwiseOp::reverse()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::reverse(), VectorwiseOp::reverse()"]
pub type Eigen_DenseBase_ConstReverseReturnType = u8;
#[doc = " \\internal expression type of a column */"]
pub type Eigen_DenseBase_ColXpr = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstColXpr = u8;
#[doc = " \\internal expression type of a row */"]
pub type Eigen_DenseBase_RowXpr = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstRowXpr = u8;
#[doc = " \\internal expression type of a block of whole columns */"]
pub type Eigen_DenseBase_ColsBlockXpr = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstColsBlockXpr = u8;
#[doc = " \\internal expression type of a block of whole rows */"]
pub type Eigen_DenseBase_RowsBlockXpr = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstRowsBlockXpr = u8;
#[doc = " \\internal expression of a block */"]
pub type Eigen_DenseBase_BlockXpr = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstBlockXpr = u8;
#[doc = " \\class VectorBlock\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size sub-vector\n\n \\tparam VectorType the type of the object in which we are taking a sub-vector\n \\tparam Size size of the sub-vector we are taking at compile time (optional)\n\n This class represents an expression of either a fixed-size or dynamic-size sub-vector.\n It is the return type of DenseBase::segment(Index,Index) and DenseBase::segment<int>(Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate sub-vector expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_VectorBlock.cpp\n Output: \\verbinclude class_VectorBlock.out\n\n \\note Even though this expression has dynamic size, in the case where \\a VectorType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedVectorBlock.cpp\n Output: \\verbinclude class_FixedVectorBlock.out\n\n \\sa class Block, DenseBase::segment(Index,Index,Index,Index), DenseBase::segment(Index,Index)"]
pub type Eigen_DenseBase_SegmentReturnType = u8;
#[doc = " \\class VectorBlock\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size sub-vector\n\n \\tparam VectorType the type of the object in which we are taking a sub-vector\n \\tparam Size size of the sub-vector we are taking at compile time (optional)\n\n This class represents an expression of either a fixed-size or dynamic-size sub-vector.\n It is the return type of DenseBase::segment(Index,Index) and DenseBase::segment<int>(Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate sub-vector expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_VectorBlock.cpp\n Output: \\verbinclude class_VectorBlock.out\n\n \\note Even though this expression has dynamic size, in the case where \\a VectorType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedVectorBlock.cpp\n Output: \\verbinclude class_FixedVectorBlock.out\n\n \\sa class Block, DenseBase::segment(Index,Index,Index,Index), DenseBase::segment(Index,Index)"]
pub type Eigen_DenseBase_ConstSegmentReturnType = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_NColsBlockXpr_Type = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstNColsBlockXpr_Type = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_NRowsBlockXpr_Type = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstNRowsBlockXpr_Type = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_FixedBlockXpr_Type = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_DenseBase_ConstFixedBlockXpr_Type = u8;
#[doc = " \\class VectorBlock\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size sub-vector\n\n \\tparam VectorType the type of the object in which we are taking a sub-vector\n \\tparam Size size of the sub-vector we are taking at compile time (optional)\n\n This class represents an expression of either a fixed-size or dynamic-size sub-vector.\n It is the return type of DenseBase::segment(Index,Index) and DenseBase::segment<int>(Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate sub-vector expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_VectorBlock.cpp\n Output: \\verbinclude class_VectorBlock.out\n\n \\note Even though this expression has dynamic size, in the case where \\a VectorType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedVectorBlock.cpp\n Output: \\verbinclude class_FixedVectorBlock.out\n\n \\sa class Block, DenseBase::segment(Index,Index,Index,Index), DenseBase::segment(Index,Index)"]
pub type Eigen_DenseBase_FixedSegmentReturnType_Type = u8;
#[doc = " \\class VectorBlock\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size sub-vector\n\n \\tparam VectorType the type of the object in which we are taking a sub-vector\n \\tparam Size size of the sub-vector we are taking at compile time (optional)\n\n This class represents an expression of either a fixed-size or dynamic-size sub-vector.\n It is the return type of DenseBase::segment(Index,Index) and DenseBase::segment<int>(Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate sub-vector expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_VectorBlock.cpp\n Output: \\verbinclude class_VectorBlock.out\n\n \\note Even though this expression has dynamic size, in the case where \\a VectorType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedVectorBlock.cpp\n Output: \\verbinclude class_FixedVectorBlock.out\n\n \\sa class Block, DenseBase::segment(Index,Index,Index,Index), DenseBase::segment(Index,Index)"]
pub type Eigen_DenseBase_ConstFixedSegmentReturnType_Type = u8;
#[doc = " \\class MatrixBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and expressions\n\n This class is the base that is inherited by all matrix, vector, and related expression\n types. Most of the Eigen API is contained in this class, and its base classes. Other important\n classes for the Eigen API are Matrix, and VectorwiseOp.\n\n Note that some methods are defined in other modules such as the \\ref LU_Module LU module\n for all functions related to matrix inversions.\n\n \\tparam Derived is the derived type, e.g. a matrix type, or an expression, etc.\n\n When writing a function taking Eigen objects as argument, if you want your function\n to take as argument any matrix, vector, or expression, just let it take a\n MatrixBase argument. As an example, here is a function printFirstRow which, given\n a matrix, vector, or expression \\a x, prints the first row of \\a x.\n\n \\code\ntemplate<typename Derived>\nvoid printFirstRow(const Eigen::MatrixBase<Derived>& x)\n{\ncout << x.row(0) << endl;\n}\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIXBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_MatrixBase {
    pub _address: u8,
}
#[doc = " \\class MatrixBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and expressions\n\n This class is the base that is inherited by all matrix, vector, and related expression\n types. Most of the Eigen API is contained in this class, and its base classes. Other important\n classes for the Eigen API are Matrix, and VectorwiseOp.\n\n Note that some methods are defined in other modules such as the \\ref LU_Module LU module\n for all functions related to matrix inversions.\n\n \\tparam Derived is the derived type, e.g. a matrix type, or an expression, etc.\n\n When writing a function taking Eigen objects as argument, if you want your function\n to take as argument any matrix, vector, or expression, just let it take a\n MatrixBase argument. As an example, here is a function printFirstRow which, given\n a matrix, vector, or expression \\a x, prints the first row of \\a x.\n\n \\code\ntemplate<typename Derived>\nvoid printFirstRow(const Eigen::MatrixBase<Derived>& x)\n{\ncout << x.row(0) << endl;\n}\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIXBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_MatrixBase_StorageBaseType = Eigen_MatrixBase;
pub type Eigen_MatrixBase_StorageKind = Eigen_internal_traits;
pub type Eigen_MatrixBase_StorageIndex = Eigen_internal_traits;
pub type Eigen_MatrixBase_Scalar = Eigen_internal_traits;
pub type Eigen_MatrixBase_PacketScalar = Eigen_internal_packet_traits;
pub type Eigen_MatrixBase_RealScalar = Eigen_NumTraits;
#[doc = " \\class DenseBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and arrays\n\n This class is the base that is inherited by all dense objects (matrix, vector, arrays,\n and related expression types). The common Eigen API for dense objects is contained in this class.\n\n \\tparam Derived is the derived type, e.g., a matrix type or an expression.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_DENSEBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_MatrixBase_Base = Eigen_DenseBase;
pub type Eigen_MatrixBase_CoeffReturnType = Eigen_MatrixBase_Base;
pub type Eigen_MatrixBase_ConstTransposeReturnType = Eigen_MatrixBase_Base;
pub type Eigen_MatrixBase_RowXpr = Eigen_MatrixBase_Base;
pub type Eigen_MatrixBase_ColXpr = Eigen_MatrixBase_Base;
#[doc = " type of the equivalent square matrix"]
pub type Eigen_MatrixBase_SquareMatrixType = u8;
pub type Eigen_MatrixBase_PlainObject = Eigen_MatrixBase_Base;
#[doc = " \\internal Represents a matrix with all coefficients equal to one another"]
pub type Eigen_MatrixBase_ConstantReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal the return type of MatrixBase::adjoint()"]
pub type Eigen_MatrixBase_AdjointReturnType = u8;
#[doc = " \\internal Return type of eigenvalues()"]
pub type Eigen_MatrixBase_EigenvaluesReturnType = u8;
#[doc = " \\internal the return type of identity"]
pub type Eigen_MatrixBase_IdentityReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal the return type of unit vectors"]
pub type Eigen_MatrixBase_BasisReturnType = u8;
#[doc = " \\internal the return type of conjugate()"]
pub type Eigen_MatrixBase_ConjugateReturnType = u8;
#[doc = " \\internal the return type of real() const"]
pub type Eigen_MatrixBase_RealReturnType = u8;
#[doc = " \\internal the return type of real()"]
pub type Eigen_MatrixBase_NonConstRealReturnType = u8;
#[doc = " \\internal the return type of imag() const"]
pub type Eigen_MatrixBase_ImagReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\internal the return type of imag()"]
pub type Eigen_MatrixBase_NonConstImagReturnType = Eigen_CwiseUnaryView<ViewOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_NegativeReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixBase_CastXpr {
    pub _address: u8,
}
pub type Eigen_MatrixBase_CastXpr_Type = Eigen_internal_cast_return_type;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseAbsReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseAbs2ReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseSqrtReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseSignReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseInverseReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_CwiseScalarEqualReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
pub type Eigen_MatrixBase_DiagonalReturnType = u8;
pub type Eigen_MatrixBase_ConstDiagonalReturnType = Eigen_internal_add_const;
pub type Eigen_MatrixBase_DiagonalDynamicIndexReturnType = u8;
pub type Eigen_MatrixBase_ConstDiagonalDynamicIndexReturnType = Eigen_internal_add_const;
#[doc = " \\internal helper struct to form the return type of the cross product"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_MatrixBase_cross_product_return_type {
    pub _address: u8,
}
pub type Eigen_MatrixBase_cross_product_return_type_Scalar = Eigen_ScalarBinaryOpTraits;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_MatrixBase_cross_product_return_type_type = u8;
pub const Eigen_MatrixBase_HomogeneousReturnTypeDirection: Eigen_MatrixBase__bindgen_ty_1 = 0;
pub type Eigen_MatrixBase__bindgen_ty_1 = i32;
pub type Eigen_MatrixBase_HomogeneousReturnType = u8;
pub const Eigen_MatrixBase_SizeMinusOne: Eigen_MatrixBase__bindgen_ty_2 = 0;
pub type Eigen_MatrixBase__bindgen_ty_2 = i32;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_MatrixBase_ConstStartMinusOne = u8;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_MatrixBase_HNormalizedReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " MatrixFunctions module /////////"]
pub type Eigen_MatrixBase_StemFunction = Eigen_internal_stem_function;
pub type Eigen_MatrixBase_DiagonalIndexReturnType_Type = u8;
pub type Eigen_MatrixBase_ConstDiagonalIndexReturnType_Type = u8;
pub type Eigen_MatrixBase_TriangularViewReturnType_Type = u8;
pub type Eigen_MatrixBase_ConstTriangularViewReturnType_Type = u8;
pub type Eigen_MatrixBase_SelfAdjointViewReturnType_Type = u8;
pub type Eigen_MatrixBase_ConstSelfAdjointViewReturnType_Type = u8;
#[doc = " \\class EigenBase\n \\ingroup Core_Module\n\n Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor MatrixBase(T).\n\n In other words, an EigenBase object is an object that can be copied into a MatrixBase.\n\n Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal matrices, etc.\n\n Notice that this class is trivial, it is only used to disambiguate overloaded functions.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_EigenBase {
    pub _address: u8,
}
#[doc = " \\brief The interface type of indices\n \\details To change this, \\c \\#define the preprocessor symbol \\c EIGEN_DEFAULT_DENSE_INDEX_TYPE.\n \\deprecated Since Eigen 3.3, its usage is deprecated. Use Eigen::Index instead.\n \\sa StorageIndex, \\ref TopicPreprocessorDirectives."]
pub type Eigen_EigenBase_Index = Eigen_Index;
pub type Eigen_EigenBase_StorageKind = Eigen_internal_traits;
pub type Eigen_Product_Lhs<_Lhs> = _Lhs;
pub type Eigen_Product_Rhs<_Rhs> = _Rhs;
pub type Eigen_Product_Base = u8;
pub type Eigen_Product_Scalar = Eigen_internal_traits;
pub type Eigen_Product_RealScalar = Eigen_NumTraits;
pub type Eigen_Product_CoeffReturnType = Eigen_Product_Base;
pub type Eigen_Product_Nested = Eigen_internal_ref_selector;
pub type Eigen_Product_StorageKind = Eigen_internal_traits;
pub type Eigen_Product_StorageIndex = Eigen_internal_traits;
pub const Eigen_Product_RowsAtCompileTime: Eigen_Product__bindgen_ty_1 = 0;
pub const Eigen_Product_ColsAtCompileTime: Eigen_Product__bindgen_ty_1 = 0;
pub const Eigen_Product_Flags: Eigen_Product__bindgen_ty_1 = 0;
pub const Eigen_Product_SizeAtCompileTime: Eigen_Product__bindgen_ty_1 = 0;
pub const Eigen_Product_MaxSizeAtCompileTime: Eigen_Product__bindgen_ty_1 = 0;
pub const Eigen_Product_IsVectorAtCompileTime: Eigen_Product__bindgen_ty_1 = 0;
pub type Eigen_Product__bindgen_ty_1 = i32;
pub type Eigen_Product_LhsNested = Eigen_internal_ref_selector;
pub type Eigen_Product_RhsNested = Eigen_internal_ref_selector;
pub type Eigen_Product_LhsNestedCleaned = Eigen_internal_remove_all;
pub type Eigen_Product_RhsNestedCleaned = Eigen_internal_remove_all;
pub type Eigen_ProductImpl_Base = Eigen_internal_generic_xpr_base;
#[doc = " \\class ArrayBase\n \\ingroup Core_Module\n\n \\brief Base class for all 1D and 2D array, and related expressions\n\n An array is similar to a dense vector or matrix. While matrices are mathematical\n objects with well defined linear algebra operators, an array is just a collection\n of scalar values arranged in a one or two dimensionnal fashion. As the main consequence,\n all operations applied to an array are performed coefficient wise. Furthermore,\n arrays support scalar math functions of the c++ standard library (e.g., std::sin(x)), and convenient\n constructors allowing to easily write generic code working for both scalar values\n and arrays.\n\n This class is the base that is inherited by all array expression types.\n\n \\tparam Derived is the derived type, e.g., an array or an expression type.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAYBASE_PLUGIN.\n\n \\sa class MatrixBase, \\ref TopicClassHierarchy"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_ArrayBase {
    pub _address: u8,
}
#[doc = " The base class for a given storage type."]
pub type Eigen_ArrayBase_StorageBaseType = Eigen_ArrayBase;
#[doc = " \\class ArrayBase\n \\ingroup Core_Module\n\n \\brief Base class for all 1D and 2D array, and related expressions\n\n An array is similar to a dense vector or matrix. While matrices are mathematical\n objects with well defined linear algebra operators, an array is just a collection\n of scalar values arranged in a one or two dimensionnal fashion. As the main consequence,\n all operations applied to an array are performed coefficient wise. Furthermore,\n arrays support scalar math functions of the c++ standard library (e.g., std::sin(x)), and convenient\n constructors allowing to easily write generic code working for both scalar values\n and arrays.\n\n This class is the base that is inherited by all array expression types.\n\n \\tparam Derived is the derived type, e.g., an array or an expression type.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAYBASE_PLUGIN.\n\n \\sa class MatrixBase, \\ref TopicClassHierarchy"]
pub type Eigen_ArrayBase_Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl = Eigen_ArrayBase;
pub type Eigen_ArrayBase_StorageKind = Eigen_internal_traits;
pub type Eigen_ArrayBase_Scalar = Eigen_internal_traits;
pub type Eigen_ArrayBase_PacketScalar = Eigen_internal_packet_traits;
pub type Eigen_ArrayBase_RealScalar = Eigen_NumTraits;
#[doc = " \\class DenseBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and arrays\n\n This class is the base that is inherited by all dense objects (matrix, vector, arrays,\n and related expression types). The common Eigen API for dense objects is contained in this class.\n\n \\tparam Derived is the derived type, e.g., a matrix type or an expression.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_DENSEBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_ArrayBase_Base = Eigen_DenseBase;
pub type Eigen_ArrayBase_CoeffReturnType = Eigen_ArrayBase_Base;
pub type Eigen_ArrayBase_PlainObject = Eigen_ArrayBase_Base;
#[doc = " \\internal Represents a matrix with all coefficients equal to one another"]
pub type Eigen_ArrayBase_ConstantReturnType = Eigen_CwiseNullaryOp<NullaryOp>;
#[doc = " \\internal the return type of conjugate()"]
pub type Eigen_ArrayBase_ConjugateReturnType = u8;
#[doc = " \\internal the return type of real() const"]
pub type Eigen_ArrayBase_RealReturnType = u8;
#[doc = " \\internal the return type of real()"]
pub type Eigen_ArrayBase_NonConstRealReturnType = u8;
#[doc = " \\internal the return type of imag() const"]
pub type Eigen_ArrayBase_ImagReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\internal the return type of imag()"]
pub type Eigen_ArrayBase_NonConstImagReturnType = Eigen_CwiseUnaryView<ViewOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_NegativeReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_ArrayBase_CastXpr {
    pub _address: u8,
}
pub type Eigen_ArrayBase_CastXpr_Type = Eigen_internal_cast_return_type;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseAbsReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseAbs2ReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseSqrtReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseSignReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseInverseReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_AbsReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_ArgReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_Abs2ReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_SqrtReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RsqrtReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_SignReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_InverseReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_BooleanNotReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_ExpReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_LogReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_Log1pReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_Log10ReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CosReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_SinReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_TanReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_AcosReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_AsinReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_AtanReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_TanhReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_SinhReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CoshReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_SquareReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CubeReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RoundReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_FloorReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CeilReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_IsNaNReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_IsInfReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_IsFiniteReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_LgammaReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_DigammaReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_ErfReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_ErfcReturnType = Eigen_CwiseUnaryOp<UnaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CwiseScalarEqualReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CmpLTReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RCmpLTReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CmpLEReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RCmpLEReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CmpEQReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RCmpEQReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_CmpNEQReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_ArrayBase_RCmpNEQReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " \\class NestByValue\n \\ingroup Core_Module\n\n \\brief Expression which must be nested by value\n\n \\tparam ExpressionType the type of the object of which we are requiring nesting-by-value\n\n This class is the return type of MatrixBase::nestByValue()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::nestByValue()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_NestByValue<ExpressionType> {
    pub m_expression: ExpressionType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExpressionType>>,
}
pub type Eigen_NestByValue_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_NestByValue_Scalar = Eigen_internal_traits;
pub type Eigen_NestByValue_RealScalar = Eigen_NumTraits;
pub type Eigen_NestByValue_CoeffReturnType = Eigen_NestByValue_Base;
pub type Eigen_NestByValue_Nested = Eigen_internal_ref_selector;
pub type Eigen_NestByValue_StorageKind = Eigen_internal_traits;
pub type Eigen_NestByValue_StorageIndex = Eigen_internal_traits;
pub const Eigen_NestByValue_RowsAtCompileTime: Eigen_NestByValue__bindgen_ty_1 = 0;
pub const Eigen_NestByValue_ColsAtCompileTime: Eigen_NestByValue__bindgen_ty_1 = 0;
pub const Eigen_NestByValue_Flags: Eigen_NestByValue__bindgen_ty_1 = 0;
pub const Eigen_NestByValue_SizeAtCompileTime: Eigen_NestByValue__bindgen_ty_1 = 0;
pub const Eigen_NestByValue_MaxSizeAtCompileTime: Eigen_NestByValue__bindgen_ty_1 = 0;
pub const Eigen_NestByValue_IsVectorAtCompileTime: Eigen_NestByValue__bindgen_ty_1 = 0;
pub type Eigen_NestByValue__bindgen_ty_1 = i32;
pub type Eigen_NestByValue_PacketScalar = Eigen_NestByValue_Base;
#[doc = " \\class ReturnByValue\n \\ingroup Core_Module\n"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_ReturnByValue {
    pub _address: u8,
}
pub type Eigen_ReturnByValue_ReturnType = Eigen_internal_traits;
pub type Eigen_ReturnByValue_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_ReturnByValue_Scalar = Eigen_internal_traits;
pub type Eigen_ReturnByValue_RealScalar = Eigen_NumTraits;
pub type Eigen_ReturnByValue_CoeffReturnType = Eigen_ReturnByValue_Base;
pub type Eigen_ReturnByValue_Nested = Eigen_internal_ref_selector;
pub type Eigen_ReturnByValue_StorageKind = Eigen_internal_traits;
pub type Eigen_ReturnByValue_StorageIndex = Eigen_internal_traits;
pub const Eigen_ReturnByValue_RowsAtCompileTime: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub const Eigen_ReturnByValue_ColsAtCompileTime: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub const Eigen_ReturnByValue_Flags: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub const Eigen_ReturnByValue_SizeAtCompileTime: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub const Eigen_ReturnByValue_MaxSizeAtCompileTime: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub const Eigen_ReturnByValue_IsVectorAtCompileTime: Eigen_ReturnByValue__bindgen_ty_1 = 0;
pub type Eigen_ReturnByValue__bindgen_ty_1 = i32;
pub type Eigen_ReturnByValue_PacketScalar = Eigen_ReturnByValue_Base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_ReturnByValue_YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT
{
    pub _address: u8,
}
#[doc = " \\class NoAlias\n \\ingroup Core_Module\n\n \\brief Pseudo expression providing an operator = assuming no aliasing\n\n \\tparam ExpressionType the type of the object on which to do the lazy assignment\n\n This class represents an expression with special assignment operators\n assuming no aliasing between the target expression and the source expression.\n More precisely it alloas to bypass the EvalBeforeAssignBit flag of the source expression.\n It is the return type of MatrixBase::noalias()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::noalias()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_NoAlias<ExpressionType> {
    pub m_expression: *mut ExpressionType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExpressionType>>,
}
pub type Eigen_NoAlias_Scalar = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase {
    pub m_storage: u8,
}
pub const Eigen_PlainObjectBase_Options: Eigen_PlainObjectBase__bindgen_ty_1 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_1 = i32;
pub type Eigen_PlainObjectBase_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_PlainObjectBase_StorageKind = Eigen_internal_traits;
pub type Eigen_PlainObjectBase_Scalar = Eigen_internal_traits;
pub type Eigen_PlainObjectBase_PacketScalar = Eigen_internal_packet_traits;
pub type Eigen_PlainObjectBase_RealScalar = Eigen_NumTraits;
pub type Eigen_PlainObjectBase_DenseType<Derived> = Derived;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_MapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_ConstMapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_AlignedMapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_ConstAlignedMapType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedConstMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedConstMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedAlignedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedAlignedMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedConstAlignedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedConstAlignedMapType_type = u8;
pub const Eigen_PlainObjectBase_NeedsToAlign: Eigen_PlainObjectBase__bindgen_ty_2 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_2 = i32;
pub type Eigen_PlainObjectBase_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_PlainObjectBase_IsPlainObjectBase: Eigen_PlainObjectBase__bindgen_ty_3 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_3 = i32;
#[doc = " \\brief Base class typedef.\n \\sa PlainObjectBase"]
pub type Eigen_Matrix_Base = Eigen_PlainObjectBase;
pub const Eigen_Matrix_Options: Eigen_Matrix__bindgen_ty_1 = 0;
pub type Eigen_Matrix__bindgen_ty_1 = i32;
pub type Eigen_Matrix_Scalar = Eigen_internal_traits;
pub type Eigen_Matrix_RealScalar = Eigen_NumTraits;
pub type Eigen_Matrix_CoeffReturnType = Eigen_Matrix_Base;
pub type Eigen_Matrix_Nested = Eigen_internal_ref_selector;
pub type Eigen_Matrix_StorageKind = Eigen_internal_traits;
pub type Eigen_Matrix_StorageIndex = Eigen_internal_traits;
pub const Eigen_Matrix_RowsAtCompileTime: Eigen_Matrix__bindgen_ty_2 = 0;
pub const Eigen_Matrix_ColsAtCompileTime: Eigen_Matrix__bindgen_ty_2 = 0;
pub const Eigen_Matrix_Flags: Eigen_Matrix__bindgen_ty_2 = 0;
pub const Eigen_Matrix_SizeAtCompileTime: Eigen_Matrix__bindgen_ty_2 = 0;
pub const Eigen_Matrix_MaxSizeAtCompileTime: Eigen_Matrix__bindgen_ty_2 = 0;
pub const Eigen_Matrix_IsVectorAtCompileTime: Eigen_Matrix__bindgen_ty_2 = 0;
pub type Eigen_Matrix__bindgen_ty_2 = i32;
pub type Eigen_Matrix_PacketScalar = Eigen_Matrix_Base;
pub type Eigen_Matrix_PlainObject = Eigen_Matrix_Base;
pub type Eigen_Matrix2i = u8;
pub type Eigen_Vector2i = u8;
pub type Eigen_RowVector2i = u8;
pub type Eigen_Matrix3i = u8;
pub type Eigen_Vector3i = u8;
pub type Eigen_RowVector3i = u8;
pub type Eigen_Matrix4i = u8;
pub type Eigen_Vector4i = u8;
pub type Eigen_RowVector4i = u8;
pub type Eigen_MatrixXi = u8;
pub type Eigen_VectorXi = u8;
pub type Eigen_RowVectorXi = u8;
pub type Eigen_Matrix2Xi = u8;
pub type Eigen_MatrixX2i = u8;
pub type Eigen_Matrix3Xi = u8;
pub type Eigen_MatrixX3i = u8;
pub type Eigen_Matrix4Xi = u8;
pub type Eigen_MatrixX4i = u8;
pub type Eigen_Matrix2f = u8;
pub type Eigen_Vector2f = u8;
pub type Eigen_RowVector2f = u8;
pub type Eigen_Matrix3f = u8;
pub type Eigen_Vector3f = u8;
pub type Eigen_RowVector3f = u8;
pub type Eigen_Matrix4f = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Vector4f = u128;
pub type Eigen_RowVector4f = u8;
pub type Eigen_MatrixXf = u8;
pub type Eigen_VectorXf = u8;
pub type Eigen_RowVectorXf = u8;
pub type Eigen_Matrix2Xf = u8;
pub type Eigen_MatrixX2f = u8;
pub type Eigen_Matrix3Xf = u8;
pub type Eigen_MatrixX3f = u8;
pub type Eigen_Matrix4Xf = u8;
pub type Eigen_MatrixX4f = u8;
pub type Eigen_Matrix2d = u8;
pub type Eigen_Vector2d = u8;
pub type Eigen_RowVector2d = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Matrix3d = [u64; 9usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Vector3d = [u64; 3usize];
pub type Eigen_RowVector3d = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Matrix4d = [u128; 8usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Vector4d = [u128; 2usize];
pub type Eigen_RowVector4d = u8;
pub type Eigen_MatrixXd = u8;
pub type Eigen_VectorXd = u8;
pub type Eigen_RowVectorXd = u8;
pub type Eigen_Matrix2Xd = u8;
pub type Eigen_MatrixX2d = u8;
pub type Eigen_Matrix3Xd = u8;
pub type Eigen_MatrixX3d = u8;
pub type Eigen_Matrix4Xd = u8;
pub type Eigen_MatrixX4d = u8;
pub type Eigen_Matrix2cf = u8;
pub type Eigen_Vector2cf = u8;
pub type Eigen_RowVector2cf = u8;
pub type Eigen_Matrix3cf = u8;
pub type Eigen_Vector3cf = u8;
pub type Eigen_RowVector3cf = u8;
pub type Eigen_Matrix4cf = u8;
pub type Eigen_Vector4cf = u8;
pub type Eigen_RowVector4cf = u8;
pub type Eigen_MatrixXcf = u8;
pub type Eigen_VectorXcf = u8;
pub type Eigen_RowVectorXcf = u8;
pub type Eigen_Matrix2Xcf = u8;
pub type Eigen_MatrixX2cf = u8;
pub type Eigen_Matrix3Xcf = u8;
pub type Eigen_MatrixX3cf = u8;
pub type Eigen_Matrix4Xcf = u8;
pub type Eigen_MatrixX4cf = u8;
pub type Eigen_Matrix2cd = u8;
pub type Eigen_Vector2cd = u8;
pub type Eigen_RowVector2cd = u8;
pub type Eigen_Matrix3cd = u8;
pub type Eigen_Vector3cd = u8;
pub type Eigen_RowVector3cd = u8;
pub type Eigen_Matrix4cd = u8;
pub type Eigen_Vector4cd = u8;
pub type Eigen_RowVector4cd = u8;
pub type Eigen_MatrixXcd = u8;
pub type Eigen_VectorXcd = u8;
pub type Eigen_RowVectorXcd = u8;
pub type Eigen_Matrix2Xcd = u8;
pub type Eigen_MatrixX2cd = u8;
pub type Eigen_Matrix3Xcd = u8;
pub type Eigen_MatrixX3cd = u8;
pub type Eigen_Matrix4Xcd = u8;
pub type Eigen_MatrixX4cd = u8;
pub type Eigen_Array_Base = Eigen_PlainObjectBase;
pub type Eigen_Array_Scalar = Eigen_internal_traits;
pub type Eigen_Array_RealScalar = Eigen_NumTraits;
pub type Eigen_Array_CoeffReturnType = Eigen_Array_Base;
pub type Eigen_Array_Nested = Eigen_internal_ref_selector;
pub type Eigen_Array_StorageKind = Eigen_internal_traits;
pub type Eigen_Array_StorageIndex = Eigen_internal_traits;
pub const Eigen_Array_RowsAtCompileTime: Eigen_Array__bindgen_ty_1 = 0;
pub const Eigen_Array_ColsAtCompileTime: Eigen_Array__bindgen_ty_1 = 0;
pub const Eigen_Array_Flags: Eigen_Array__bindgen_ty_1 = 0;
pub const Eigen_Array_SizeAtCompileTime: Eigen_Array__bindgen_ty_1 = 0;
pub const Eigen_Array_MaxSizeAtCompileTime: Eigen_Array__bindgen_ty_1 = 0;
pub const Eigen_Array_IsVectorAtCompileTime: Eigen_Array__bindgen_ty_1 = 0;
pub type Eigen_Array__bindgen_ty_1 = i32;
pub type Eigen_Array_PacketScalar = Eigen_Array_Base;
pub const Eigen_Array_Options: Eigen_Array__bindgen_ty_2 = 0;
pub type Eigen_Array__bindgen_ty_2 = i32;
pub type Eigen_Array_PlainObject = Eigen_Array_Base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Array_PrivateType {
    pub _address: u8,
}
pub type Eigen_Array22i = u8;
pub type Eigen_Array2i = u8;
pub type Eigen_Array33i = u8;
pub type Eigen_Array3i = u8;
pub type Eigen_Array44i = u8;
pub type Eigen_Array4i = u8;
pub type Eigen_ArrayXXi = u8;
pub type Eigen_ArrayXi = u8;
pub type Eigen_Array2Xi = u8;
pub type Eigen_ArrayX2i = u8;
pub type Eigen_Array3Xi = u8;
pub type Eigen_ArrayX3i = u8;
pub type Eigen_Array4Xi = u8;
pub type Eigen_ArrayX4i = u8;
pub type Eigen_Array22f = u8;
pub type Eigen_Array2f = u8;
pub type Eigen_Array33f = u8;
pub type Eigen_Array3f = u8;
pub type Eigen_Array44f = u8;
pub type Eigen_Array4f = u8;
pub type Eigen_ArrayXXf = u8;
pub type Eigen_ArrayXf = u8;
pub type Eigen_Array2Xf = u8;
pub type Eigen_ArrayX2f = u8;
pub type Eigen_Array3Xf = u8;
pub type Eigen_ArrayX3f = u8;
pub type Eigen_Array4Xf = u8;
pub type Eigen_ArrayX4f = u8;
pub type Eigen_Array22d = u8;
pub type Eigen_Array2d = u8;
pub type Eigen_Array33d = u8;
pub type Eigen_Array3d = u8;
pub type Eigen_Array44d = u8;
pub type Eigen_Array4d = u8;
pub type Eigen_ArrayXXd = u8;
pub type Eigen_ArrayXd = u8;
pub type Eigen_Array2Xd = u8;
pub type Eigen_ArrayX2d = u8;
pub type Eigen_Array3Xd = u8;
pub type Eigen_ArrayX3d = u8;
pub type Eigen_Array4Xd = u8;
pub type Eigen_ArrayX4d = u8;
pub type Eigen_Array22cf = u8;
pub type Eigen_Array2cf = u8;
pub type Eigen_Array33cf = u8;
pub type Eigen_Array3cf = u8;
pub type Eigen_Array44cf = u8;
pub type Eigen_Array4cf = u8;
pub type Eigen_ArrayXXcf = u8;
pub type Eigen_ArrayXcf = u8;
pub type Eigen_Array2Xcf = u8;
pub type Eigen_ArrayX2cf = u8;
pub type Eigen_Array3Xcf = u8;
pub type Eigen_ArrayX3cf = u8;
pub type Eigen_Array4Xcf = u8;
pub type Eigen_ArrayX4cf = u8;
pub type Eigen_Array22cd = u8;
pub type Eigen_Array2cd = u8;
pub type Eigen_Array33cd = u8;
pub type Eigen_Array3cd = u8;
pub type Eigen_Array44cd = u8;
pub type Eigen_Array4cd = u8;
pub type Eigen_ArrayXXcd = u8;
pub type Eigen_ArrayXcd = u8;
pub type Eigen_Array2Xcd = u8;
pub type Eigen_ArrayX2cd = u8;
pub type Eigen_Array3Xcd = u8;
pub type Eigen_ArrayX3cd = u8;
pub type Eigen_Array4Xcd = u8;
pub type Eigen_ArrayX4cd = u8;
#[doc = " \\class CwiseTernaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise ternary operator is\n applied to two expressions\n\n \\tparam TernaryOp template functor implementing the operator\n \\tparam Arg1Type the type of the first argument\n \\tparam Arg2Type the type of the second argument\n \\tparam Arg3Type the type of the third argument\n\n This class represents an expression where a coefficient-wise ternary\n operator is applied to three expressions.\n It is the return type of ternary operators, by which we mean only those\n ternary operators where\n all three arguments are Eigen expressions.\n For example, the return type of betainc(matrix1, matrix2, matrix3) is a\n CwiseTernaryOp.\n\n Most of the time, this is the only way that it is used, so you typically\n don't have to name\n CwiseTernaryOp types explicitly.\n\n \\sa MatrixBase::ternaryExpr(const MatrixBase<Argument2> &, const\n MatrixBase<Argument3> &, const CustomTernaryOp &) const, class CwiseBinaryOp,\n class CwiseUnaryOp, class CwiseNullaryOp"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_CwiseTernaryOp<TernaryOp> {
    pub m_arg1: Eigen_CwiseTernaryOp_Arg1Nested,
    pub m_arg2: Eigen_CwiseTernaryOp_Arg2Nested,
    pub m_arg3: Eigen_CwiseTernaryOp_Arg3Nested,
    pub m_functor: TernaryOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TernaryOp>>,
}
pub type Eigen_CwiseTernaryOp_Arg1 = Eigen_internal_remove_all;
pub type Eigen_CwiseTernaryOp_Arg2 = Eigen_internal_remove_all;
pub type Eigen_CwiseTernaryOp_Arg3 = Eigen_internal_remove_all;
pub type Eigen_CwiseTernaryOp_Base = Eigen_CwiseTernaryOpImpl;
pub type Eigen_CwiseTernaryOp_Scalar = Eigen_internal_traits;
pub type Eigen_CwiseTernaryOp_RealScalar = Eigen_NumTraits;
pub type Eigen_CwiseTernaryOp_CoeffReturnType = Eigen_CwiseTernaryOp_Base;
pub type Eigen_CwiseTernaryOp_Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseTernaryOp_StorageKind = Eigen_internal_traits;
pub type Eigen_CwiseTernaryOp_StorageIndex = Eigen_internal_traits;
pub const Eigen_CwiseTernaryOp_RowsAtCompileTime: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseTernaryOp_ColsAtCompileTime: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseTernaryOp_Flags: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseTernaryOp_SizeAtCompileTime: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseTernaryOp_MaxSizeAtCompileTime: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseTernaryOp_IsVectorAtCompileTime: Eigen_CwiseTernaryOp__bindgen_ty_1 = 0;
pub type Eigen_CwiseTernaryOp__bindgen_ty_1 = i32;
pub type Eigen_CwiseTernaryOp_Arg1Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseTernaryOp_Arg2Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseTernaryOp_Arg3Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseTernaryOp__Arg1Nested = Eigen_internal_remove_reference;
pub type Eigen_CwiseTernaryOp__Arg2Nested = Eigen_internal_remove_reference;
pub type Eigen_CwiseTernaryOp__Arg3Nested = Eigen_internal_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_CwiseTernaryOpImpl {
    pub _address: u8,
}
pub type Eigen_CwiseTernaryOpImpl_Base = Eigen_internal_generic_xpr_base;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_CwiseBinaryOp<BinaryOp> {
    pub m_lhs: Eigen_CwiseBinaryOp_LhsNested,
    pub m_rhs: Eigen_CwiseBinaryOp_RhsNested,
    pub m_functor: BinaryOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BinaryOp>>,
}
pub type Eigen_CwiseBinaryOp_Functor = Eigen_internal_remove_all;
pub type Eigen_CwiseBinaryOp_Lhs = Eigen_internal_remove_all;
pub type Eigen_CwiseBinaryOp_Rhs = Eigen_internal_remove_all;
pub type Eigen_CwiseBinaryOp_Base = Eigen_CwiseBinaryOpImpl;
pub type Eigen_CwiseBinaryOp_Scalar = Eigen_internal_traits;
pub type Eigen_CwiseBinaryOp_RealScalar = Eigen_NumTraits;
pub type Eigen_CwiseBinaryOp_CoeffReturnType = Eigen_CwiseBinaryOp_Base;
pub type Eigen_CwiseBinaryOp_Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseBinaryOp_StorageKind = Eigen_internal_traits;
pub type Eigen_CwiseBinaryOp_StorageIndex = Eigen_internal_traits;
pub const Eigen_CwiseBinaryOp_RowsAtCompileTime: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseBinaryOp_ColsAtCompileTime: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseBinaryOp_Flags: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseBinaryOp_SizeAtCompileTime: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseBinaryOp_MaxSizeAtCompileTime: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseBinaryOp_IsVectorAtCompileTime: Eigen_CwiseBinaryOp__bindgen_ty_1 = 0;
pub type Eigen_CwiseBinaryOp__bindgen_ty_1 = i32;
pub type Eigen_CwiseBinaryOp_LhsNested = Eigen_internal_ref_selector;
pub type Eigen_CwiseBinaryOp_RhsNested = Eigen_internal_ref_selector;
pub type Eigen_CwiseBinaryOp__LhsNested = Eigen_internal_remove_reference;
pub type Eigen_CwiseBinaryOp__RhsNested = Eigen_internal_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_CwiseBinaryOpImpl {
    pub _address: u8,
}
pub type Eigen_CwiseBinaryOpImpl_Base = Eigen_internal_generic_xpr_base;
#[doc = " \\class CwiseUnaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise unary operator is applied to an expression\n\n \\tparam UnaryOp template functor implementing the operator\n \\tparam XprType the type of the expression to which we are applying the unary operator\n\n This class represents an expression where a unary operator is applied to an expression.\n It is the return type of all operations taking exactly 1 input expression, regardless of the\n presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix\n is considered unary, because only the right-hand side is an expression, and its\n return type is a specialization of CwiseUnaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseUnaryOp types explicitly.\n\n \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_CwiseUnaryOp<UnaryOp> {
    pub m_xpr: Eigen_CwiseUnaryOp_XprTypeNested,
    pub m_functor: UnaryOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<UnaryOp>>,
}
pub type Eigen_CwiseUnaryOp_Base = Eigen_CwiseUnaryOpImpl;
pub type Eigen_CwiseUnaryOp_Scalar = Eigen_internal_traits;
pub type Eigen_CwiseUnaryOp_RealScalar = Eigen_NumTraits;
pub type Eigen_CwiseUnaryOp_CoeffReturnType = Eigen_CwiseUnaryOp_Base;
pub type Eigen_CwiseUnaryOp_Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseUnaryOp_StorageKind = Eigen_internal_traits;
pub type Eigen_CwiseUnaryOp_StorageIndex = Eigen_internal_traits;
pub const Eigen_CwiseUnaryOp_RowsAtCompileTime: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryOp_ColsAtCompileTime: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryOp_Flags: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryOp_SizeAtCompileTime: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryOp_MaxSizeAtCompileTime: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryOp_IsVectorAtCompileTime: Eigen_CwiseUnaryOp__bindgen_ty_1 = 0;
pub type Eigen_CwiseUnaryOp__bindgen_ty_1 = i32;
pub type Eigen_CwiseUnaryOp_XprTypeNested = Eigen_internal_ref_selector;
pub type Eigen_CwiseUnaryOp_NestedExpression = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_CwiseUnaryOpImpl {
    pub _address: u8,
}
pub type Eigen_CwiseUnaryOpImpl_Base = Eigen_internal_generic_xpr_base;
#[doc = " \\class CwiseNullaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression of a matrix where all coefficients are defined by a functor\n\n \\tparam NullaryOp template functor implementing the operator\n \\tparam PlainObjectType the underlying plain matrix/array type\n\n This class represents an expression of a generic nullary operator.\n It is the return type of the Ones(), Zero(), Constant(), Identity() and Random() methods,\n and most of the time this is the only way it is used.\n\n However, if you want to write a function returning such an expression, you\n will need to use this class.\n\n The functor NullaryOp must expose one of the following method:\n<table class=\"manual\">\n<tr            ><td>\\c operator()() </td><td>if the procedural generation does not depend on the coefficient entries (e.g., random numbers)</td></tr>\n<tr class=\"alt\"><td>\\c operator()(Index i)</td><td>if the procedural generation makes sense for vectors only and that it depends on the coefficient index \\c i (e.g., linspace) </td></tr>\n<tr            ><td>\\c operator()(Index i,Index j)</td><td>if the procedural generation depends on the matrix coordinates \\c i, \\c j (e.g., to generate a checkerboard with 0 and 1)</td></tr>\n</table>\n It is also possible to expose the last two operators if the generation makes sense for matrices but can be optimized for vectors.\n\n See DenseBase::NullaryExpr(Index,const CustomNullaryOp&) for an example binding\n C++11 random number generators.\n\n A nullary expression can also be used to implement custom sophisticated matrix manipulations\n that cannot be covered by the existing set of natively supported matrix manipulations.\n See this \\ref TopicCustomizing_NullaryExpr \"page\" for some examples and additional explanations\n on the behavior of CwiseNullaryOp.\n\n \\sa class CwiseUnaryOp, class CwiseBinaryOp, DenseBase::NullaryExpr"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_CwiseNullaryOp<NullaryOp> {
    pub m_rows: u8,
    pub m_cols: u8,
    pub m_functor: NullaryOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<NullaryOp>>,
}
pub type Eigen_CwiseNullaryOp_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_CwiseNullaryOp_Scalar = Eigen_internal_traits;
pub type Eigen_CwiseNullaryOp_RealScalar = Eigen_NumTraits;
pub type Eigen_CwiseNullaryOp_CoeffReturnType = Eigen_CwiseNullaryOp_Base;
pub type Eigen_CwiseNullaryOp_Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseNullaryOp_StorageKind = Eigen_internal_traits;
pub type Eigen_CwiseNullaryOp_StorageIndex = Eigen_internal_traits;
pub const Eigen_CwiseNullaryOp_RowsAtCompileTime: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseNullaryOp_ColsAtCompileTime: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseNullaryOp_Flags: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseNullaryOp_SizeAtCompileTime: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseNullaryOp_MaxSizeAtCompileTime: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub const Eigen_CwiseNullaryOp_IsVectorAtCompileTime: Eigen_CwiseNullaryOp__bindgen_ty_1 = 0;
pub type Eigen_CwiseNullaryOp__bindgen_ty_1 = i32;
pub type Eigen_CwiseNullaryOp_PacketScalar = Eigen_CwiseNullaryOp_Base;
#[doc = " \\class CwiseUnaryView\n \\ingroup Core_Module\n\n \\brief Generic lvalue expression of a coefficient-wise unary operator of a matrix or a vector\n\n \\tparam ViewOp template functor implementing the view\n \\tparam MatrixType the type of the matrix we are applying the unary operator\n\n This class represents a lvalue expression of a generic unary view operator of a matrix or a vector.\n It is the return type of real() and imag(), and most of the time this is the only way it is used.\n\n \\sa MatrixBase::unaryViewExpr(const CustomUnaryOp &) const, class CwiseUnaryOp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_CwiseUnaryView<ViewOp> {
    pub m_matrix: Eigen_CwiseUnaryView_MatrixTypeNested,
    pub m_functor: ViewOp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ViewOp>>,
}
pub type Eigen_CwiseUnaryView_Base = Eigen_CwiseUnaryViewImpl;
pub type Eigen_CwiseUnaryView_Scalar = Eigen_internal_traits;
pub type Eigen_CwiseUnaryView_RealScalar = Eigen_NumTraits;
pub type Eigen_CwiseUnaryView_CoeffReturnType = Eigen_CwiseUnaryView_Base;
pub type Eigen_CwiseUnaryView_Nested = Eigen_internal_ref_selector;
pub type Eigen_CwiseUnaryView_StorageKind = Eigen_internal_traits;
pub type Eigen_CwiseUnaryView_StorageIndex = Eigen_internal_traits;
pub const Eigen_CwiseUnaryView_RowsAtCompileTime: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryView_ColsAtCompileTime: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryView_Flags: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryView_SizeAtCompileTime: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryView_MaxSizeAtCompileTime: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub const Eigen_CwiseUnaryView_IsVectorAtCompileTime: Eigen_CwiseUnaryView__bindgen_ty_1 = 0;
pub type Eigen_CwiseUnaryView__bindgen_ty_1 = i32;
pub type Eigen_CwiseUnaryView_MatrixTypeNested = Eigen_internal_ref_selector;
pub type Eigen_CwiseUnaryView_NestedExpression = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_CwiseUnaryViewImpl {
    pub _address: u8,
}
pub type Eigen_CwiseUnaryViewImpl_Base = Eigen_internal_generic_xpr_base;
pub type Eigen_Stride_Index = Eigen_Index;
pub const Eigen_Stride_InnerStrideAtCompileTime: Eigen_Stride__bindgen_ty_1 = 0;
pub const Eigen_Stride_OuterStrideAtCompileTime: Eigen_Stride__bindgen_ty_1 = 0;
pub type Eigen_Stride__bindgen_ty_1 = i32;
#[doc = " \\class Stride\n \\ingroup Core_Module\n\n \\brief Holds strides information for Map\n\n This class holds the strides information for mapping arrays with strides with class Map.\n\n It holds two values: the inner stride and the outer stride.\n\n The inner stride is the pointer increment between two consecutive entries within a given row of a\n row-major matrix or within a given column of a column-major matrix.\n\n The outer stride is the pointer increment between two consecutive rows of a row-major matrix or\n between two consecutive columns of a column-major matrix.\n\n These two values can be passed either at compile-time as template parameters, or at runtime as\n arguments to the constructor.\n\n Indeed, this class takes two template parameters:\n  \\tparam _OuterStrideAtCompileTime the outer stride, or Dynamic if you want to specify it at runtime.\n  \\tparam _InnerStrideAtCompileTime the inner stride, or Dynamic if you want to specify it at runtime.\n\n Here is an example:\n \\include Map_general_stride.cpp\n Output: \\verbinclude Map_general_stride.out\n\n \\sa class InnerStride, class OuterStride, \\ref TopicStorageOrders"]
pub type Eigen_InnerStride_Base = u8;
#[doc = " \\class Stride\n \\ingroup Core_Module\n\n \\brief Holds strides information for Map\n\n This class holds the strides information for mapping arrays with strides with class Map.\n\n It holds two values: the inner stride and the outer stride.\n\n The inner stride is the pointer increment between two consecutive entries within a given row of a\n row-major matrix or within a given column of a column-major matrix.\n\n The outer stride is the pointer increment between two consecutive rows of a row-major matrix or\n between two consecutive columns of a column-major matrix.\n\n These two values can be passed either at compile-time as template parameters, or at runtime as\n arguments to the constructor.\n\n Indeed, this class takes two template parameters:\n  \\tparam _OuterStrideAtCompileTime the outer stride, or Dynamic if you want to specify it at runtime.\n  \\tparam _InnerStrideAtCompileTime the inner stride, or Dynamic if you want to specify it at runtime.\n\n Here is an example:\n \\include Map_general_stride.cpp\n Output: \\verbinclude Map_general_stride.out\n\n \\sa class InnerStride, class OuterStride, \\ref TopicStorageOrders"]
pub type Eigen_OuterStride_Base = u8;
pub type Eigen_Map_Base = u8;
pub type Eigen_Map_Scalar = Eigen_internal_traits;
pub type Eigen_Map_RealScalar = Eigen_NumTraits;
pub type Eigen_Map_CoeffReturnType = Eigen_Map_Base;
pub type Eigen_Map_Nested = Eigen_internal_ref_selector;
pub type Eigen_Map_StorageKind = Eigen_internal_traits;
pub type Eigen_Map_StorageIndex = Eigen_internal_traits;
pub const Eigen_Map_RowsAtCompileTime: Eigen_Map__bindgen_ty_1 = 0;
pub const Eigen_Map_ColsAtCompileTime: Eigen_Map__bindgen_ty_1 = 0;
pub const Eigen_Map_Flags: Eigen_Map__bindgen_ty_1 = 0;
pub const Eigen_Map_SizeAtCompileTime: Eigen_Map__bindgen_ty_1 = 0;
pub const Eigen_Map_MaxSizeAtCompileTime: Eigen_Map__bindgen_ty_1 = 0;
pub const Eigen_Map_IsVectorAtCompileTime: Eigen_Map__bindgen_ty_1 = 0;
pub type Eigen_Map__bindgen_ty_1 = i32;
pub type Eigen_Map_PacketScalar = Eigen_Map_Base;
pub type Eigen_Map_PointerType = Eigen_Map_Base;
pub type Eigen_Map_PointerArgType = Eigen_Map_PointerType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_RefBase {
    pub m_stride: Eigen_RefBase_StrideBase,
}
pub type Eigen_RefBase_PlainObjectType = Eigen_internal_traits;
pub type Eigen_RefBase_StrideType = Eigen_internal_traits;
pub type Eigen_RefBase_Base = u8;
pub type Eigen_RefBase_Scalar = Eigen_internal_traits;
pub type Eigen_RefBase_RealScalar = Eigen_NumTraits;
pub type Eigen_RefBase_CoeffReturnType = Eigen_RefBase_Base;
pub type Eigen_RefBase_Nested = Eigen_internal_ref_selector;
pub type Eigen_RefBase_StorageKind = Eigen_internal_traits;
pub type Eigen_RefBase_StorageIndex = Eigen_internal_traits;
pub const Eigen_RefBase_RowsAtCompileTime: Eigen_RefBase__bindgen_ty_1 = 0;
pub const Eigen_RefBase_ColsAtCompileTime: Eigen_RefBase__bindgen_ty_1 = 0;
pub const Eigen_RefBase_Flags: Eigen_RefBase__bindgen_ty_1 = 0;
pub const Eigen_RefBase_SizeAtCompileTime: Eigen_RefBase__bindgen_ty_1 = 0;
pub const Eigen_RefBase_MaxSizeAtCompileTime: Eigen_RefBase__bindgen_ty_1 = 0;
pub const Eigen_RefBase_IsVectorAtCompileTime: Eigen_RefBase__bindgen_ty_1 = 0;
pub type Eigen_RefBase__bindgen_ty_1 = i32;
pub type Eigen_RefBase_PacketScalar = Eigen_RefBase_Base;
#[doc = " \\class Stride\n \\ingroup Core_Module\n\n \\brief Holds strides information for Map\n\n This class holds the strides information for mapping arrays with strides with class Map.\n\n It holds two values: the inner stride and the outer stride.\n\n The inner stride is the pointer increment between two consecutive entries within a given row of a\n row-major matrix or within a given column of a column-major matrix.\n\n The outer stride is the pointer increment between two consecutive rows of a row-major matrix or\n between two consecutive columns of a column-major matrix.\n\n These two values can be passed either at compile-time as template parameters, or at runtime as\n arguments to the constructor.\n\n Indeed, this class takes two template parameters:\n  \\tparam _OuterStrideAtCompileTime the outer stride, or Dynamic if you want to specify it at runtime.\n  \\tparam _InnerStrideAtCompileTime the inner stride, or Dynamic if you want to specify it at runtime.\n\n Here is an example:\n \\include Map_general_stride.cpp\n Output: \\verbinclude Map_general_stride.out\n\n \\sa class InnerStride, class OuterStride, \\ref TopicStorageOrders"]
pub type Eigen_RefBase_StrideBase = u8;
pub type Eigen_Ref_Traits = Eigen_internal_traits;
pub type Eigen_Ref_Base = Eigen_RefBase;
pub type Eigen_Ref_Scalar = Eigen_internal_traits;
pub type Eigen_Ref_RealScalar = Eigen_NumTraits;
pub type Eigen_Ref_CoeffReturnType = Eigen_Ref_Base;
pub type Eigen_Ref_Nested = Eigen_internal_ref_selector;
pub type Eigen_Ref_StorageKind = Eigen_internal_traits;
pub type Eigen_Ref_StorageIndex = Eigen_internal_traits;
pub const Eigen_Ref_RowsAtCompileTime: Eigen_Ref__bindgen_ty_1 = 0;
pub const Eigen_Ref_ColsAtCompileTime: Eigen_Ref__bindgen_ty_1 = 0;
pub const Eigen_Ref_Flags: Eigen_Ref__bindgen_ty_1 = 0;
pub const Eigen_Ref_SizeAtCompileTime: Eigen_Ref__bindgen_ty_1 = 0;
pub const Eigen_Ref_MaxSizeAtCompileTime: Eigen_Ref__bindgen_ty_1 = 0;
pub const Eigen_Ref_IsVectorAtCompileTime: Eigen_Ref__bindgen_ty_1 = 0;
pub type Eigen_Ref__bindgen_ty_1 = i32;
pub type Eigen_Ref_PacketScalar = Eigen_Ref_Base;
pub type Eigen_Block_Impl = u8;
pub type Eigen_Block_Base = Eigen_Block_Impl;
pub type Eigen_Block_Scalar = Eigen_internal_traits;
pub type Eigen_Block_RealScalar = Eigen_NumTraits;
pub type Eigen_Block_CoeffReturnType = Eigen_Block_Base;
pub type Eigen_Block_Nested = Eigen_internal_ref_selector;
pub type Eigen_Block_StorageKind = Eigen_internal_traits;
pub type Eigen_Block_StorageIndex = Eigen_internal_traits;
pub const Eigen_Block_RowsAtCompileTime: Eigen_Block__bindgen_ty_1 = 0;
pub const Eigen_Block_ColsAtCompileTime: Eigen_Block__bindgen_ty_1 = 0;
pub const Eigen_Block_Flags: Eigen_Block__bindgen_ty_1 = 0;
pub const Eigen_Block_SizeAtCompileTime: Eigen_Block__bindgen_ty_1 = 0;
pub const Eigen_Block_MaxSizeAtCompileTime: Eigen_Block__bindgen_ty_1 = 0;
pub const Eigen_Block_IsVectorAtCompileTime: Eigen_Block__bindgen_ty_1 = 0;
pub type Eigen_Block__bindgen_ty_1 = i32;
pub type Eigen_Block_NestedExpression = Eigen_internal_remove_all;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_VectorBlock_Base = u8;
pub const Eigen_VectorBlock_IsColVector: Eigen_VectorBlock__bindgen_ty_1 = 0;
pub type Eigen_VectorBlock__bindgen_ty_1 = i32;
pub type Eigen_VectorBlock_Scalar = Eigen_internal_traits;
pub type Eigen_VectorBlock_RealScalar = Eigen_NumTraits;
pub type Eigen_VectorBlock_CoeffReturnType = Eigen_VectorBlock_Base;
pub type Eigen_VectorBlock_Nested = Eigen_internal_ref_selector;
pub type Eigen_VectorBlock_StorageKind = Eigen_internal_traits;
pub type Eigen_VectorBlock_StorageIndex = Eigen_internal_traits;
pub const Eigen_VectorBlock_RowsAtCompileTime: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub const Eigen_VectorBlock_ColsAtCompileTime: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub const Eigen_VectorBlock_Flags: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub const Eigen_VectorBlock_SizeAtCompileTime: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub const Eigen_VectorBlock_MaxSizeAtCompileTime: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub const Eigen_VectorBlock_IsVectorAtCompileTime: Eigen_VectorBlock__bindgen_ty_2 = 0;
pub type Eigen_VectorBlock__bindgen_ty_2 = i32;
pub type Eigen_VectorBlock_PacketScalar = Eigen_VectorBlock_Base;
#[doc = " \\class Transpose\n \\ingroup Core_Module\n\n \\brief Expression of the transpose of a matrix\n\n \\tparam MatrixType the type of the object of which we are taking the transpose\n\n This class represents an expression of the transpose of a matrix.\n It is the return type of MatrixBase::transpose() and MatrixBase::adjoint()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::transpose(), MatrixBase::adjoint()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Transpose {
    pub m_matrix: Eigen_internal_ref_selector,
}
pub type Eigen_Transpose_MatrixTypeNested = Eigen_internal_ref_selector;
pub type Eigen_Transpose_Base = Eigen_TransposeImpl;
pub type Eigen_Transpose_Scalar = Eigen_internal_traits;
pub type Eigen_Transpose_RealScalar = Eigen_NumTraits;
pub type Eigen_Transpose_CoeffReturnType = Eigen_Transpose_Base;
pub type Eigen_Transpose_Nested = Eigen_internal_ref_selector;
pub type Eigen_Transpose_StorageKind = Eigen_internal_traits;
pub type Eigen_Transpose_StorageIndex = Eigen_internal_traits;
pub const Eigen_Transpose_RowsAtCompileTime: Eigen_Transpose__bindgen_ty_1 = 0;
pub const Eigen_Transpose_ColsAtCompileTime: Eigen_Transpose__bindgen_ty_1 = 0;
pub const Eigen_Transpose_Flags: Eigen_Transpose__bindgen_ty_1 = 0;
pub const Eigen_Transpose_SizeAtCompileTime: Eigen_Transpose__bindgen_ty_1 = 0;
pub const Eigen_Transpose_MaxSizeAtCompileTime: Eigen_Transpose__bindgen_ty_1 = 0;
pub const Eigen_Transpose_IsVectorAtCompileTime: Eigen_Transpose__bindgen_ty_1 = 0;
pub type Eigen_Transpose__bindgen_ty_1 = i32;
pub type Eigen_Transpose_NestedExpression = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TransposeImpl {
    pub _address: u8,
}
pub type Eigen_TransposeImpl_Base = Eigen_internal_generic_xpr_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_DiagonalBase {
    pub _address: u8,
}
pub type Eigen_DiagonalBase_DiagonalVectorType = Eigen_internal_traits;
pub type Eigen_DiagonalBase_Scalar = Eigen_DiagonalBase_DiagonalVectorType;
pub type Eigen_DiagonalBase_RealScalar = Eigen_DiagonalBase_DiagonalVectorType;
pub type Eigen_DiagonalBase_StorageKind = Eigen_internal_traits;
pub type Eigen_DiagonalBase_StorageIndex = Eigen_internal_traits;
pub const Eigen_DiagonalBase_RowsAtCompileTime: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub const Eigen_DiagonalBase_ColsAtCompileTime: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub const Eigen_DiagonalBase_MaxRowsAtCompileTime: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub const Eigen_DiagonalBase_MaxColsAtCompileTime: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub const Eigen_DiagonalBase_IsVectorAtCompileTime: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub const Eigen_DiagonalBase_Flags: Eigen_DiagonalBase__bindgen_ty_1 = 0;
pub type Eigen_DiagonalBase__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_DiagonalBase_DenseMatrixType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_DiagonalBase_DenseType = Eigen_DiagonalBase_DenseMatrixType;
pub type Eigen_DiagonalBase_PlainObject = u8;
pub type Eigen_DiagonalBase_InverseReturnType = Eigen_DiagonalWrapper;
pub type Eigen_DiagonalMatrix_DiagonalVectorType = Eigen_internal_traits;
pub type Eigen_DiagonalMatrix_Nested = *const u8;
pub type Eigen_DiagonalMatrix_Scalar<_Scalar> = _Scalar;
pub type Eigen_DiagonalMatrix_StorageKind = Eigen_internal_traits;
pub type Eigen_DiagonalMatrix_StorageIndex = Eigen_internal_traits;
#[repr(C)]
pub struct Eigen_DiagonalWrapper {
    pub m_diagonal: [u8; 0usize],
}
pub type Eigen_DiagonalWrapper_DiagonalVectorType<_DiagonalVectorType> = _DiagonalVectorType;
pub type Eigen_DiagonalWrapper_Nested = Eigen_DiagonalWrapper;
pub const Eigen_Diagonal_DiagIndex: Eigen_Diagonal__bindgen_ty_1 = 0;
pub type Eigen_Diagonal__bindgen_ty_1 = i32;
pub type Eigen_Diagonal_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_Diagonal_Scalar = Eigen_internal_traits;
pub type Eigen_Diagonal_RealScalar = Eigen_NumTraits;
pub type Eigen_Diagonal_CoeffReturnType = Eigen_Diagonal_Base;
pub type Eigen_Diagonal_Nested = Eigen_internal_ref_selector;
pub type Eigen_Diagonal_StorageKind = Eigen_internal_traits;
pub type Eigen_Diagonal_StorageIndex = Eigen_internal_traits;
pub const Eigen_Diagonal_RowsAtCompileTime: Eigen_Diagonal__bindgen_ty_2 = 0;
pub const Eigen_Diagonal_ColsAtCompileTime: Eigen_Diagonal__bindgen_ty_2 = 0;
pub const Eigen_Diagonal_Flags: Eigen_Diagonal__bindgen_ty_2 = 0;
pub const Eigen_Diagonal_SizeAtCompileTime: Eigen_Diagonal__bindgen_ty_2 = 0;
pub const Eigen_Diagonal_MaxSizeAtCompileTime: Eigen_Diagonal__bindgen_ty_2 = 0;
pub const Eigen_Diagonal_IsVectorAtCompileTime: Eigen_Diagonal__bindgen_ty_2 = 0;
pub type Eigen_Diagonal__bindgen_ty_2 = i32;
pub type Eigen_Diagonal_PacketScalar = Eigen_Diagonal_Base;
pub type Eigen_Diagonal_ScalarWithConstIfNotLvalue = u8;
#[doc = " \\class CommaInitializer\n \\ingroup Core_Module\n\n \\brief Helper class used by the comma initializer operator\n\n This class is internally used to implement the comma initializer feature. It is\n the return type of MatrixBase::operator<<, and most of the time this is the only\n way it is used.\n\n \\sa \\blank \\ref MatrixBaseCommaInitRef \"MatrixBase::operator<<\", CommaInitializer::finished()"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_CommaInitializer<XprType> {
    pub m_xpr: *mut XprType,
    pub m_row: Eigen_Index,
    pub m_col: Eigen_Index,
    pub m_currentBlockRows: Eigen_Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<XprType>>,
}
pub type Eigen_CommaInitializer_Scalar = [u8; 0usize];
pub const Large: Eigen__bindgen_ty_3 = 2;
pub const Small: Eigen__bindgen_ty_3 = 3;
pub type Eigen__bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Solve<Decomposition, RhsType> {
    pub m_dec: *const Decomposition,
    pub m_rhs: *const RhsType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Decomposition>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<RhsType>>,
}
pub type Eigen_Solve_PlainObject = Eigen_internal_traits;
pub type Eigen_Solve_StorageIndex = Eigen_internal_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SolveImpl {
    pub _address: u8,
}
pub type Eigen_SolveImpl_Base = Eigen_internal_generic_xpr_base;
#[doc = " \\class Inverse\n\n \\brief Expression of the inverse of another expression\n\n \\tparam XprType the type of the expression we are taking the inverse\n\n This class represents an abstract expression of A.inverse()\n and most of the time this is the only way it is used.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Inverse {
    pub m_xpr: Eigen_Inverse_XprTypeNested,
}
pub type Eigen_Inverse_StorageIndex = [u8; 0usize];
pub type Eigen_Inverse_PlainObject = [u8; 0usize];
pub type Eigen_Inverse_Scalar = [u8; 0usize];
pub type Eigen_Inverse_XprTypeNested = Eigen_internal_ref_selector;
pub type Eigen_Inverse_XprTypeNestedCleaned = Eigen_internal_remove_all;
pub type Eigen_Inverse_Nested = Eigen_internal_ref_selector;
pub type Eigen_Inverse_NestedExpression = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_InverseImpl {
    pub _address: u8,
}
pub type Eigen_InverseImpl_Base = Eigen_internal_generic_xpr_base;
pub type Eigen_InverseImpl_Scalar = [u8; 0usize];
#[doc = " \\class SolverBase\n \\brief A base class for matrix decomposition and solvers\n\n \\tparam Derived the actual type of the decomposition/solver.\n\n Any matrix decomposition inheriting this base class provide the following API:\n\n \\code\n MatrixType A, b, x;\n DecompositionType dec(A);\n x = dec.solve(b);             // solve A   * x = b\n x = dec.transpose().solve(b); // solve A^T * x = b\n x = dec.adjoint().solve(b);   // solve A'  * x = b\n \\endcode\n\n \\warning Currently, any other usage of transpose() and adjoint() are not supported and will produce compilation errors.\n\n \\sa class PartialPivLU, class FullPivLU"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_SolverBase {
    pub _address: u8,
}
#[doc = " \\class EigenBase\n \\ingroup Core_Module\n\n Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor MatrixBase(T).\n\n In other words, an EigenBase object is an object that can be copied into a MatrixBase.\n\n Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal matrices, etc.\n\n Notice that this class is trivial, it is only used to disambiguate overloaded functions.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_SolverBase_Base = Eigen_EigenBase;
pub type Eigen_SolverBase_Scalar = Eigen_internal_traits;
pub type Eigen_SolverBase_CoeffReturnType = Eigen_SolverBase_Scalar;
pub const Eigen_SolverBase_RowsAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_ColsAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_SizeAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_MaxRowsAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_MaxColsAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_MaxSizeAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub const Eigen_SolverBase_IsVectorAtCompileTime: Eigen_SolverBase__bindgen_ty_1 = 0;
pub type Eigen_SolverBase__bindgen_ty_1 = i32;
#[doc = " \\internal the return type of transpose()"]
pub type Eigen_SolverBase_ConstTransposeReturnType = Eigen_internal_add_const;
#[doc = " \\internal the return type of adjoint()"]
pub type Eigen_SolverBase_AdjointReturnType = u8;
#[doc = " \\class PermutationBase\n \\ingroup Core_Module\n\n \\brief Base class for permutations\n\n \\tparam Derived the derived class\n\n This class is the base class for all expressions representing a permutation matrix,\n internally stored as a vector of integers.\n The convention followed here is that if \\f$ \\sigma \\f$ is a permutation, the corresponding permutation matrix\n \\f$ P_\\sigma \\f$ is such that if \\f$ (e_1,\\ldots,e_p) \\f$ is the canonical basis, we have:\n  \\f[ P_\\sigma(e_i) = e_{\\sigma(i)}. \\f]\n This convention ensures that for any two permutations \\f$ \\sigma, \\tau \\f$, we have:\n  \\f[ P_{\\sigma\\circ\\tau} = P_\\sigma P_\\tau. \\f]\n\n Permutation matrices are square and invertible.\n\n Notice that in addition to the member functions and operators listed here, there also are non-member\n operator* to multiply any kind of permutation object with any kind of matrix expression (MatrixBase)\n on either side.\n\n \\sa class PermutationMatrix, class PermutationWrapper"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PermutationBase {
    pub _address: u8,
}
pub type Eigen_PermutationBase_Traits = Eigen_internal_traits;
#[doc = " \\class EigenBase\n \\ingroup Core_Module\n\n Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor MatrixBase(T).\n\n In other words, an EigenBase object is an object that can be copied into a MatrixBase.\n\n Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal matrices, etc.\n\n Notice that this class is trivial, it is only used to disambiguate overloaded functions.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_PermutationBase_Base = Eigen_EigenBase;
pub type Eigen_PermutationBase_IndicesType = Eigen_PermutationBase_Traits;
pub const Eigen_PermutationBase_Flags: Eigen_PermutationBase__bindgen_ty_1 = 0;
pub const Eigen_PermutationBase_RowsAtCompileTime: Eigen_PermutationBase__bindgen_ty_1 = 0;
pub const Eigen_PermutationBase_ColsAtCompileTime: Eigen_PermutationBase__bindgen_ty_1 = 0;
pub const Eigen_PermutationBase_MaxRowsAtCompileTime: Eigen_PermutationBase__bindgen_ty_1 = 0;
pub const Eigen_PermutationBase_MaxColsAtCompileTime: Eigen_PermutationBase__bindgen_ty_1 = 0;
pub type Eigen_PermutationBase__bindgen_ty_1 = i32;
pub type Eigen_PermutationBase_StorageIndex = Eigen_PermutationBase_Traits;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_PermutationBase_DenseMatrixType = u8;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_PermutationBase_PlainPermutationType = u8;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_PermutationBase_PlainObject = Eigen_PermutationBase_PlainPermutationType;
#[doc = " \\class Inverse\n\n \\brief Expression of the inverse of another expression\n\n \\tparam XprType the type of the expression we are taking the inverse\n\n This class represents an abstract expression of A.inverse()\n and most of the time this is the only way it is used.\n"]
pub type Eigen_PermutationBase_InverseReturnType = Eigen_Inverse;
pub type Eigen_PermutationBase_Scalar = ::std::os::raw::c_void;
#[doc = " \\class PermutationBase\n \\ingroup Core_Module\n\n \\brief Base class for permutations\n\n \\tparam Derived the derived class\n\n This class is the base class for all expressions representing a permutation matrix,\n internally stored as a vector of integers.\n The convention followed here is that if \\f$ \\sigma \\f$ is a permutation, the corresponding permutation matrix\n \\f$ P_\\sigma \\f$ is such that if \\f$ (e_1,\\ldots,e_p) \\f$ is the canonical basis, we have:\n  \\f[ P_\\sigma(e_i) = e_{\\sigma(i)}. \\f]\n This convention ensures that for any two permutations \\f$ \\sigma, \\tau \\f$, we have:\n  \\f[ P_{\\sigma\\circ\\tau} = P_\\sigma P_\\tau. \\f]\n\n Permutation matrices are square and invertible.\n\n Notice that in addition to the member functions and operators listed here, there also are non-member\n operator* to multiply any kind of permutation object with any kind of matrix expression (MatrixBase)\n on either side.\n\n \\sa class PermutationMatrix, class PermutationWrapper"]
pub type Eigen_PermutationMatrix_Base = Eigen_PermutationBase;
pub type Eigen_PermutationMatrix_Traits = Eigen_internal_traits;
pub type Eigen_PermutationMatrix_Nested = *const u8;
pub type Eigen_PermutationMatrix_IndicesType = Eigen_PermutationMatrix_Traits;
pub type Eigen_PermutationMatrix_StorageIndex = Eigen_PermutationMatrix_Traits;
#[doc = " \\class PermutationWrapper\n \\ingroup Core_Module\n\n \\brief Class to view a vector of integers as a permutation matrix\n\n \\tparam _IndicesType the type of the vector of integer (can be any compatible expression)\n\n This class allows to view any vector expression of integers as a permutation matrix.\n\n \\sa class PermutationBase, class PermutationMatrix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PermutationWrapper {
    pub m_indices: Eigen_PermutationWrapper_IndicesType,
}
#[doc = " \\class PermutationBase\n \\ingroup Core_Module\n\n \\brief Base class for permutations\n\n \\tparam Derived the derived class\n\n This class is the base class for all expressions representing a permutation matrix,\n internally stored as a vector of integers.\n The convention followed here is that if \\f$ \\sigma \\f$ is a permutation, the corresponding permutation matrix\n \\f$ P_\\sigma \\f$ is such that if \\f$ (e_1,\\ldots,e_p) \\f$ is the canonical basis, we have:\n  \\f[ P_\\sigma(e_i) = e_{\\sigma(i)}. \\f]\n This convention ensures that for any two permutations \\f$ \\sigma, \\tau \\f$, we have:\n  \\f[ P_{\\sigma\\circ\\tau} = P_\\sigma P_\\tau. \\f]\n\n Permutation matrices are square and invertible.\n\n Notice that in addition to the member functions and operators listed here, there also are non-member\n operator* to multiply any kind of permutation object with any kind of matrix expression (MatrixBase)\n on either side.\n\n \\sa class PermutationMatrix, class PermutationWrapper"]
pub type Eigen_PermutationWrapper_Base = Eigen_PermutationBase;
pub type Eigen_PermutationWrapper_Traits = Eigen_internal_traits;
pub type Eigen_PermutationWrapper_IndicesType = Eigen_PermutationWrapper_Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TranspositionsBase {
    pub _address: u8,
}
pub type Eigen_TranspositionsBase_Traits = Eigen_internal_traits;
pub type Eigen_TranspositionsBase_IndicesType = Eigen_TranspositionsBase_Traits;
pub type Eigen_TranspositionsBase_StorageIndex = Eigen_TranspositionsBase_IndicesType;
pub type Eigen_TranspositionsBase_Index = Eigen_Index;
pub type Eigen_Transpositions_Traits = Eigen_internal_traits;
pub type Eigen_Transpositions_Base = Eigen_TranspositionsBase;
pub type Eigen_Transpositions_IndicesType = Eigen_Transpositions_Traits;
pub type Eigen_Transpositions_StorageIndex = Eigen_Transpositions_IndicesType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TranspositionsWrapper {
    pub m_indices: Eigen_TranspositionsWrapper_IndicesType,
}
pub type Eigen_TranspositionsWrapper_Traits = Eigen_internal_traits;
pub type Eigen_TranspositionsWrapper_Base = Eigen_TranspositionsBase;
pub type Eigen_TranspositionsWrapper_IndicesType = Eigen_TranspositionsWrapper_Traits;
pub type Eigen_TranspositionsWrapper_StorageIndex = Eigen_TranspositionsWrapper_IndicesType;
#[doc = " \\class TriangularBase\n \\ingroup Core_Module\n\n \\brief Base class for triangular part in a matrix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_TriangularBase {
    pub _address: u8,
}
pub const Eigen_TriangularBase_Mode: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_RowsAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_ColsAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_MaxRowsAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_MaxColsAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_SizeAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub const Eigen_TriangularBase_MaxSizeAtCompileTime: Eigen_TriangularBase__bindgen_ty_1 = 0;
pub type Eigen_TriangularBase__bindgen_ty_1 = i32;
pub type Eigen_TriangularBase_Scalar = Eigen_internal_traits;
pub type Eigen_TriangularBase_StorageKind = Eigen_internal_traits;
pub type Eigen_TriangularBase_StorageIndex = Eigen_internal_traits;
pub type Eigen_TriangularBase_DenseMatrixType = Eigen_internal_traits;
pub type Eigen_TriangularBase_DenseType = Eigen_TriangularBase_DenseMatrixType;
pub type Eigen_TriangularBase_Nested<Derived> = *const Derived;
pub type Eigen_TriangularView_Base = u8;
pub type Eigen_TriangularView_Scalar = Eigen_internal_traits;
pub type Eigen_TriangularView_MatrixType<_MatrixType> = _MatrixType;
pub type Eigen_TriangularView_MatrixTypeNested = Eigen_internal_traits;
pub type Eigen_TriangularView_MatrixTypeNestedNonRef = Eigen_internal_traits;
pub type Eigen_TriangularView_MatrixConjugateReturnType = [u8; 0usize];
pub type Eigen_TriangularView_StorageKind = Eigen_internal_traits;
pub type Eigen_TriangularView_NestedExpression = Eigen_internal_traits;
pub const Eigen_TriangularView_Mode: Eigen_TriangularView__bindgen_ty_1 = 0;
pub const Eigen_TriangularView_Flags: Eigen_TriangularView__bindgen_ty_1 = 0;
pub const Eigen_TriangularView_TransposeMode: Eigen_TriangularView__bindgen_ty_1 = 0;
pub const Eigen_TriangularView_IsVectorAtCompileTime: Eigen_TriangularView__bindgen_ty_1 = 0;
pub type Eigen_TriangularView__bindgen_ty_1 = i32;
pub type Eigen_TriangularView_ConjugateReturnType = u8;
pub type Eigen_TriangularView_AdjointReturnType = u8;
pub type Eigen_TriangularView_TransposeReturnType = u8;
pub type Eigen_TriangularView_ConstTransposeReturnType = u8;
pub type Eigen_SelfAdjointView_MatrixType<_MatrixType> = _MatrixType;
#[doc = " \\class TriangularBase\n \\ingroup Core_Module\n\n \\brief Base class for triangular part in a matrix"]
pub type Eigen_SelfAdjointView_Base = Eigen_TriangularBase;
pub type Eigen_SelfAdjointView_MatrixTypeNested = Eigen_internal_traits;
pub type Eigen_SelfAdjointView_MatrixTypeNestedCleaned = Eigen_internal_traits;
pub type Eigen_SelfAdjointView_NestedExpression = Eigen_SelfAdjointView_MatrixTypeNestedCleaned;
#[doc = " \\brief The type of coefficients in this matrix"]
pub type Eigen_SelfAdjointView_Scalar = Eigen_internal_traits;
pub type Eigen_SelfAdjointView_StorageIndex = [u8; 0usize];
pub type Eigen_SelfAdjointView_MatrixConjugateReturnType = [u8; 0usize];
pub const Eigen_SelfAdjointView_Mode: Eigen_SelfAdjointView__bindgen_ty_1 = 0;
pub const Eigen_SelfAdjointView_Flags: Eigen_SelfAdjointView__bindgen_ty_1 = 0;
pub const Eigen_SelfAdjointView_TransposeMode: Eigen_SelfAdjointView__bindgen_ty_1 = 0;
pub type Eigen_SelfAdjointView__bindgen_ty_1 = i32;
pub type Eigen_SelfAdjointView_PlainObject = [u8; 0usize];
pub type Eigen_SelfAdjointView_ConjugateReturnType = u8;
pub type Eigen_SelfAdjointView_AdjointReturnType = u8;
pub type Eigen_SelfAdjointView_TransposeReturnType = u8;
pub type Eigen_SelfAdjointView_ConstTransposeReturnType = u8;
#[doc = " Real part of #Scalar"]
pub type Eigen_SelfAdjointView_RealScalar = Eigen_NumTraits;
#[doc = " Return type of eigenvalues()"]
pub type Eigen_SelfAdjointView_EigenvaluesReturnType = u8;
#[doc = " \\class InnerIterator\n \\brief An InnerIterator allows to loop over the element of any matrix expression.\n\n \\warning To be used with care because an evaluator is constructed every time an InnerIterator iterator is constructed.\n\n TODO: add a usage example"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_InnerIterator {
    pub m_eval: Eigen_InnerIterator_EvaluatorType,
    pub m_iter: Eigen_InnerIterator_IteratorType,
}
pub type Eigen_InnerIterator_IteratorType = Eigen_internal_inner_iterator_selector;
pub type Eigen_InnerIterator_EvaluatorType = Eigen_internal_evaluator;
pub type Eigen_InnerIterator_Scalar = Eigen_internal_traits;
#[repr(C)]
pub struct Eigen_Select {
    pub m_condition: [u8; 0usize],
    pub m_then: [u8; 0usize],
    pub m_else: [u8; 0usize],
}
pub type Eigen_Select_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_Select_Scalar = Eigen_internal_traits;
pub type Eigen_Select_RealScalar = Eigen_NumTraits;
pub type Eigen_Select_CoeffReturnType = Eigen_Select_Base;
pub type Eigen_Select_Nested = Eigen_internal_ref_selector;
pub type Eigen_Select_StorageKind = Eigen_internal_traits;
pub type Eigen_Select_StorageIndex = Eigen_internal_traits;
pub const Eigen_Select_RowsAtCompileTime: Eigen_Select__bindgen_ty_1 = 0;
pub const Eigen_Select_ColsAtCompileTime: Eigen_Select__bindgen_ty_1 = 0;
pub const Eigen_Select_Flags: Eigen_Select__bindgen_ty_1 = 0;
pub const Eigen_Select_SizeAtCompileTime: Eigen_Select__bindgen_ty_1 = 0;
pub const Eigen_Select_MaxSizeAtCompileTime: Eigen_Select__bindgen_ty_1 = 0;
pub const Eigen_Select_IsVectorAtCompileTime: Eigen_Select__bindgen_ty_1 = 0;
pub type Eigen_Select__bindgen_ty_1 = i32;
pub type Eigen_Select_PacketScalar = Eigen_Select_Base;
pub type Eigen_PartialReduxExpr_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_PartialReduxExpr_Scalar = Eigen_internal_traits;
pub type Eigen_PartialReduxExpr_RealScalar = Eigen_NumTraits;
pub type Eigen_PartialReduxExpr_CoeffReturnType = Eigen_PartialReduxExpr_Base;
pub type Eigen_PartialReduxExpr_Nested = Eigen_internal_ref_selector;
pub type Eigen_PartialReduxExpr_StorageKind = Eigen_internal_traits;
pub type Eigen_PartialReduxExpr_StorageIndex = Eigen_internal_traits;
pub const Eigen_PartialReduxExpr_RowsAtCompileTime: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub const Eigen_PartialReduxExpr_ColsAtCompileTime: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub const Eigen_PartialReduxExpr_Flags: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub const Eigen_PartialReduxExpr_SizeAtCompileTime: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub const Eigen_PartialReduxExpr_MaxSizeAtCompileTime: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub const Eigen_PartialReduxExpr_IsVectorAtCompileTime: Eigen_PartialReduxExpr__bindgen_ty_1 = 0;
pub type Eigen_PartialReduxExpr__bindgen_ty_1 = i32;
pub type Eigen_PartialReduxExpr_PacketScalar = Eigen_PartialReduxExpr_Base;
pub type Eigen_VectorwiseOp_Scalar = [u8; 0usize];
pub type Eigen_VectorwiseOp_RealScalar = [u8; 0usize];
pub type Eigen_VectorwiseOp_Index = Eigen_Index;
pub type Eigen_VectorwiseOp_ExpressionTypeNested = Eigen_internal_ref_selector;
pub type Eigen_VectorwiseOp_ExpressionTypeNestedCleaned = Eigen_internal_remove_all;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_VectorwiseOp_ReturnType {
    pub _address: u8,
}
#[doc = " \\class PartialReduxExpr\n \\ingroup Core_Module\n\n \\brief Generic expression of a partially reduxed matrix\n\n \\tparam MatrixType the type of the matrix we are applying the redux operation\n \\tparam MemberOp type of the member functor\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents an expression of a partial redux operator of a matrix.\n It is the return type of some VectorwiseOp functions,\n and most of the time this is the only way it is used.\n\n \\sa class VectorwiseOp"]
pub type Eigen_VectorwiseOp_ReturnType_Type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_VectorwiseOp_ReduxReturnType {
    pub _address: u8,
}
#[doc = " \\class PartialReduxExpr\n \\ingroup Core_Module\n\n \\brief Generic expression of a partially reduxed matrix\n\n \\tparam MatrixType the type of the matrix we are applying the redux operation\n \\tparam MemberOp type of the member functor\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents an expression of a partial redux operator of a matrix.\n It is the return type of some VectorwiseOp functions,\n and most of the time this is the only way it is used.\n\n \\sa class VectorwiseOp"]
pub type Eigen_VectorwiseOp_ReduxReturnType_Type = u8;
pub const Eigen_VectorwiseOp_isVertical: Eigen_VectorwiseOp__bindgen_ty_1 = 0;
pub const Eigen_VectorwiseOp_isHorizontal: Eigen_VectorwiseOp__bindgen_ty_1 = 0;
pub type Eigen_VectorwiseOp__bindgen_ty_1 = i32;
pub type Eigen_VectorwiseOp_SubVector = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_VectorwiseOp_ExtendedType {
    pub _address: u8,
}
#[doc = " \\class Replicate\n \\ingroup Core_Module\n\n \\brief Expression of the multiple replication of a matrix or vector\n\n \\tparam MatrixType the type of the object we are replicating\n \\tparam RowFactor number of repetitions at compile time along the vertical direction, can be Dynamic.\n \\tparam ColFactor number of repetitions at compile time along the horizontal direction, can be Dynamic.\n\n This class represents an expression of the multiple replication of a matrix or vector.\n It is the return type of DenseBase::replicate() and most of the time\n this is the only way it is used.\n\n \\sa DenseBase::replicate()"]
pub type Eigen_VectorwiseOp_ExtendedType_Type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_VectorwiseOp_OppositeExtendedType {
    pub _address: u8,
}
#[doc = " \\class Replicate\n \\ingroup Core_Module\n\n \\brief Expression of the multiple replication of a matrix or vector\n\n \\tparam MatrixType the type of the object we are replicating\n \\tparam RowFactor number of repetitions at compile time along the vertical direction, can be Dynamic.\n \\tparam ColFactor number of repetitions at compile time along the horizontal direction, can be Dynamic.\n\n This class represents an expression of the multiple replication of a matrix or vector.\n It is the return type of DenseBase::replicate() and most of the time\n this is the only way it is used.\n\n \\sa DenseBase::replicate()"]
pub type Eigen_VectorwiseOp_OppositeExtendedType_Type = u8;
pub type Eigen_VectorwiseOp_MinCoeffReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_MaxCoeffReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_SquaredNormReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_NormReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_BlueNormReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_StableNormReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_HypotNormReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_SumReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_MeanReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_AllReturnType = [u8; 0usize];
pub type Eigen_VectorwiseOp_AnyReturnType = [u8; 0usize];
#[doc = " \\class PartialReduxExpr\n \\ingroup Core_Module\n\n \\brief Generic expression of a partially reduxed matrix\n\n \\tparam MatrixType the type of the matrix we are applying the redux operation\n \\tparam MemberOp type of the member functor\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents an expression of a partial redux operator of a matrix.\n It is the return type of some VectorwiseOp functions,\n and most of the time this is the only way it is used.\n\n \\sa class VectorwiseOp"]
pub type Eigen_VectorwiseOp_CountReturnType = u8;
pub type Eigen_VectorwiseOp_ProdReturnType = [u8; 0usize];
#[doc = " \\class Reverse\n \\ingroup Core_Module\n\n \\brief Expression of the reverse of a vector or matrix\n\n \\tparam MatrixType the type of the object of which we are taking the reverse\n \\tparam Direction defines the direction of the reverse operation, can be Vertical, Horizontal, or BothDirections\n\n This class represents an expression of the reverse of a vector.\n It is the return type of MatrixBase::reverse() and VectorwiseOp::reverse()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::reverse(), VectorwiseOp::reverse()"]
pub type Eigen_VectorwiseOp_ConstReverseReturnType = u8;
#[doc = " \\class Reverse\n \\ingroup Core_Module\n\n \\brief Expression of the reverse of a vector or matrix\n\n \\tparam MatrixType the type of the object of which we are taking the reverse\n \\tparam Direction defines the direction of the reverse operation, can be Vertical, Horizontal, or BothDirections\n\n This class represents an expression of the reverse of a vector.\n It is the return type of MatrixBase::reverse() and VectorwiseOp::reverse()\n and most of the time this is the only way it is used.\n\n \\sa MatrixBase::reverse(), VectorwiseOp::reverse()"]
pub type Eigen_VectorwiseOp_ReverseReturnType = u8;
#[doc = " \\class PartialReduxExpr\n \\ingroup Core_Module\n\n \\brief Generic expression of a partially reduxed matrix\n\n \\tparam MatrixType the type of the matrix we are applying the redux operation\n \\tparam MemberOp type of the member functor\n \\tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)\n\n This class represents an expression of a partial redux operator of a matrix.\n It is the return type of some VectorwiseOp functions,\n and most of the time this is the only way it is used.\n\n \\sa class VectorwiseOp"]
pub type Eigen_VectorwiseOp_LpNormReturnType_Type = u8;
#[doc = " \\class Replicate\n \\ingroup Core_Module\n\n \\brief Expression of the multiple replication of a matrix or vector\n\n \\tparam MatrixType the type of the object we are replicating\n \\tparam RowFactor number of repetitions at compile time along the vertical direction, can be Dynamic.\n \\tparam ColFactor number of repetitions at compile time along the horizontal direction, can be Dynamic.\n\n This class represents an expression of the multiple replication of a matrix or vector.\n It is the return type of DenseBase::replicate() and most of the time\n this is the only way it is used.\n\n \\sa DenseBase::replicate()"]
pub type Eigen_VectorwiseOp_ReplicateReturnType = u8;
#[doc = " Geometry module ///////////"]
pub type Eigen_VectorwiseOp_HomogeneousReturnType = u8;
pub type Eigen_VectorwiseOp_CrossReturnType = [u8; 0usize];
pub const Eigen_VectorwiseOp_HNormalized_Size: Eigen_VectorwiseOp__bindgen_ty_2 = 0;
pub const Eigen_VectorwiseOp_HNormalized_SizeMinusOne: Eigen_VectorwiseOp__bindgen_ty_2 = 0;
pub type Eigen_VectorwiseOp__bindgen_ty_2 = i32;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_VectorwiseOp_HNormalized_Block = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_VectorwiseOp_HNormalized_Factors = u8;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_VectorwiseOp_HNormalizedReturnType = Eigen_CwiseBinaryOp<BinaryOp>;
pub type Eigen_Replicate_MatrixTypeNested = Eigen_internal_traits;
pub type Eigen_Replicate__MatrixTypeNested = Eigen_internal_traits;
pub type Eigen_Replicate_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_Replicate_Scalar = Eigen_internal_traits;
pub type Eigen_Replicate_RealScalar = Eigen_NumTraits;
pub type Eigen_Replicate_CoeffReturnType = Eigen_Replicate_Base;
pub type Eigen_Replicate_Nested = Eigen_internal_ref_selector;
pub type Eigen_Replicate_StorageKind = Eigen_internal_traits;
pub type Eigen_Replicate_StorageIndex = Eigen_internal_traits;
pub const Eigen_Replicate_RowsAtCompileTime: Eigen_Replicate__bindgen_ty_1 = 0;
pub const Eigen_Replicate_ColsAtCompileTime: Eigen_Replicate__bindgen_ty_1 = 0;
pub const Eigen_Replicate_Flags: Eigen_Replicate__bindgen_ty_1 = 0;
pub const Eigen_Replicate_SizeAtCompileTime: Eigen_Replicate__bindgen_ty_1 = 0;
pub const Eigen_Replicate_MaxSizeAtCompileTime: Eigen_Replicate__bindgen_ty_1 = 0;
pub const Eigen_Replicate_IsVectorAtCompileTime: Eigen_Replicate__bindgen_ty_1 = 0;
pub type Eigen_Replicate__bindgen_ty_1 = i32;
pub type Eigen_Replicate_PacketScalar = Eigen_Replicate_Base;
pub type Eigen_Replicate_NestedExpression = Eigen_internal_remove_all;
pub type Eigen_Reverse_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_Reverse_Scalar = Eigen_internal_traits;
pub type Eigen_Reverse_RealScalar = Eigen_NumTraits;
pub type Eigen_Reverse_CoeffReturnType = Eigen_Reverse_Base;
pub type Eigen_Reverse_Nested = Eigen_internal_ref_selector;
pub type Eigen_Reverse_StorageKind = Eigen_internal_traits;
pub type Eigen_Reverse_StorageIndex = Eigen_internal_traits;
pub const Eigen_Reverse_RowsAtCompileTime: Eigen_Reverse__bindgen_ty_1 = 0;
pub const Eigen_Reverse_ColsAtCompileTime: Eigen_Reverse__bindgen_ty_1 = 0;
pub const Eigen_Reverse_Flags: Eigen_Reverse__bindgen_ty_1 = 0;
pub const Eigen_Reverse_SizeAtCompileTime: Eigen_Reverse__bindgen_ty_1 = 0;
pub const Eigen_Reverse_MaxSizeAtCompileTime: Eigen_Reverse__bindgen_ty_1 = 0;
pub const Eigen_Reverse_IsVectorAtCompileTime: Eigen_Reverse__bindgen_ty_1 = 0;
pub type Eigen_Reverse__bindgen_ty_1 = i32;
pub type Eigen_Reverse_PacketScalar = Eigen_Reverse_Base;
pub type Eigen_Reverse_NestedExpression = Eigen_internal_remove_all;
pub const Eigen_Reverse_PacketSize: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_IsColMajor: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_ReverseRow: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_ReverseCol: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_OffsetRow: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_OffsetCol: Eigen_Reverse__bindgen_ty_2 = 0;
pub const Eigen_Reverse_ReversePacket: Eigen_Reverse__bindgen_ty_2 = 0;
pub type Eigen_Reverse__bindgen_ty_2 = i32;
pub type Eigen_Reverse_reverse_packet = u8;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_ArrayWrapper {
    pub m_expression: Eigen_ArrayWrapper_NestedExpressionType,
}
#[doc = " \\class ArrayBase\n \\ingroup Core_Module\n\n \\brief Base class for all 1D and 2D array, and related expressions\n\n An array is similar to a dense vector or matrix. While matrices are mathematical\n objects with well defined linear algebra operators, an array is just a collection\n of scalar values arranged in a one or two dimensionnal fashion. As the main consequence,\n all operations applied to an array are performed coefficient wise. Furthermore,\n arrays support scalar math functions of the c++ standard library (e.g., std::sin(x)), and convenient\n constructors allowing to easily write generic code working for both scalar values\n and arrays.\n\n This class is the base that is inherited by all array expression types.\n\n \\tparam Derived is the derived type, e.g., an array or an expression type.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAYBASE_PLUGIN.\n\n \\sa class MatrixBase, \\ref TopicClassHierarchy"]
pub type Eigen_ArrayWrapper_Base = Eigen_ArrayBase;
pub type Eigen_ArrayWrapper_Scalar = Eigen_internal_traits;
pub type Eigen_ArrayWrapper_RealScalar = Eigen_NumTraits;
pub type Eigen_ArrayWrapper_CoeffReturnType = Eigen_ArrayWrapper_Base;
pub type Eigen_ArrayWrapper_Nested = Eigen_internal_ref_selector;
pub type Eigen_ArrayWrapper_StorageKind = Eigen_internal_traits;
pub type Eigen_ArrayWrapper_StorageIndex = Eigen_internal_traits;
pub const Eigen_ArrayWrapper_RowsAtCompileTime: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub const Eigen_ArrayWrapper_ColsAtCompileTime: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub const Eigen_ArrayWrapper_Flags: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub const Eigen_ArrayWrapper_SizeAtCompileTime: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub const Eigen_ArrayWrapper_MaxSizeAtCompileTime: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub const Eigen_ArrayWrapper_IsVectorAtCompileTime: Eigen_ArrayWrapper__bindgen_ty_1 = 0;
pub type Eigen_ArrayWrapper__bindgen_ty_1 = i32;
pub type Eigen_ArrayWrapper_PacketScalar = Eigen_ArrayWrapper_Base;
pub type Eigen_ArrayWrapper_NestedExpression = Eigen_internal_remove_all;
pub type Eigen_ArrayWrapper_ScalarWithConstIfNotLvalue = u8;
pub type Eigen_ArrayWrapper_NestedExpressionType = Eigen_internal_ref_selector;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_MatrixWrapper {
    pub m_expression: Eigen_MatrixWrapper_NestedExpressionType,
}
#[doc = " \\class MatrixBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and expressions\n\n This class is the base that is inherited by all matrix, vector, and related expression\n types. Most of the Eigen API is contained in this class, and its base classes. Other important\n classes for the Eigen API are Matrix, and VectorwiseOp.\n\n Note that some methods are defined in other modules such as the \\ref LU_Module LU module\n for all functions related to matrix inversions.\n\n \\tparam Derived is the derived type, e.g. a matrix type, or an expression, etc.\n\n When writing a function taking Eigen objects as argument, if you want your function\n to take as argument any matrix, vector, or expression, just let it take a\n MatrixBase argument. As an example, here is a function printFirstRow which, given\n a matrix, vector, or expression \\a x, prints the first row of \\a x.\n\n \\code\ntemplate<typename Derived>\nvoid printFirstRow(const Eigen::MatrixBase<Derived>& x)\n{\ncout << x.row(0) << endl;\n}\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIXBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_MatrixWrapper_Base = Eigen_MatrixBase;
pub type Eigen_MatrixWrapper_Scalar = Eigen_internal_traits;
pub type Eigen_MatrixWrapper_RealScalar = Eigen_NumTraits;
pub type Eigen_MatrixWrapper_CoeffReturnType = Eigen_MatrixWrapper_Base;
pub type Eigen_MatrixWrapper_Nested = Eigen_internal_ref_selector;
pub type Eigen_MatrixWrapper_StorageKind = Eigen_internal_traits;
pub type Eigen_MatrixWrapper_StorageIndex = Eigen_internal_traits;
pub const Eigen_MatrixWrapper_RowsAtCompileTime: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub const Eigen_MatrixWrapper_ColsAtCompileTime: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub const Eigen_MatrixWrapper_Flags: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub const Eigen_MatrixWrapper_SizeAtCompileTime: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub const Eigen_MatrixWrapper_MaxSizeAtCompileTime: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub const Eigen_MatrixWrapper_IsVectorAtCompileTime: Eigen_MatrixWrapper__bindgen_ty_1 = 0;
pub type Eigen_MatrixWrapper__bindgen_ty_1 = i32;
pub type Eigen_MatrixWrapper_PacketScalar = Eigen_MatrixWrapper_Base;
pub type Eigen_MatrixWrapper_NestedExpression = Eigen_internal_remove_all;
pub type Eigen_MatrixWrapper_ScalarWithConstIfNotLvalue = u8;
pub type Eigen_MatrixWrapper_NestedExpressionType = Eigen_internal_ref_selector;
#[doc = " \\ingroup Jacobi_Module\n \\jacobi_module\n \\class JacobiRotation\n \\brief Rotation given by a cosine-sine pair.\n\n This class represents a Jacobi or Givens rotation.\n This is a 2D rotation in the plane \\c J of angle \\f$ \\theta \\f$ defined by\n its cosine \\c c and sine \\c s as follow:\n \\f$ J = \\left ( \\begin{array}{cc} c & \\overline s \\\\ -s  & \\overline c \\end{array} \\right ) \\f$\n\n You can apply the respective counter-clockwise rotation to a column vector \\c v by\n applying its adjoint on the left: \\f$ v = J^* v \\f$ that translates to the following Eigen code:\n \\code\n v.applyOnTheLeft(J.adjoint());\n \\endcode\n\n \\sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_JacobiRotation<Scalar> {
    pub m_c: Scalar,
    pub m_s: Scalar,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Scalar>>,
}
pub type Eigen_JacobiRotation_RealScalar = Eigen_NumTraits;
pub type Eigen_LLT_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_LLT_RowsAtCompileTime: Eigen_LLT__bindgen_ty_1 = 0;
pub const Eigen_LLT_ColsAtCompileTime: Eigen_LLT__bindgen_ty_1 = 0;
pub const Eigen_LLT_MaxColsAtCompileTime: Eigen_LLT__bindgen_ty_1 = 0;
pub type Eigen_LLT__bindgen_ty_1 = i32;
pub type Eigen_LLT_Scalar = [u8; 0usize];
pub type Eigen_LLT_RealScalar = [u8; 0usize];
pub type Eigen_LLT_Index = Eigen_Index;
pub type Eigen_LLT_StorageIndex = [u8; 0usize];
pub const Eigen_LLT_PacketSize: Eigen_LLT__bindgen_ty_2 = 0;
pub const Eigen_LLT_AlignmentMask: Eigen_LLT__bindgen_ty_2 = 0;
pub const Eigen_LLT_UpLo: Eigen_LLT__bindgen_ty_2 = 0;
pub type Eigen_LLT__bindgen_ty_2 = i32;
pub type Eigen_LLT_Traits = u8;
pub type Eigen_LDLT_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_LDLT_RowsAtCompileTime: Eigen_LDLT__bindgen_ty_1 = 0;
pub const Eigen_LDLT_ColsAtCompileTime: Eigen_LDLT__bindgen_ty_1 = 0;
pub const Eigen_LDLT_MaxRowsAtCompileTime: Eigen_LDLT__bindgen_ty_1 = 0;
pub const Eigen_LDLT_MaxColsAtCompileTime: Eigen_LDLT__bindgen_ty_1 = 0;
pub const Eigen_LDLT_UpLo: Eigen_LDLT__bindgen_ty_1 = 0;
pub type Eigen_LDLT__bindgen_ty_1 = i32;
pub type Eigen_LDLT_Scalar = [u8; 0usize];
pub type Eigen_LDLT_RealScalar = [u8; 0usize];
pub type Eigen_LDLT_Index = Eigen_Index;
pub type Eigen_LDLT_StorageIndex = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_LDLT_TmpMatrixType = u8;
#[doc = " \\class Transpositions\n \\ingroup Core_Module\n\n \\brief Represents a sequence of transpositions (row/column interchange)\n\n \\tparam SizeAtCompileTime the number of transpositions, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of transpositions, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n\n This class represents a permutation transformation as a sequence of \\em n transpositions\n \\f$[T_{n-1} \\ldots T_{i} \\ldots T_{0}]\\f$. It is internally stored as a vector of integers \\c indices.\n Each transposition \\f$ T_{i} \\f$ applied on the left of a matrix (\\f$ T_{i} M\\f$) interchanges\n the rows \\c i and \\c indices[i] of the matrix \\c M.\n A transposition applied on the right (e.g., \\f$ M T_{i}\\f$) yields a column interchange.\n\n Compared to the class PermutationMatrix, such a sequence of transpositions is what is\n computed during a decomposition with pivoting, and it is faster when applying the permutation in-place.\n\n To apply a sequence of transpositions to a matrix, simply use the operator * as in the following example:\n \\code\n Transpositions tr;\n MatrixXf mat;\n mat = tr * mat;\n \\endcode\n In this example, we detect that the matrix appears on both side, and so the transpositions\n are applied in-place without any temporary or extra copy.\n\n \\sa class PermutationMatrix"]
pub type Eigen_LDLT_TranspositionType = u8;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_LDLT_PermutationType = u8;
pub type Eigen_LDLT_Traits = u8;
pub type Eigen_HouseholderSequence_EssentialVectorType = u8;
pub const Eigen_HouseholderSequence_RowsAtCompileTime: Eigen_HouseholderSequence__bindgen_ty_1 = 0;
pub const Eigen_HouseholderSequence_ColsAtCompileTime: Eigen_HouseholderSequence__bindgen_ty_1 = 0;
pub const Eigen_HouseholderSequence_MaxRowsAtCompileTime: Eigen_HouseholderSequence__bindgen_ty_1 =
    0;
pub const Eigen_HouseholderSequence_MaxColsAtCompileTime: Eigen_HouseholderSequence__bindgen_ty_1 =
    0;
pub type Eigen_HouseholderSequence__bindgen_ty_1 = i32;
pub type Eigen_HouseholderSequence_Scalar = Eigen_internal_traits;
pub type Eigen_HouseholderSequence_ConjugateReturnType = u8;
#[doc = " \\ingroup QR_Module\n\n\n \\class HouseholderQR\n\n \\brief Householder QR decomposition of a matrix\n\n \\tparam _MatrixType the type of the matrix of which we are computing the QR decomposition\n\n This class performs a QR decomposition of a matrix \\b A into matrices \\b Q and \\b R\n such that\n \\f[\n  \\mathbf{A} = \\mathbf{Q} \\, \\mathbf{R}\n \\f]\n by using Householder transformations. Here, \\b Q a unitary matrix and \\b R an upper triangular matrix.\n The result is stored in a compact way compatible with LAPACK.\n\n Note that no pivoting is performed. This is \\b not a rank-revealing decomposition.\n If you want that feature, use FullPivHouseholderQR or ColPivHouseholderQR instead.\n\n This Householder QR decomposition is faster, but less numerically stable and less feature-full than\n FullPivHouseholderQR or ColPivHouseholderQR.\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::householderQr()"]
#[repr(C)]
pub struct Eigen_HouseholderQR<_MatrixType> {
    pub m_qr: Eigen_HouseholderQR_MatrixType<_MatrixType>,
    pub m_hCoeffs: Eigen_HouseholderQR_HCoeffsType,
    pub m_temp: Eigen_HouseholderQR_RowVectorType,
    pub m_isInitialized: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_HouseholderQR_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_HouseholderQR_RowsAtCompileTime: Eigen_HouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_HouseholderQR_ColsAtCompileTime: Eigen_HouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_HouseholderQR_MaxRowsAtCompileTime: Eigen_HouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_HouseholderQR_MaxColsAtCompileTime: Eigen_HouseholderQR__bindgen_ty_1 = 0;
pub type Eigen_HouseholderQR__bindgen_ty_1 = i32;
pub type Eigen_HouseholderQR_Scalar = [u8; 0usize];
pub type Eigen_HouseholderQR_RealScalar = [u8; 0usize];
pub type Eigen_HouseholderQR_StorageIndex = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_HouseholderQR_MatrixQType = u8;
pub type Eigen_HouseholderQR_HCoeffsType = [u8; 0usize];
pub type Eigen_HouseholderQR_RowVectorType = [u8; 0usize];
pub type Eigen_HouseholderQR_HouseholderSequenceType = u8;
#[doc = " \\ingroup QR_Module\n\n \\class FullPivHouseholderQR\n\n \\brief Householder rank-revealing QR decomposition of a matrix with full pivoting\n\n \\tparam _MatrixType the type of the matrix of which we are computing the QR decomposition\n\n This class performs a rank-revealing QR decomposition of a matrix \\b A into matrices \\b P, \\b P', \\b Q and \\b R\n such that\n \\f[\n  \\mathbf{P} \\, \\mathbf{A} \\, \\mathbf{P}' = \\mathbf{Q} \\, \\mathbf{R}\n \\f]\n by using Householder transformations. Here, \\b P and \\b P' are permutation matrices, \\b Q a unitary matrix\n and \\b R an upper triangular matrix.\n\n This decomposition performs a very prudent full pivoting in order to be rank-revealing and achieve optimal\n numerical stability. The trade-off is that it is slower than HouseholderQR and ColPivHouseholderQR.\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::fullPivHouseholderQr()"]
#[repr(C)]
pub struct Eigen_FullPivHouseholderQR<_MatrixType> {
    pub m_qr: Eigen_FullPivHouseholderQR_MatrixType<_MatrixType>,
    pub m_hCoeffs: Eigen_FullPivHouseholderQR_HCoeffsType,
    pub m_rows_transpositions: Eigen_FullPivHouseholderQR_IntDiagSizeVectorType,
    pub m_cols_transpositions: Eigen_FullPivHouseholderQR_IntDiagSizeVectorType,
    pub m_cols_permutation: Eigen_FullPivHouseholderQR_PermutationType,
    pub m_temp: Eigen_FullPivHouseholderQR_RowVectorType,
    pub m_isInitialized: bool,
    pub m_usePrescribedThreshold: bool,
    pub m_prescribedThreshold: Eigen_FullPivHouseholderQR_RealScalar,
    pub m_maxpivot: Eigen_FullPivHouseholderQR_RealScalar,
    pub m_nonzero_pivots: Eigen_Index,
    pub m_precision: Eigen_FullPivHouseholderQR_RealScalar,
    pub m_det_pq: Eigen_Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_FullPivHouseholderQR_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_FullPivHouseholderQR_RowsAtCompileTime: Eigen_FullPivHouseholderQR__bindgen_ty_1 =
    0;
pub const Eigen_FullPivHouseholderQR_ColsAtCompileTime: Eigen_FullPivHouseholderQR__bindgen_ty_1 =
    0;
pub const Eigen_FullPivHouseholderQR_MaxRowsAtCompileTime:
    Eigen_FullPivHouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_FullPivHouseholderQR_MaxColsAtCompileTime:
    Eigen_FullPivHouseholderQR__bindgen_ty_1 = 0;
pub type Eigen_FullPivHouseholderQR__bindgen_ty_1 = i32;
pub type Eigen_FullPivHouseholderQR_Scalar = [u8; 0usize];
pub type Eigen_FullPivHouseholderQR_RealScalar = [u8; 0usize];
pub type Eigen_FullPivHouseholderQR_StorageIndex = [u8; 0usize];
#[doc = " \\ingroup QR_Module\n\n \\brief Expression type for return value of FullPivHouseholderQR::matrixQ()\n\n \\tparam MatrixType type of underlying dense matrix"]
pub type Eigen_FullPivHouseholderQR_MatrixQReturnType =
    Eigen_internal_FullPivHouseholderQRMatrixQReturnType;
pub type Eigen_FullPivHouseholderQR_HCoeffsType = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_FullPivHouseholderQR_IntDiagSizeVectorType = u8;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_FullPivHouseholderQR_PermutationType = u8;
pub type Eigen_FullPivHouseholderQR_RowVectorType = [u8; 0usize];
pub type Eigen_FullPivHouseholderQR_ColVectorType = [u8; 0usize];
pub type Eigen_FullPivHouseholderQR_PlainObject = [u8; 0usize];
#[doc = " \\ingroup QR_Module\n\n \\class ColPivHouseholderQR\n\n \\brief Householder rank-revealing QR decomposition of a matrix with column-pivoting\n\n \\tparam _MatrixType the type of the matrix of which we are computing the QR decomposition\n\n This class performs a rank-revealing QR decomposition of a matrix \\b A into matrices \\b P, \\b Q and \\b R\n such that\n \\f[\n  \\mathbf{A} \\, \\mathbf{P} = \\mathbf{Q} \\, \\mathbf{R}\n \\f]\n by using Householder transformations. Here, \\b P is a permutation matrix, \\b Q a unitary matrix and \\b R an\n upper triangular matrix.\n\n This decomposition performs column pivoting in order to be rank-revealing and improve\n numerical stability. It is slower than HouseholderQR, and faster than FullPivHouseholderQR.\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::colPivHouseholderQr()"]
#[repr(C)]
pub struct Eigen_ColPivHouseholderQR<_MatrixType> {
    pub m_qr: Eigen_ColPivHouseholderQR_MatrixType<_MatrixType>,
    pub m_hCoeffs: Eigen_ColPivHouseholderQR_HCoeffsType,
    pub m_colsPermutation: Eigen_ColPivHouseholderQR_PermutationType,
    pub m_colsTranspositions: Eigen_ColPivHouseholderQR_IntRowVectorType,
    pub m_temp: Eigen_ColPivHouseholderQR_RowVectorType,
    pub m_colNormsUpdated: Eigen_ColPivHouseholderQR_RealRowVectorType,
    pub m_colNormsDirect: Eigen_ColPivHouseholderQR_RealRowVectorType,
    pub m_isInitialized: bool,
    pub m_usePrescribedThreshold: bool,
    pub m_prescribedThreshold: Eigen_ColPivHouseholderQR_RealScalar,
    pub m_maxpivot: Eigen_ColPivHouseholderQR_RealScalar,
    pub m_nonzero_pivots: Eigen_Index,
    pub m_det_pq: Eigen_Index,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_ColPivHouseholderQR_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_ColPivHouseholderQR_RowsAtCompileTime: Eigen_ColPivHouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_ColPivHouseholderQR_ColsAtCompileTime: Eigen_ColPivHouseholderQR__bindgen_ty_1 = 0;
pub const Eigen_ColPivHouseholderQR_MaxRowsAtCompileTime: Eigen_ColPivHouseholderQR__bindgen_ty_1 =
    0;
pub const Eigen_ColPivHouseholderQR_MaxColsAtCompileTime: Eigen_ColPivHouseholderQR__bindgen_ty_1 =
    0;
pub type Eigen_ColPivHouseholderQR__bindgen_ty_1 = i32;
pub type Eigen_ColPivHouseholderQR_Scalar = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_RealScalar = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_StorageIndex = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_HCoeffsType = [u8; 0usize];
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_ColPivHouseholderQR_PermutationType = u8;
pub type Eigen_ColPivHouseholderQR_IntRowVectorType = Eigen_internal_plain_row_type;
pub type Eigen_ColPivHouseholderQR_RowVectorType = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_RealRowVectorType = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_HouseholderSequenceType = u8;
pub type Eigen_ColPivHouseholderQR_PlainObject = [u8; 0usize];
pub type Eigen_ColPivHouseholderQR_PermIndexType = Eigen_ColPivHouseholderQR_PermutationType;
#[doc = " \\ingroup QR_Module\n\n \\class CompleteOrthogonalDecomposition\n\n \\brief Complete orthogonal decomposition (COD) of a matrix.\n\n \\param MatrixType the type of the matrix of which we are computing the COD.\n\n This class performs a rank-revealing complete orthogonal decomposition of a\n matrix  \\b A into matrices \\b P, \\b Q, \\b T, and \\b Z such that\n \\f[\n  \\mathbf{A} \\, \\mathbf{P} = \\mathbf{Q} \\,\n                     \\begin{bmatrix} \\mathbf{T} &  \\mathbf{0} \\\\\n                                     \\mathbf{0} & \\mathbf{0} \\end{bmatrix} \\, \\mathbf{Z}\n \\f]\n by using Householder transformations. Here, \\b P is a permutation matrix,\n \\b Q and \\b Z are unitary matrices and \\b T an upper triangular matrix of\n size rank-by-rank. \\b A may be rank deficient.\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::completeOrthogonalDecomposition()"]
#[repr(C)]
pub struct Eigen_CompleteOrthogonalDecomposition<_MatrixType> {
    pub m_cpqr:
        Eigen_ColPivHouseholderQR<Eigen_CompleteOrthogonalDecomposition_MatrixType<_MatrixType>>,
    pub m_zCoeffs: Eigen_CompleteOrthogonalDecomposition_HCoeffsType,
    pub m_temp: Eigen_CompleteOrthogonalDecomposition_RowVectorType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_CompleteOrthogonalDecomposition_MatrixType<_MatrixType> = _MatrixType;
pub const Eigen_CompleteOrthogonalDecomposition_RowsAtCompileTime:
    Eigen_CompleteOrthogonalDecomposition__bindgen_ty_1 = 0;
pub const Eigen_CompleteOrthogonalDecomposition_ColsAtCompileTime:
    Eigen_CompleteOrthogonalDecomposition__bindgen_ty_1 = 0;
pub const Eigen_CompleteOrthogonalDecomposition_MaxRowsAtCompileTime:
    Eigen_CompleteOrthogonalDecomposition__bindgen_ty_1 = 0;
pub const Eigen_CompleteOrthogonalDecomposition_MaxColsAtCompileTime:
    Eigen_CompleteOrthogonalDecomposition__bindgen_ty_1 = 0;
pub type Eigen_CompleteOrthogonalDecomposition__bindgen_ty_1 = i32;
pub type Eigen_CompleteOrthogonalDecomposition_Scalar = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_RealScalar = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_StorageIndex = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_HCoeffsType = [u8; 0usize];
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_CompleteOrthogonalDecomposition_PermutationType = u8;
pub type Eigen_CompleteOrthogonalDecomposition_IntRowVectorType = Eigen_internal_plain_row_type;
pub type Eigen_CompleteOrthogonalDecomposition_RowVectorType = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_RealRowVectorType = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_HouseholderSequenceType = u8;
pub type Eigen_CompleteOrthogonalDecomposition_PlainObject = [u8; 0usize];
pub type Eigen_CompleteOrthogonalDecomposition_PermIndexType =
    Eigen_CompleteOrthogonalDecomposition_PermutationType;
#[doc = " \\ingroup SVD_Module\n\n\n \\class SVDBase\n\n \\brief Base class of SVD algorithms\n\n \\tparam Derived the type of the actual SVD decomposition\n\n SVD decomposition consists in decomposing any n-by-p matrix \\a A as a product\n   \\f[ A = U S V^* \\f]\n where \\a U is a n-by-n unitary, \\a V is a p-by-p unitary, and \\a S is a n-by-p real positive matrix which is zero outside of its main diagonal;\n the diagonal entries of S are known as the \\em singular \\em values of \\a A and the columns of \\a U and \\a V are known as the left\n and right \\em singular \\em vectors of \\a A respectively.\n\n Singular values are always sorted in decreasing order.\n\n\n You can ask for only \\em thin \\a U or \\a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \\a m be the\n smaller value among \\a n and \\a p, there are only \\a m singular vectors; the remaining columns of \\a U and \\a V do not correspond to actual\n singular vectors. Asking for \\em thin \\a U or \\a V means asking for only their \\a m first columns to be formed. So \\a U is then a n-by-m matrix,\n and \\a V is then a p-by-m matrix. Notice that thin \\a U and \\a V are all you need for (least squares) solving.\n\n If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to\n terminate in finite (and reasonable) time.\n \\sa class BDCSVD, class JacobiSVD"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_SVDBase {
    pub m_matrixU: Eigen_SVDBase_MatrixUType,
    pub m_matrixV: Eigen_SVDBase_MatrixVType,
    pub m_singularValues: Eigen_SVDBase_SingularValuesType,
    pub m_isInitialized: bool,
    pub m_isAllocated: bool,
    pub m_usePrescribedThreshold: bool,
    pub m_computeFullU: bool,
    pub m_computeThinU: bool,
    pub m_computeFullV: bool,
    pub m_computeThinV: bool,
    pub m_computationOptions: ::std::os::raw::c_uint,
    pub m_nonzeroSingularValues: Eigen_SVDBase_Index,
    pub m_rows: Eigen_SVDBase_Index,
    pub m_cols: Eigen_SVDBase_Index,
    pub m_diagSize: Eigen_SVDBase_Index,
    pub m_prescribedThreshold: Eigen_SVDBase_RealScalar,
}
pub type Eigen_SVDBase_MatrixType = Eigen_internal_traits;
pub type Eigen_SVDBase_Scalar = Eigen_SVDBase_MatrixType;
pub type Eigen_SVDBase_RealScalar = Eigen_NumTraits;
pub type Eigen_SVDBase_StorageIndex = Eigen_SVDBase_MatrixType;
pub type Eigen_SVDBase_Index = Eigen_Index;
pub const Eigen_SVDBase_RowsAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_ColsAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_DiagSizeAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_MaxRowsAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_MaxColsAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_MaxDiagSizeAtCompileTime: Eigen_SVDBase__bindgen_ty_1 = 0;
pub const Eigen_SVDBase_MatrixOptions: Eigen_SVDBase__bindgen_ty_1 = 0;
pub type Eigen_SVDBase__bindgen_ty_1 = i32;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_SVDBase_MatrixUType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_SVDBase_MatrixVType = u8;
pub type Eigen_SVDBase_SingularValuesType = Eigen_internal_plain_diag_type;
#[doc = " \\ingroup SVD_Module\n\n\n \\class SVDBase\n\n \\brief Base class of SVD algorithms\n\n \\tparam Derived the type of the actual SVD decomposition\n\n SVD decomposition consists in decomposing any n-by-p matrix \\a A as a product\n   \\f[ A = U S V^* \\f]\n where \\a U is a n-by-n unitary, \\a V is a p-by-p unitary, and \\a S is a n-by-p real positive matrix which is zero outside of its main diagonal;\n the diagonal entries of S are known as the \\em singular \\em values of \\a A and the columns of \\a U and \\a V are known as the left\n and right \\em singular \\em vectors of \\a A respectively.\n\n Singular values are always sorted in decreasing order.\n\n\n You can ask for only \\em thin \\a U or \\a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \\a m be the\n smaller value among \\a n and \\a p, there are only \\a m singular vectors; the remaining columns of \\a U and \\a V do not correspond to actual\n singular vectors. Asking for \\em thin \\a U or \\a V means asking for only their \\a m first columns to be formed. So \\a U is then a n-by-m matrix,\n and \\a V is then a p-by-m matrix. Notice that thin \\a U and \\a V are all you need for (least squares) solving.\n\n If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to\n terminate in finite (and reasonable) time.\n \\sa class BDCSVD, class JacobiSVD"]
pub type Eigen_JacobiSVD_Base = Eigen_SVDBase;
pub type Eigen_JacobiSVD_MatrixType<_MatrixType> = _MatrixType;
pub type Eigen_JacobiSVD_Scalar = [u8; 0usize];
pub type Eigen_JacobiSVD_RealScalar = [u8; 0usize];
pub const Eigen_JacobiSVD_RowsAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_ColsAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_DiagSizeAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_MaxRowsAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_MaxColsAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_MaxDiagSizeAtCompileTime: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub const Eigen_JacobiSVD_MatrixOptions: Eigen_JacobiSVD__bindgen_ty_1 = 0;
pub type Eigen_JacobiSVD__bindgen_ty_1 = i32;
pub type Eigen_JacobiSVD_MatrixUType = Eigen_JacobiSVD_Base;
pub type Eigen_JacobiSVD_MatrixVType = Eigen_JacobiSVD_Base;
pub type Eigen_JacobiSVD_SingularValuesType = Eigen_JacobiSVD_Base;
pub type Eigen_JacobiSVD_RowType = [u8; 0usize];
pub type Eigen_JacobiSVD_ColType = [u8; 0usize];
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_JacobiSVD_WorkMatrixType = u8;
#[doc = " \\ingroup SVD_Module\n\n\n \\class BDCSVD\n\n \\brief class Bidiagonal Divide and Conquer SVD\n\n \\tparam _MatrixType the type of the matrix of which we are computing the SVD decomposition\n\n This class first reduces the input matrix to bi-diagonal form using class UpperBidiagonalization,\n and then performs a divide-and-conquer diagonalization. Small blocks are diagonalized using class JacobiSVD.\n You can control the switching size with the setSwitchSize() method, default is 16.\n For small matrice (<16), it is thus preferable to directly use JacobiSVD. For larger ones, BDCSVD is highly\n recommended and can several order of magnitude faster.\n\n \\warning this algorithm is unlikely to provide accurate result when compiled with unsafe math optimizations.\n For instance, this concerns Intel's compiler (ICC), which perfroms such optimization by default unless\n you compile with the \\c -fp-model \\c precise option. Likewise, the \\c -ffast-math option of GCC or clang will\n significantly degrade the accuracy.\n\n \\sa class JacobiSVD"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_BDCSVD {
    pub _base: Eigen_SVDBase,
    pub m_naiveU: Eigen_BDCSVD_MatrixXr,
    pub m_naiveV: Eigen_BDCSVD_MatrixXr,
    pub m_computed: Eigen_BDCSVD_MatrixXr,
    pub m_nRec: Eigen_Index,
    pub m_workspace: Eigen_BDCSVD_ArrayXr,
    pub m_workspaceI: Eigen_BDCSVD_ArrayXi,
    pub m_algoswap: ::std::os::raw::c_int,
    pub m_isTranspose: bool,
    pub m_compU: bool,
    pub m_compV: bool,
    pub m_numIters: ::std::os::raw::c_int,
}
#[doc = " \\ingroup SVD_Module\n\n\n \\class SVDBase\n\n \\brief Base class of SVD algorithms\n\n \\tparam Derived the type of the actual SVD decomposition\n\n SVD decomposition consists in decomposing any n-by-p matrix \\a A as a product\n   \\f[ A = U S V^* \\f]\n where \\a U is a n-by-n unitary, \\a V is a p-by-p unitary, and \\a S is a n-by-p real positive matrix which is zero outside of its main diagonal;\n the diagonal entries of S are known as the \\em singular \\em values of \\a A and the columns of \\a U and \\a V are known as the left\n and right \\em singular \\em vectors of \\a A respectively.\n\n Singular values are always sorted in decreasing order.\n\n\n You can ask for only \\em thin \\a U or \\a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \\a m be the\n smaller value among \\a n and \\a p, there are only \\a m singular vectors; the remaining columns of \\a U and \\a V do not correspond to actual\n singular vectors. Asking for \\em thin \\a U or \\a V means asking for only their \\a m first columns to be formed. So \\a U is then a n-by-m matrix,\n and \\a V is then a p-by-m matrix. Notice that thin \\a U and \\a V are all you need for (least squares) solving.\n\n If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to\n terminate in finite (and reasonable) time.\n \\sa class BDCSVD, class JacobiSVD"]
pub type Eigen_BDCSVD_Base = Eigen_SVDBase;
pub type Eigen_BDCSVD_MatrixType<_MatrixType> = _MatrixType;
pub type Eigen_BDCSVD_Scalar = [u8; 0usize];
pub type Eigen_BDCSVD_RealScalar = [u8; 0usize];
pub type Eigen_BDCSVD_Literal = [u8; 0usize];
pub const Eigen_BDCSVD_RowsAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_ColsAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_DiagSizeAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_MaxRowsAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_MaxColsAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_MaxDiagSizeAtCompileTime: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub const Eigen_BDCSVD_MatrixOptions: Eigen_BDCSVD__bindgen_ty_1 = 0;
pub type Eigen_BDCSVD__bindgen_ty_1 = i32;
pub type Eigen_BDCSVD_MatrixUType = Eigen_BDCSVD_Base;
pub type Eigen_BDCSVD_MatrixVType = Eigen_BDCSVD_Base;
pub type Eigen_BDCSVD_SingularValuesType = Eigen_BDCSVD_Base;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_BDCSVD_MatrixX = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_BDCSVD_MatrixXr = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_BDCSVD_VectorType = u8;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_BDCSVD_ArrayXr = u8;
#[doc = " \\class Array\n \\ingroup Core_Module\n\n \\brief General-purpose arrays with easy API for coefficient-wise operations\n\n The %Array class is very similar to the Matrix class. It provides\n general-purpose one- and two-dimensional arrays. The difference between the\n %Array and the %Matrix class is primarily in the API: the API for the\n %Array class provides easy access to coefficient-wise operations, while the\n API for the %Matrix class provides easy access to linear-algebra\n operations.\n\n See documentation of class Matrix for detailed information on the template parameters\n storage layout.\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_ARRAY_PLUGIN.\n\n \\sa \\blank \\ref TutorialArrayClass, \\ref TopicClassHierarchy"]
pub type Eigen_BDCSVD_ArrayXi = [u64; 2usize];
#[doc = " \\class Ref\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing expression\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam Options specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                 The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Ref implies a contiguous storage along the inner dimension (inner stride==1),\n                   but accepts a variable outer stride (leading dimension).\n                   This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class provides a way to write non-template functions taking Eigen objects as parameters while limiting the number of copies.\n A Ref<> object can represent either a const expression or a l-value:\n \\code\n // in-out argument:\n void foo1(Ref<VectorXf> x);\n\n // read-only const argument:\n void foo2(const Ref<const VectorXf>& x);\n \\endcode\n\n In the in-out case, the input argument must satisfy the constraints of the actual Ref<> type, otherwise a compilation issue will be triggered.\n By default, a Ref<VectorXf> can reference any dense vector expression of float having a contiguous memory layout.\n Likewise, a Ref<MatrixXf> can reference any column-major dense matrix expression of float whose column's elements are contiguously stored with\n the possibility to have a constant space in-between each column, i.e. the inner stride must be equal to 1, but the outer stride (or leading dimension)\n can be greater than the number of rows.\n\n In the const case, if the input expression does not match the above requirement, then it is evaluated into a temporary before being passed to the function.\n Here are some examples:\n \\code\n MatrixXf A;\n VectorXf a;\n foo1(a.head());             // OK\n foo1(A.col());              // OK\n foo1(A.row());              // Compilation error because here innerstride!=1\n foo2(A.row());              // Compilation error because A.row() is a 1xN object while foo2 is expecting a Nx1 object\n foo2(A.row().transpose());  // The row is copied into a contiguous temporary\n foo2(2*a);                  // The expression is evaluated into a temporary\n foo2(A.col().segment(2,4)); // No temporary\n \\endcode\n\n The range of inputs that can be referenced without temporary can be enlarged using the last two template parameters.\n Here is an example accepting an innerstride!=1:\n \\code\n // in-out argument:\n void foo3(Ref<VectorXf,0,InnerStride<> > x);\n foo3(A.row());              // OK\n \\endcode\n The downside here is that the function foo3 might be significantly slower than foo1 because it won't be able to exploit vectorization, and will involve more\n expensive address computations even if the input is contiguously stored in memory. To overcome this issue, one might propose to overload internally calling a\n template function, e.g.:\n \\code\n // in the .h:\n void foo(const Ref<MatrixXf>& A);\n void foo(const Ref<MatrixXf,0,Stride<> >& A);\n\n // in the .cpp:\n template<typename TypeOfA> void foo_impl(const TypeOfA& A) {\n     ... // crazy code goes here\n }\n void foo(const Ref<MatrixXf>& A) { foo_impl(A); }\n void foo(const Ref<MatrixXf,0,Stride<> >& A) { foo_impl(A); }\n \\endcode\n\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_BDCSVD_ArrayRef = u8;
#[doc = " \\class Ref\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing expression\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam Options specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                 The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Ref implies a contiguous storage along the inner dimension (inner stride==1),\n                   but accepts a variable outer stride (leading dimension).\n                   This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class provides a way to write non-template functions taking Eigen objects as parameters while limiting the number of copies.\n A Ref<> object can represent either a const expression or a l-value:\n \\code\n // in-out argument:\n void foo1(Ref<VectorXf> x);\n\n // read-only const argument:\n void foo2(const Ref<const VectorXf>& x);\n \\endcode\n\n In the in-out case, the input argument must satisfy the constraints of the actual Ref<> type, otherwise a compilation issue will be triggered.\n By default, a Ref<VectorXf> can reference any dense vector expression of float having a contiguous memory layout.\n Likewise, a Ref<MatrixXf> can reference any column-major dense matrix expression of float whose column's elements are contiguously stored with\n the possibility to have a constant space in-between each column, i.e. the inner stride must be equal to 1, but the outer stride (or leading dimension)\n can be greater than the number of rows.\n\n In the const case, if the input expression does not match the above requirement, then it is evaluated into a temporary before being passed to the function.\n Here are some examples:\n \\code\n MatrixXf A;\n VectorXf a;\n foo1(a.head());             // OK\n foo1(A.col());              // OK\n foo1(A.row());              // Compilation error because here innerstride!=1\n foo2(A.row());              // Compilation error because A.row() is a 1xN object while foo2 is expecting a Nx1 object\n foo2(A.row().transpose());  // The row is copied into a contiguous temporary\n foo2(2*a);                  // The expression is evaluated into a temporary\n foo2(A.col().segment(2,4)); // No temporary\n \\endcode\n\n The range of inputs that can be referenced without temporary can be enlarged using the last two template parameters.\n Here is an example accepting an innerstride!=1:\n \\code\n // in-out argument:\n void foo3(Ref<VectorXf,0,InnerStride<> > x);\n foo3(A.row());              // OK\n \\endcode\n The downside here is that the function foo3 might be significantly slower than foo1 because it won't be able to exploit vectorization, and will involve more\n expensive address computations even if the input is contiguously stored in memory. To overcome this issue, one might propose to overload internally calling a\n template function, e.g.:\n \\code\n // in the .h:\n void foo(const Ref<MatrixXf>& A);\n void foo(const Ref<MatrixXf,0,Stride<> >& A);\n\n // in the .cpp:\n template<typename TypeOfA> void foo_impl(const TypeOfA& A) {\n     ... // crazy code goes here\n }\n void foo(const Ref<MatrixXf>& A) { foo_impl(A); }\n void foo(const Ref<MatrixXf,0,Stride<> >& A) { foo_impl(A); }\n \\endcode\n\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_BDCSVD_IndicesRef = [u64; 4usize];
#[doc = " \\ingroup LU_Module\n\n \\class FullPivLU\n\n \\brief LU decomposition of a matrix with complete pivoting, and related features\n\n \\tparam _MatrixType the type of the matrix of which we are computing the LU decomposition\n\n This class represents a LU decomposition of any matrix, with complete pivoting: the matrix A is\n decomposed as \\f$ A = P^{-1} L U Q^{-1} \\f$ where L is unit-lower-triangular, U is\n upper-triangular, and P and Q are permutation matrices. This is a rank-revealing LU\n decomposition. The eigenvalues (diagonal coefficients) of U are sorted in such a way that any\n zeros are at the end.\n\n This decomposition provides the generic approach to solving systems of linear equations, computing\n the rank, invertibility, inverse, kernel, and determinant.\n\n This LU decomposition is very stable and well tested with large matrices. However there are use cases where the SVD\n decomposition is inherently more stable and/or flexible. For example, when computing the kernel of a matrix,\n working with the SVD allows to select the smallest singular values of the matrix, something that\n the LU decomposition doesn't see.\n\n The data of the LU decomposition can be directly accessed through the methods matrixLU(),\n permutationP(), permutationQ().\n\n As an exemple, here is how the original matrix can be retrieved:\n \\include class_FullPivLU.cpp\n Output: \\verbinclude class_FullPivLU.out\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::fullPivLu(), MatrixBase::determinant(), MatrixBase::inverse()"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_FullPivLU<_MatrixType> {
    pub m_lu: Eigen_FullPivLU_MatrixType<_MatrixType>,
    pub m_p: Eigen_FullPivLU_PermutationPType,
    pub m_q: Eigen_FullPivLU_PermutationQType,
    pub m_rowsTranspositions: Eigen_FullPivLU_IntColVectorType,
    pub m_colsTranspositions: Eigen_FullPivLU_IntRowVectorType,
    pub m_nonzero_pivots: Eigen_Index,
    pub m_l1_norm: Eigen_FullPivLU_RealScalar,
    pub m_maxpivot: Eigen_FullPivLU_RealScalar,
    pub m_prescribedThreshold: Eigen_FullPivLU_RealScalar,
    pub m_det_pq: ::std::os::raw::c_schar,
    pub m_isInitialized: bool,
    pub m_usePrescribedThreshold: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_FullPivLU_MatrixType<_MatrixType> = _MatrixType;
#[doc = " \\class SolverBase\n \\brief A base class for matrix decomposition and solvers\n\n \\tparam Derived the actual type of the decomposition/solver.\n\n Any matrix decomposition inheriting this base class provide the following API:\n\n \\code\n MatrixType A, b, x;\n DecompositionType dec(A);\n x = dec.solve(b);             // solve A   * x = b\n x = dec.transpose().solve(b); // solve A^T * x = b\n x = dec.adjoint().solve(b);   // solve A'  * x = b\n \\endcode\n\n \\warning Currently, any other usage of transpose() and adjoint() are not supported and will produce compilation errors.\n\n \\sa class PartialPivLU, class FullPivLU"]
pub type Eigen_FullPivLU_Base = Eigen_SolverBase;
pub type Eigen_FullPivLU_Scalar = Eigen_internal_traits;
pub type Eigen_FullPivLU_RealScalar = Eigen_NumTraits;
pub type Eigen_FullPivLU_CoeffReturnType = Eigen_FullPivLU_Base;
pub type Eigen_FullPivLU_Nested = Eigen_internal_ref_selector;
pub type Eigen_FullPivLU_StorageKind = Eigen_internal_traits;
pub type Eigen_FullPivLU_StorageIndex = Eigen_internal_traits;
pub const Eigen_FullPivLU_RowsAtCompileTime: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub const Eigen_FullPivLU_ColsAtCompileTime: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub const Eigen_FullPivLU_Flags: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub const Eigen_FullPivLU_SizeAtCompileTime: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub const Eigen_FullPivLU_MaxSizeAtCompileTime: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub const Eigen_FullPivLU_IsVectorAtCompileTime: Eigen_FullPivLU__bindgen_ty_1 = 0;
pub type Eigen_FullPivLU__bindgen_ty_1 = i32;
pub const Eigen_FullPivLU_MaxRowsAtCompileTime: Eigen_FullPivLU__bindgen_ty_2 = 0;
pub const Eigen_FullPivLU_MaxColsAtCompileTime: Eigen_FullPivLU__bindgen_ty_2 = 0;
pub type Eigen_FullPivLU__bindgen_ty_2 = i32;
pub type Eigen_FullPivLU_IntRowVectorType = Eigen_internal_plain_row_type;
pub type Eigen_FullPivLU_IntColVectorType = Eigen_internal_plain_col_type;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_FullPivLU_PermutationQType = u8;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_FullPivLU_PermutationPType = u8;
pub type Eigen_FullPivLU_PlainObject = [u8; 0usize];
#[doc = " \\ingroup LU_Module\n\n \\class PartialPivLU\n\n \\brief LU decomposition of a matrix with partial pivoting, and related features\n\n \\tparam _MatrixType the type of the matrix of which we are computing the LU decomposition\n\n This class represents a LU decomposition of a \\b square \\b invertible matrix, with partial pivoting: the matrix A\n is decomposed as A = PLU where L is unit-lower-triangular, U is upper-triangular, and P\n is a permutation matrix.\n\n Typically, partial pivoting LU decomposition is only considered numerically stable for square invertible\n matrices. Thus LAPACK's dgesv and dgesvx require the matrix to be square and invertible. The present class\n does the same. It will assert that the matrix is square, but it won't (actually it can't) check that the\n matrix is invertible: it is your task to check that you only use this decomposition on invertible matrices.\n\n The guaranteed safe alternative, working for all matrices, is the full pivoting LU decomposition, provided\n by class FullPivLU.\n\n This is \\b not a rank-revealing LU decomposition. Many features are intentionally absent from this class,\n such as rank computation. If you need these features, use class FullPivLU.\n\n This LU decomposition is suitable to invert invertible matrices. It is what MatrixBase::inverse() uses\n in the general case.\n On the other hand, it is \\b not suitable to determine whether a given matrix is invertible.\n\n The data of the LU decomposition can be directly accessed through the methods matrixLU(), permutationP().\n\n This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism.\n\n \\sa MatrixBase::partialPivLu(), MatrixBase::determinant(), MatrixBase::inverse(), MatrixBase::computeInverse(), class FullPivLU"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_PartialPivLU<_MatrixType> {
    pub m_lu: Eigen_PartialPivLU_MatrixType<_MatrixType>,
    pub m_p: Eigen_PartialPivLU_PermutationType,
    pub m_rowsTranspositions: Eigen_PartialPivLU_TranspositionType,
    pub m_l1_norm: Eigen_PartialPivLU_RealScalar,
    pub m_det_p: ::std::os::raw::c_schar,
    pub m_isInitialized: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MatrixType>>,
}
pub type Eigen_PartialPivLU_MatrixType<_MatrixType> = _MatrixType;
#[doc = " \\class SolverBase\n \\brief A base class for matrix decomposition and solvers\n\n \\tparam Derived the actual type of the decomposition/solver.\n\n Any matrix decomposition inheriting this base class provide the following API:\n\n \\code\n MatrixType A, b, x;\n DecompositionType dec(A);\n x = dec.solve(b);             // solve A   * x = b\n x = dec.transpose().solve(b); // solve A^T * x = b\n x = dec.adjoint().solve(b);   // solve A'  * x = b\n \\endcode\n\n \\warning Currently, any other usage of transpose() and adjoint() are not supported and will produce compilation errors.\n\n \\sa class PartialPivLU, class FullPivLU"]
pub type Eigen_PartialPivLU_Base = Eigen_SolverBase;
pub type Eigen_PartialPivLU_Scalar = Eigen_internal_traits;
pub type Eigen_PartialPivLU_RealScalar = Eigen_NumTraits;
pub type Eigen_PartialPivLU_CoeffReturnType = Eigen_PartialPivLU_Base;
pub type Eigen_PartialPivLU_Nested = Eigen_internal_ref_selector;
pub type Eigen_PartialPivLU_StorageKind = Eigen_internal_traits;
pub type Eigen_PartialPivLU_StorageIndex = Eigen_internal_traits;
pub const Eigen_PartialPivLU_RowsAtCompileTime: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub const Eigen_PartialPivLU_ColsAtCompileTime: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub const Eigen_PartialPivLU_Flags: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub const Eigen_PartialPivLU_SizeAtCompileTime: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub const Eigen_PartialPivLU_MaxSizeAtCompileTime: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub const Eigen_PartialPivLU_IsVectorAtCompileTime: Eigen_PartialPivLU__bindgen_ty_1 = 0;
pub type Eigen_PartialPivLU__bindgen_ty_1 = i32;
pub const Eigen_PartialPivLU_MaxRowsAtCompileTime: Eigen_PartialPivLU__bindgen_ty_2 = 0;
pub const Eigen_PartialPivLU_MaxColsAtCompileTime: Eigen_PartialPivLU__bindgen_ty_2 = 0;
pub type Eigen_PartialPivLU__bindgen_ty_2 = i32;
#[doc = " \\class PermutationMatrix\n \\ingroup Core_Module\n\n \\brief Permutation matrix\n\n \\tparam SizeAtCompileTime the number of rows/cols, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of rows/cols, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n \\tparam _StorageIndex the integer type of the indices\n\n This class represents a permutation matrix, internally stored as a vector of integers.\n\n \\sa class PermutationBase, class PermutationWrapper, class DiagonalMatrix"]
pub type Eigen_PartialPivLU_PermutationType = u8;
#[doc = " \\class Transpositions\n \\ingroup Core_Module\n\n \\brief Represents a sequence of transpositions (row/column interchange)\n\n \\tparam SizeAtCompileTime the number of transpositions, or Dynamic\n \\tparam MaxSizeAtCompileTime the maximum number of transpositions, or Dynamic. This optional parameter defaults to SizeAtCompileTime. Most of the time, you should not have to specify it.\n\n This class represents a permutation transformation as a sequence of \\em n transpositions\n \\f$[T_{n-1} \\ldots T_{i} \\ldots T_{0}]\\f$. It is internally stored as a vector of integers \\c indices.\n Each transposition \\f$ T_{i} \\f$ applied on the left of a matrix (\\f$ T_{i} M\\f$) interchanges\n the rows \\c i and \\c indices[i] of the matrix \\c M.\n A transposition applied on the right (e.g., \\f$ M T_{i}\\f$) yields a column interchange.\n\n Compared to the class PermutationMatrix, such a sequence of transpositions is what is\n computed during a decomposition with pivoting, and it is faster when applying the permutation in-place.\n\n To apply a sequence of transpositions to a matrix, simply use the operator * as in the following example:\n \\code\n Transpositions tr;\n MatrixXf mat;\n mat = tr * mat;\n \\endcode\n In this example, we detect that the matrix appears on both side, and so the transpositions\n are applied in-place without any temporary or extra copy.\n\n \\sa class PermutationMatrix"]
pub type Eigen_PartialPivLU_TranspositionType = u8;
pub type Eigen_PartialPivLU_PlainObject = [u8; 0usize];
pub type Eigen_Homogeneous_NestedExpression<MatrixType> = MatrixType;
pub const Eigen_Homogeneous_Direction: Eigen_Homogeneous__bindgen_ty_1 = 0;
pub type Eigen_Homogeneous__bindgen_ty_1 = i32;
#[doc = " \\class MatrixBase\n \\ingroup Core_Module\n\n \\brief Base class for all dense matrices, vectors, and expressions\n\n This class is the base that is inherited by all matrix, vector, and related expression\n types. Most of the Eigen API is contained in this class, and its base classes. Other important\n classes for the Eigen API are Matrix, and VectorwiseOp.\n\n Note that some methods are defined in other modules such as the \\ref LU_Module LU module\n for all functions related to matrix inversions.\n\n \\tparam Derived is the derived type, e.g. a matrix type, or an expression, etc.\n\n When writing a function taking Eigen objects as argument, if you want your function\n to take as argument any matrix, vector, or expression, just let it take a\n MatrixBase argument. As an example, here is a function printFirstRow which, given\n a matrix, vector, or expression \\a x, prints the first row of \\a x.\n\n \\code\ntemplate<typename Derived>\nvoid printFirstRow(const Eigen::MatrixBase<Derived>& x)\n{\ncout << x.row(0) << endl;\n}\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIXBASE_PLUGIN.\n\n \\sa \\blank \\ref TopicClassHierarchy"]
pub type Eigen_Homogeneous_Base = Eigen_MatrixBase;
pub type Eigen_Homogeneous_Scalar = Eigen_internal_traits;
pub type Eigen_Homogeneous_RealScalar = Eigen_NumTraits;
pub type Eigen_Homogeneous_CoeffReturnType = Eigen_Homogeneous_Base;
pub type Eigen_Homogeneous_Nested = Eigen_internal_ref_selector;
pub type Eigen_Homogeneous_StorageKind = Eigen_internal_traits;
pub type Eigen_Homogeneous_StorageIndex = Eigen_internal_traits;
pub const Eigen_Homogeneous_RowsAtCompileTime: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub const Eigen_Homogeneous_ColsAtCompileTime: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub const Eigen_Homogeneous_Flags: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub const Eigen_Homogeneous_SizeAtCompileTime: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub const Eigen_Homogeneous_MaxSizeAtCompileTime: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub const Eigen_Homogeneous_IsVectorAtCompileTime: Eigen_Homogeneous__bindgen_ty_2 = 0;
pub type Eigen_Homogeneous__bindgen_ty_2 = i32;
pub type Eigen_Homogeneous_PacketScalar = Eigen_Homogeneous_Base;
pub const Eigen_RotationBase_Dim: Eigen_RotationBase__bindgen_ty_1 = 0;
pub type Eigen_RotationBase__bindgen_ty_1 = i32;
#[doc = " the scalar type of the coefficients"]
pub type Eigen_RotationBase_Scalar = Eigen_internal_traits;
#[doc = " corresponding linear transformation matrix type"]
pub type Eigen_RotationBase_RotationMatrixType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_RotationBase_VectorType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_Rotation2D<_Scalar> {
    pub m_angle: Eigen_Rotation2D_Scalar<_Scalar>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Scalar>>,
}
#[doc = " \\class RotationBase\n\n \\brief Common base class for compact rotation representations\n\n \\tparam Derived is the derived type, i.e., a rotation type\n \\tparam _Dim the dimension of the space"]
pub type Eigen_Rotation2D_Base = u8;
pub const Eigen_Rotation2D_Dim: Eigen_Rotation2D__bindgen_ty_1 = 0;
pub type Eigen_Rotation2D__bindgen_ty_1 = i32;
#[doc = " the scalar type of the coefficients"]
pub type Eigen_Rotation2D_Scalar<_Scalar> = _Scalar;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Rotation2D_Vector2 = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Rotation2D_Matrix2 = u8;
#[doc = " \\ingroup Geometry_Module\n single precision 2D rotation type"]
pub type Eigen_Rotation2Df = Eigen_Rotation2D<f32>;
#[doc = " \\ingroup Geometry_Module\n double precision 2D rotation type"]
pub type Eigen_Rotation2Dd = Eigen_Rotation2D<f64>;
#[doc = " \\geometry_module \\ingroup Geometry_Module\n \\class QuaternionBase\n \\brief Base class for quaternion expressions\n \\tparam Derived derived type (CRTP)\n \\sa class Quaternion"]
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_QuaternionBase {
    pub _address: u8,
}
#[doc = " \\class RotationBase\n\n \\brief Common base class for compact rotation representations\n\n \\tparam Derived is the derived type, i.e., a rotation type\n \\tparam _Dim the dimension of the space"]
pub type Eigen_QuaternionBase_Base = u8;
pub type Eigen_QuaternionBase_Scalar = Eigen_internal_traits;
pub type Eigen_QuaternionBase_RealScalar = Eigen_NumTraits;
pub type Eigen_QuaternionBase_Coefficients = Eigen_internal_traits;
pub type Eigen_QuaternionBase_CoeffReturnType = Eigen_QuaternionBase_Coefficients;
pub type Eigen_QuaternionBase_NonConstCoeffReturnType = u8;
pub const Eigen_QuaternionBase_Flags: Eigen_QuaternionBase__bindgen_ty_1 = 0;
pub type Eigen_QuaternionBase__bindgen_ty_1 = i32;
#[doc = " the type of a 3D vector"]
pub type Eigen_QuaternionBase_Vector3 = u8;
#[doc = " the equivalent rotation matrix type"]
pub type Eigen_QuaternionBase_Matrix3 = u8;
#[doc = " the equivalent angle-axis type"]
pub type Eigen_QuaternionBase_AngleAxisType = Eigen_AngleAxis<Eigen_QuaternionBase_Scalar>;
#[doc = " \\geometry_module \\ingroup Geometry_Module\n \\class QuaternionBase\n \\brief Base class for quaternion expressions\n \\tparam Derived derived type (CRTP)\n \\sa class Quaternion"]
pub type Eigen_Quaternion_Base = Eigen_QuaternionBase;
pub const Eigen_Quaternion_NeedsAlignment: Eigen_Quaternion__bindgen_ty_1 = 0;
pub type Eigen_Quaternion__bindgen_ty_1 = i32;
pub type Eigen_Quaternion_Scalar<_Scalar> = _Scalar;
pub type Eigen_Quaternion_Coefficients = Eigen_internal_traits;
pub type Eigen_Quaternion_AngleAxisType = Eigen_Quaternion_Base;
pub type Eigen_Quaternion_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
#[doc = " \\ingroup Geometry_Module\n single precision quaternion type"]
pub type Eigen_Quaternionf = u128;
#[doc = " \\ingroup Geometry_Module\n double precision quaternion type"]
pub type Eigen_Quaterniond = [u128; 2usize];
#[doc = " \\ingroup Geometry_Module\n Map an unaligned array of single precision scalars as a quaternion"]
pub type Eigen_QuaternionMapf = u8;
#[doc = " \\ingroup Geometry_Module\n Map an unaligned array of double precision scalars as a quaternion"]
pub type Eigen_QuaternionMapd = u8;
#[doc = " \\ingroup Geometry_Module\n Map a 16-byte aligned array of single precision scalars as a quaternion"]
pub type Eigen_QuaternionMapAlignedf = u8;
#[doc = " \\ingroup Geometry_Module\n Map a 16-byte aligned array of double precision scalars as a quaternion"]
pub type Eigen_QuaternionMapAlignedd = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_AngleAxis<_Scalar> {
    pub m_axis: Eigen_AngleAxis_Vector3,
    pub m_angle: Eigen_AngleAxis_Scalar<_Scalar>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Scalar>>,
}
#[doc = " \\class RotationBase\n\n \\brief Common base class for compact rotation representations\n\n \\tparam Derived is the derived type, i.e., a rotation type\n \\tparam _Dim the dimension of the space"]
pub type Eigen_AngleAxis_Base = u8;
pub const Eigen_AngleAxis_Dim: Eigen_AngleAxis__bindgen_ty_1 = 0;
pub type Eigen_AngleAxis__bindgen_ty_1 = i32;
#[doc = " the scalar type of the coefficients"]
pub type Eigen_AngleAxis_Scalar<_Scalar> = _Scalar;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_AngleAxis_Matrix3 = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_AngleAxis_Vector3 = u8;
pub type Eigen_AngleAxis_QuaternionType = u8;
#[doc = " \\ingroup Geometry_Module\n single precision angle-axis type"]
pub type Eigen_AngleAxisf = Eigen_AngleAxis<f32>;
#[doc = " \\ingroup Geometry_Module\n double precision angle-axis type"]
pub type Eigen_AngleAxisd = Eigen_AngleAxis<f64>;
pub type Eigen_Transform_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_Transform_Mode: Eigen_Transform__bindgen_ty_1 = 0;
pub const Eigen_Transform_Options: Eigen_Transform__bindgen_ty_1 = 0;
#[doc = "< space dimension in which the transformation holds"]
pub const Eigen_Transform_Dim: Eigen_Transform__bindgen_ty_1 = 0;
#[doc = "< size of a respective homogeneous vector"]
pub const Eigen_Transform_HDim: Eigen_Transform__bindgen_ty_1 = 0;
pub const Eigen_Transform_Rows: Eigen_Transform__bindgen_ty_1 = 0;
pub type Eigen_Transform__bindgen_ty_1 = i32;
#[doc = " the scalar type of the coefficients"]
pub type Eigen_Transform_Scalar<_Scalar> = _Scalar;
pub type Eigen_Transform_StorageIndex = Eigen_Index;
pub type Eigen_Transform_Index = Eigen_Index;
#[doc = " type of the matrix used to represent the transformation"]
pub type Eigen_Transform_MatrixType = u8;
#[doc = " constified MatrixType"]
pub type Eigen_Transform_ConstMatrixType = Eigen_Transform_MatrixType;
#[doc = " type of the matrix used to represent the linear part of the transformation"]
pub type Eigen_Transform_LinearMatrixType = u8;
#[doc = " type of read/write reference to the linear part of the transformation"]
pub type Eigen_Transform_LinearPart = u8;
#[doc = " type of read reference to the linear part of the transformation"]
pub type Eigen_Transform_ConstLinearPart = u8;
#[doc = " type of read/write reference to the affine part of the transformation"]
pub type Eigen_Transform_AffinePart = u8;
#[doc = " type of read reference to the affine part of the transformation"]
pub type Eigen_Transform_ConstAffinePart = u8;
#[doc = " type of a vector"]
pub type Eigen_Transform_VectorType = u8;
#[doc = " type of a read/write reference to the translation part of the rotation"]
pub type Eigen_Transform_TranslationPart = u8;
#[doc = " type of a read reference to the translation part of the rotation"]
pub type Eigen_Transform_ConstTranslationPart = u8;
#[doc = " corresponding translation type"]
pub type Eigen_Transform_TranslationType = u8;
pub const Eigen_Transform_TransformTimeDiagonalMode: Eigen_Transform__bindgen_ty_2 = 0;
pub type Eigen_Transform__bindgen_ty_2 = i32;
#[doc = " The return type of the product between a diagonal matrix and a transform"]
pub type Eigen_Transform_TransformTimeDiagonalReturnType = u8;
#[doc = " Specializations of take affine part            ***"]
pub type Eigen_Transform_take_affine_part = Eigen_internal_transform_take_affine_part;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Isometry2f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Isometry3f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Isometry2d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Isometry3d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Affine2f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Affine3f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Affine2d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Affine3d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_AffineCompact2f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_AffineCompact3f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_AffineCompact2d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_AffineCompact3d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Projective2f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Projective3f = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Projective2d = u8;
#[doc = " \\ingroup Geometry_Module"]
pub type Eigen_Projective3d = u8;
pub type Eigen_Translation_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_Translation_Dim: Eigen_Translation__bindgen_ty_1 = 0;
#[doc = " dimension of the space"]
pub type Eigen_Translation__bindgen_ty_1 = i32;
#[doc = " the scalar type of the coefficients"]
pub type Eigen_Translation_Scalar<_Scalar> = _Scalar;
#[doc = " corresponding vector type"]
pub type Eigen_Translation_VectorType = u8;
#[doc = " corresponding linear transformation matrix type"]
pub type Eigen_Translation_LinearMatrixType = u8;
#[doc = " corresponding affine transformation type"]
pub type Eigen_Translation_AffineTransformType = u8;
#[doc = " corresponding isometric transformation type"]
pub type Eigen_Translation_IsometryTransformType = u8;
pub type Eigen_Translation2f = u8;
pub type Eigen_Translation2d = u8;
pub type Eigen_Translation3f = u8;
pub type Eigen_Translation3d = u8;
#[doc = " \\geometry_module \\ingroup Geometry_Module\n\n \\class Scaling\n\n \\brief Represents a generic uniform scaling transformation\n\n \\tparam _Scalar the scalar type, i.e., the type of the coefficients.\n\n This class represent a uniform scaling transformation. It is the return\n type of Scaling(Scalar), and most of the time this is the only way it\n is used. In particular, this class is not aimed to be used to store a scaling transformation,\n but rather to make easier the constructions and updates of Transform objects.\n\n To represent an axis aligned scaling, use the DiagonalMatrix class.\n\n \\sa Scaling(), class DiagonalMatrix, MatrixBase::asDiagonal(), class Translation, class Transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_UniformScaling<_Scalar> {
    pub m_factor: Eigen_UniformScaling_Scalar<_Scalar>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Scalar>>,
}
#[doc = " the scalar type of the coefficients"]
pub type Eigen_UniformScaling_Scalar<_Scalar> = _Scalar;
#[doc = " \\deprecated"]
pub type Eigen_AlignedScaling2f = u8;
#[doc = " \\deprecated"]
pub type Eigen_AlignedScaling2d = u8;
#[doc = " \\deprecated"]
pub type Eigen_AlignedScaling3f = u8;
#[doc = " \\deprecated"]
pub type Eigen_AlignedScaling3d = u8;
pub type Eigen_Hyperplane_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_Hyperplane_AmbientDimAtCompileTime: Eigen_Hyperplane__bindgen_ty_1 = 0;
pub const Eigen_Hyperplane_Options: Eigen_Hyperplane__bindgen_ty_1 = 0;
pub type Eigen_Hyperplane__bindgen_ty_1 = i32;
pub type Eigen_Hyperplane_Scalar<_Scalar> = _Scalar;
pub type Eigen_Hyperplane_RealScalar = Eigen_NumTraits;
pub type Eigen_Hyperplane_Index = Eigen_Index;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Hyperplane_VectorType = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_Hyperplane_Coefficients = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_Hyperplane_NormalReturnType = u8;
#[doc = " \\class Block\n \\ingroup Core_Module\n\n \\brief Expression of a fixed-size or dynamic-size block\n\n \\tparam XprType the type of the expression in which we are taking a block\n \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)\n \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)\n \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or\n         to set of columns of a column major matrix (optional). The parameter allows to determine\n         at compile time whether aligned access is possible on the block expression.\n\n This class represents an expression of either a fixed-size or dynamic-size block. It is the return\n type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and\n most of the time this is the only way it is used.\n\n However, if you want to directly maniputate block expressions,\n for instance if you want to write a function returning such an expression, you\n will need to use this class.\n\n Here is an example illustrating the dynamic case:\n \\include class_Block.cpp\n Output: \\verbinclude class_Block.out\n\n \\note Even though this expression has dynamic size, in the case where \\a XprType\n has fixed size, this expression inherits a fixed maximal size which means that evaluating\n it does not cause a dynamic memory allocation.\n\n Here is an example illustrating the fixed-size case:\n \\include class_FixedBlock.cpp\n Output: \\verbinclude class_FixedBlock.out\n\n \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"]
pub type Eigen_Hyperplane_ConstNormalReturnType = u8;
pub type Eigen_ParametrizedLine_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_ParametrizedLine_AmbientDimAtCompileTime: Eigen_ParametrizedLine__bindgen_ty_1 = 0;
pub const Eigen_ParametrizedLine_Options: Eigen_ParametrizedLine__bindgen_ty_1 = 0;
pub type Eigen_ParametrizedLine__bindgen_ty_1 = i32;
pub type Eigen_ParametrizedLine_Scalar<_Scalar> = _Scalar;
pub type Eigen_ParametrizedLine_RealScalar = Eigen_NumTraits;
pub type Eigen_ParametrizedLine_Index = Eigen_Index;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_ParametrizedLine_VectorType = u8;
pub type Eigen_AlignedBox_eigen_aligned_operator_new_marker_type = ::std::os::raw::c_void;
pub const Eigen_AlignedBox_AmbientDimAtCompileTime: Eigen_AlignedBox__bindgen_ty_1 = 0;
pub type Eigen_AlignedBox__bindgen_ty_1 = i32;
pub type Eigen_AlignedBox_Scalar<_Scalar> = _Scalar;
pub type Eigen_AlignedBox_ScalarTraits = Eigen_NumTraits;
pub type Eigen_AlignedBox_Index = Eigen_Index;
pub type Eigen_AlignedBox_RealScalar = Eigen_AlignedBox_ScalarTraits;
pub type Eigen_AlignedBox_NonInteger = Eigen_AlignedBox_ScalarTraits;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_AlignedBox_VectorType = u8;
#[doc = " \\class CwiseBinaryOp\n \\ingroup Core_Module\n\n \\brief Generic expression where a coefficient-wise binary operator is applied to two expressions\n\n \\tparam BinaryOp template functor implementing the operator\n \\tparam LhsType the type of the left-hand side\n \\tparam RhsType the type of the right-hand side\n\n This class represents an expression  where a coefficient-wise binary operator is applied to two expressions.\n It is the return type of binary operators, by which we mean only those binary operators where\n both the left-hand side and the right-hand side are Eigen expressions.\n For example, the return type of matrix1+matrix2 is a CwiseBinaryOp.\n\n Most of the time, this is the only way that it is used, so you typically don't have to name\n CwiseBinaryOp types explicitly.\n\n \\sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp"]
pub type Eigen_AlignedBox_VectorTypeSum = Eigen_CwiseBinaryOp<BinaryOp>;
#[doc = " 1D names @{"]
pub const Eigen_AlignedBox_CornerType_Min: Eigen_AlignedBox_CornerType = 0;
#[doc = " 1D names @{"]
pub const Eigen_AlignedBox_CornerType_Max: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 2D corner @{"]
pub const Eigen_AlignedBox_CornerType_BottomLeft: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 2D corner @{"]
pub const Eigen_AlignedBox_CornerType_BottomRight: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 2D corner @{"]
pub const Eigen_AlignedBox_CornerType_TopLeft: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 2D corner @{"]
pub const Eigen_AlignedBox_CornerType_TopRight: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_BottomLeftFloor: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_BottomRightFloor: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_TopLeftFloor: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_TopRightFloor: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_BottomLeftCeil: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_BottomRightCeil: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_TopLeftCeil: Eigen_AlignedBox_CornerType = 0;
#[doc = " Identifier for 3D corner  @{"]
pub const Eigen_AlignedBox_CornerType_TopRightCeil: Eigen_AlignedBox_CornerType = 0;
#[doc = " Define constants to name the corners of a 1D, 2D or 3D axis aligned bounding box"]
pub type Eigen_AlignedBox_CornerType = i32;
pub type Eigen_AlignedBox1i = u8;
pub type Eigen_AlignedBox2i = u8;
pub type Eigen_AlignedBox3i = u8;
pub type Eigen_AlignedBox4i = u8;
pub type Eigen_AlignedBoxXi = u8;
pub type Eigen_AlignedBox1f = u8;
pub type Eigen_AlignedBox2f = u8;
pub type Eigen_AlignedBox3f = u8;
pub type Eigen_AlignedBox4f = u8;
pub type Eigen_AlignedBoxXf = u8;
pub type Eigen_AlignedBox1d = u8;
pub type Eigen_AlignedBox2d = u8;
pub type Eigen_AlignedBox3d = u8;
pub type Eigen_AlignedBox4d = u8;
pub type Eigen_AlignedBoxXd = u8;
#[repr(C)]
#[derive(Debug)]
pub struct Eigen_aligned_allocator_indirection {
    pub _address: u8,
}
pub type Eigen_aligned_allocator_indirection_size_type = usize;
pub type Eigen_aligned_allocator_indirection_difference_type = isize;
pub type Eigen_aligned_allocator_indirection_pointer<T> = *mut T;
pub type Eigen_aligned_allocator_indirection_const_pointer<T> = *const T;
pub type Eigen_aligned_allocator_indirection_reference<T> = *mut T;
pub type Eigen_aligned_allocator_indirection_const_reference<T> = *const T;
pub type Eigen_aligned_allocator_indirection_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_aligned_allocator_indirection_rebind {
    pub _address: u8,
}
#[doc = " Extending Eigen namespace by adding frequently used matrix type"]
pub type Eigen_Matrix6d = u8;
pub type Eigen_Vector6d = u8;
pub type Eigen_Vector3uint8 = u8;
#[doc = " Use Eigen::DontAlign for matrices inside classes which are exposed in the\n Open3D headers https://github.com/isl-org/Open3D/issues/653"]
pub type Eigen_Matrix6d_u = u8;
pub type Eigen_Matrix4d_u = u8;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
pub const FP_INT_UPWARD: _bindgen_ty_40 = 0;
pub const FP_INT_DOWNWARD: _bindgen_ty_40 = 1;
pub const FP_INT_TOWARDZERO: _bindgen_ty_40 = 2;
pub const FP_INT_TONEARESTFROMZERO: _bindgen_ty_40 = 3;
pub const FP_INT_TONEAREST: _bindgen_ty_40 = 4;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorder(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermag(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
extern "C" {
    pub fn __sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn exp10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp10l(__x: u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nextdownl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nextdownl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextupl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nextupl(__x: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn roundevenl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundevenl(__x: u128) -> u128;
}
extern "C" {
    pub fn fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxmagl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminmagl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminmagl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn canonicalizel(__cx: *mut u128, __x: *const u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadl(__x: *const u128) -> u128;
}
extern "C" {
    pub fn __getpayloadl(__x: *const u128) -> u128;
}
extern "C" {
    pub fn setpayloadl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn acosf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __acosf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn asinf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __asinf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn atanf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __atanf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
extern "C" {
    pub fn cosf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __cosf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn sinf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __sinf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn tanf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __tanf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn coshf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __coshf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn sinhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __sinhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn tanhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __tanhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
extern "C" {
    pub fn __sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
extern "C" {
    pub fn acoshf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __acoshf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn asinhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __asinhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn atanhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __atanhf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn expf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __expf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn __frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn __ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn logf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __logf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn log10f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __log10f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
extern "C" {
    pub fn __modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
extern "C" {
    pub fn exp10f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __exp10f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn expm1f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __expm1f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn log1pf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __log1pf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn logbf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __logbf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn exp2f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __exp2f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn log2f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __log2f32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn sqrtf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __sqrtf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn cbrtf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __cbrtf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn ceilf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __ceilf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn fabsf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fabsf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn floorf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __floorf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
extern "C" {
    pub fn __nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
extern "C" {
    pub fn j0f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __j0f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn j1f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __j1f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
extern "C" {
    pub fn __jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
extern "C" {
    pub fn y0f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __y0f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn y1f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __y1f32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
extern "C" {
    pub fn __ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
extern "C" {
    pub fn erff32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __erff32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn erfcf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __erfcf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn lgammaf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __lgammaf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn tgammaf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn __tgammaf32(arg1: _Float32) -> _Float32;
}
extern "C" {
    pub fn lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn __lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn rintf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __rintf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn nextdownf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __nextdownf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn nextupf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __nextupf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn __scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
extern "C" {
    pub fn __scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
extern "C" {
    pub fn nearbyintf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __nearbyintf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn roundf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __roundf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn truncf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __truncf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int) -> _Float32;
}
extern "C" {
    pub fn __remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int)
        -> _Float32;
}
extern "C" {
    pub fn lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
extern "C" {
    pub fn roundevenf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn __roundevenf32(__x: _Float32) -> _Float32;
}
extern "C" {
    pub fn fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn __fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
extern "C" {
    pub fn canonicalizef32(__cx: *mut _Float32, __x: *const _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf32(__x: *const _Float32) -> _Float32;
}
extern "C" {
    pub fn __getpayloadf32(__x: *const _Float32) -> _Float32;
}
extern "C" {
    pub fn setpayloadf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __acosf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn asinf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __asinf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn atanf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __atanf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
extern "C" {
    pub fn cosf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __cosf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn sinf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __sinf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn tanf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __tanf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn coshf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __coshf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn sinhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __sinhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn tanhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __tanhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
extern "C" {
    pub fn __sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
extern "C" {
    pub fn acoshf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __acoshf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn asinhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __asinhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn atanhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __atanhf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn expf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __expf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn __frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn __ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn logf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __logf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn log10f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __log10f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
extern "C" {
    pub fn __modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
extern "C" {
    pub fn exp10f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __exp10f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn expm1f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __expm1f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn log1pf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __log1pf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn logbf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __logbf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn exp2f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __exp2f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn log2f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __log2f64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn sqrtf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __sqrtf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn cbrtf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __cbrtf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn ceilf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __ceilf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn fabsf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fabsf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn floorf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __floorf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
extern "C" {
    pub fn __nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
extern "C" {
    pub fn j0f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __j0f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn j1f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __j1f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
extern "C" {
    pub fn __jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
extern "C" {
    pub fn y0f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __y0f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn y1f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __y1f64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
extern "C" {
    pub fn __ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
extern "C" {
    pub fn erff64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __erff64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn erfcf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __erfcf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn lgammaf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __lgammaf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn tgammaf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn __tgammaf64(arg1: _Float64) -> _Float64;
}
extern "C" {
    pub fn lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn __lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn rintf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __rintf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn nextdownf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __nextdownf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn nextupf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __nextupf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn __scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
extern "C" {
    pub fn __scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
extern "C" {
    pub fn nearbyintf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __nearbyintf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn roundf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __roundf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn truncf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __truncf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int) -> _Float64;
}
extern "C" {
    pub fn __remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int)
        -> _Float64;
}
extern "C" {
    pub fn lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
extern "C" {
    pub fn roundevenf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn __roundevenf64(__x: _Float64) -> _Float64;
}
extern "C" {
    pub fn fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn __fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
extern "C" {
    pub fn canonicalizef64(__cx: *mut _Float64, __x: *const _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf64(__x: *const _Float64) -> _Float64;
}
extern "C" {
    pub fn __getpayloadf64(__x: *const _Float64) -> _Float64;
}
extern "C" {
    pub fn setpayloadf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __acosf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn asinf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __asinf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn atanf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __atanf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn cosf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __cosf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn sinf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __sinf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn tanf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __tanf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn coshf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __coshf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn sinhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __sinhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn tanhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __tanhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
extern "C" {
    pub fn __sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
extern "C" {
    pub fn acoshf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __acoshf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn asinhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __asinhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn atanhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __atanhf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn expf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __expf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn __frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn __ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn logf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __logf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn log10f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __log10f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
extern "C" {
    pub fn exp10f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __exp10f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn expm1f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __expm1f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn log1pf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __log1pf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn logbf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __logbf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn exp2f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __exp2f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn log2f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __log2f32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn sqrtf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __sqrtf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn cbrtf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __cbrtf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn ceilf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __ceilf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fabsf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fabsf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn floorf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __floorf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
extern "C" {
    pub fn __nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
extern "C" {
    pub fn j0f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __j0f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn j1f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __j1f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn y0f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __y0f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn y1f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __y1f32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn erff32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __erff32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn erfcf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __erfcf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn lgammaf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __lgammaf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn tgammaf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __tgammaf32x(arg1: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn __lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn rintf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __rintf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn nextdownf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __nextdownf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn nextupf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __nextupf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn __scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
extern "C" {
    pub fn ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
extern "C" {
    pub fn __scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
extern "C" {
    pub fn nearbyintf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __nearbyintf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn roundf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __roundf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn truncf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __truncf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
extern "C" {
    pub fn __remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
extern "C" {
    pub fn lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn roundevenf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __roundevenf32x(__x: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
extern "C" {
    pub fn canonicalizef32x(__cx: *mut _Float32x, __x: *const _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf32x(__x: *const _Float32x, __y: *const _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf32x(__x: *const _Float32x, __y: *const _Float32x)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
extern "C" {
    pub fn __getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
extern "C" {
    pub fn setpayloadf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __acosf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn asinf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __asinf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn atanf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __atanf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn cosf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __cosf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn sinf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __sinf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn tanf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __tanf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn coshf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __coshf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn sinhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __sinhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn tanhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __tanhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
extern "C" {
    pub fn __sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
extern "C" {
    pub fn acoshf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __acoshf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn asinhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __asinhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn atanhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __atanhf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn expf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __expf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn __frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn __ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn logf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __logf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn log10f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __log10f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
extern "C" {
    pub fn exp10f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __exp10f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn expm1f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __expm1f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn log1pf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __log1pf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn logbf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __logbf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn exp2f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __exp2f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn log2f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __log2f64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn sqrtf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __sqrtf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn cbrtf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __cbrtf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn ceilf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __ceilf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fabsf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fabsf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn floorf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __floorf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
extern "C" {
    pub fn __nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
extern "C" {
    pub fn j0f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __j0f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn j1f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __j1f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn y0f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __y0f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn y1f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __y1f64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn erff64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __erff64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn erfcf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __erfcf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn lgammaf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __lgammaf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn tgammaf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __tgammaf64x(arg1: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn __lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn rintf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __rintf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn nextdownf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __nextdownf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn nextupf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __nextupf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn __scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
extern "C" {
    pub fn ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
extern "C" {
    pub fn __scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
extern "C" {
    pub fn nearbyintf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __nearbyintf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn roundf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __roundf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn truncf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __truncf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
extern "C" {
    pub fn __remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
extern "C" {
    pub fn lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn roundevenf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __roundevenf64x(__x: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
extern "C" {
    pub fn canonicalizef64x(__cx: *mut _Float64x, __x: *const _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf64x(__x: *const _Float64x, __y: *const _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf64x(__x: *const _Float64x, __y: *const _Float64x)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
extern "C" {
    pub fn __getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
extern "C" {
    pub fn setpayloadf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fadd(__x: f64, __y: f64) -> f32;
}
extern "C" {
    pub fn fdiv(__x: f64, __y: f64) -> f32;
}
extern "C" {
    pub fn fmul(__x: f64, __y: f64) -> f32;
}
extern "C" {
    pub fn fsub(__x: f64, __y: f64) -> f32;
}
extern "C" {
    pub fn faddl(__x: u128, __y: u128) -> f32;
}
extern "C" {
    pub fn fdivl(__x: u128, __y: u128) -> f32;
}
extern "C" {
    pub fn fmull(__x: u128, __y: u128) -> f32;
}
extern "C" {
    pub fn fsubl(__x: u128, __y: u128) -> f32;
}
extern "C" {
    pub fn daddl(__x: u128, __y: u128) -> f64;
}
extern "C" {
    pub fn ddivl(__x: u128, __y: u128) -> f64;
}
extern "C" {
    pub fn dmull(__x: u128, __y: u128) -> f64;
}
extern "C" {
    pub fn dsubl(__x: u128, __y: u128) -> f64;
}
extern "C" {
    pub fn f32addf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
extern "C" {
    pub fn f32divf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
extern "C" {
    pub fn f32mulf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
extern "C" {
    pub fn f32subf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
extern "C" {
    pub fn f32addf64(__x: _Float64, __y: _Float64) -> _Float32;
}
extern "C" {
    pub fn f32divf64(__x: _Float64, __y: _Float64) -> _Float32;
}
extern "C" {
    pub fn f32mulf64(__x: _Float64, __y: _Float64) -> _Float32;
}
extern "C" {
    pub fn f32subf64(__x: _Float64, __y: _Float64) -> _Float32;
}
extern "C" {
    pub fn f32addf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
extern "C" {
    pub fn f32divf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
extern "C" {
    pub fn f32mulf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
extern "C" {
    pub fn f32subf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
extern "C" {
    pub fn f32xaddf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
extern "C" {
    pub fn f32xdivf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
extern "C" {
    pub fn f32xmulf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
extern "C" {
    pub fn f32xsubf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
extern "C" {
    pub fn f32xaddf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
extern "C" {
    pub fn f32xdivf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
extern "C" {
    pub fn f32xmulf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
extern "C" {
    pub fn f32xsubf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
extern "C" {
    pub fn f64addf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
extern "C" {
    pub fn f64divf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
extern "C" {
    pub fn f64mulf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
extern "C" {
    pub fn f64subf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_41 = 0;
pub const FP_INFINITE: _bindgen_ty_41 = 1;
pub const FP_ZERO: _bindgen_ty_41 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_41 = 3;
pub const FP_NORMAL: _bindgen_ty_41 = 4;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __iscanonicall(__x: u128) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __iseqsig_type {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout___iseqsig_type_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
}
#[test]
fn __bindgen_test_layout___iseqsig_type_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
}
#[test]
fn __bindgen_test_layout___iseqsig_type_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__iseqsig_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__iseqsig_type)
        )
    );
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut u32, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u32, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
extern "C" {
    pub fn wcscpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscat(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncat(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut u32, __s2: *const u32, __n: usize) -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const u32, __s2: *const u32, __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(__s1: *mut u32, __s2: *const u32, __n: usize, __loc: locale_t) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcschr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
extern "C" {
    pub fn wcschrnul(__s: *const u32, __wc: u32) -> *mut u32;
}
extern "C" {
    pub fn wcscspn(__wcs: *const u32, __reject: *const u32) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const u32, __accept: *const u32) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const u32, __accept: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsstr(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcstok(__s: *mut u32, __delim: *const u32, __ptr: *mut *mut u32) -> *mut u32;
}
extern "C" {
    pub fn wcslen(__s: *const u32) -> usize;
}
extern "C" {
    pub fn wcswcs(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsnlen(__s: *const u32, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(__s: *const u32, __c: u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemcmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemmove(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemset(__s: *mut u32, __c: u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn wmempcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: u32, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcwidth(__c: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcswidth(__s: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstod(__nptr: *const u32, __endptr: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const u32, __endptr: *mut *mut u32) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const u32, __endptr: *mut *mut u32) -> u128;
}
extern "C" {
    pub fn wcstof32(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32;
}
extern "C" {
    pub fn wcstof64(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64;
}
extern "C" {
    pub fn wcstof32x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32x;
}
extern "C" {
    pub fn wcstof64x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64x;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstoq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstouq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstol_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstod_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f64;
}
extern "C" {
    pub fn wcstof_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f32;
}
extern "C" {
    pub fn wcstold_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> u128;
}
extern "C" {
    pub fn wcstof32_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32;
}
extern "C" {
    pub fn wcstof64_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64;
}
extern "C" {
    pub fn wcstof32x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32x;
}
extern "C" {
    pub fn wcstof64x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64x;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut u32, __sizeloc: *mut usize) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut u32, __n: usize, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut u32,
        __n: usize,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: u32) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut u32, __n: ::std::os::raw::c_int, __stream: *mut __FILE) -> *mut u32;
}
extern "C" {
    pub fn fputws(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar_unlocked() -> wint_t;
}
extern "C" {
    pub fn fgetwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn fputwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar_unlocked(__wc: u32) -> wint_t;
}
extern "C" {
    pub fn fgetws_unlocked(
        __ws: *mut u32,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut u32;
}
extern "C" {
    pub fn fputws_unlocked(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn wcsftime_l(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    const UNINIT: ::std::mem::MaybeUninit<lconv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
pub const _ISupper: _bindgen_ty_43 = 256;
pub const _ISlower: _bindgen_ty_43 = 512;
pub const _ISalpha: _bindgen_ty_43 = 1024;
pub const _ISdigit: _bindgen_ty_43 = 2048;
pub const _ISxdigit: _bindgen_ty_43 = 4096;
pub const _ISspace: _bindgen_ty_43 = 8192;
pub const _ISprint: _bindgen_ty_43 = 16384;
pub const _ISgraph: _bindgen_ty_43 = 32768;
pub const _ISblank: _bindgen_ty_43 = 1;
pub const _IScntrl: _bindgen_ty_43 = 2;
pub const _ISpunct: _bindgen_ty_43 = 4;
pub const _ISalnum: _bindgen_ty_43 = 8;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isctype(
        __c: ::std::os::raw::c_int,
        __mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        __child_stack: *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcpu(
        arg1: *mut ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setns(
        __fd: ::std::os::raw::c_int,
        __nstype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout_timex() {
    const UNINIT: ::std::mem::MaybeUninit<timex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::std::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxerror) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esterror) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tolerance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsfreq) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stabil) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitcnt) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calcnt) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errcnt) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stbcnt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tai) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tai)
        )
    );
}
extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_44 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_44 = 1;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_45 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_45 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_45 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_45 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_45 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_45 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_45 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_45 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_45 = 0;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_46 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_46 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_46 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_46 = 1;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_47 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_47 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_47 = 2;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_48 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_48 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_48 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_48 = 0;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_49 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_49 = 1;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_50 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_50 = 1;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_51 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_51 = 1;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_52 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_52 = 1;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_53 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_53 = 1;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(
        __th: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_cleanup_class {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_class() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_class> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_class>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_class))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_class>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_class))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_class),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_class),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_class),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_class),
            "::",
            stringify!(__cancel_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent_np(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust_np(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust_np(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type __gthread_t = pthread_t;
pub type __gthread_key_t = pthread_key_t;
pub type __gthread_once_t = pthread_once_t;
pub type __gthread_mutex_t = pthread_mutex_t;
pub type __gthread_recursive_mutex_t = pthread_mutex_t;
pub type __gthread_cond_t = pthread_cond_t;
pub type __gthread_time_t = timespec;
pub type _Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
pub type wctype_t = ::std::os::raw::c_ulong;
pub const __ISwupper: _bindgen_ty_54 = 0;
pub const __ISwlower: _bindgen_ty_54 = 1;
pub const __ISwalpha: _bindgen_ty_54 = 2;
pub const __ISwdigit: _bindgen_ty_54 = 3;
pub const __ISwxdigit: _bindgen_ty_54 = 4;
pub const __ISwspace: _bindgen_ty_54 = 5;
pub const __ISwprint: _bindgen_ty_54 = 6;
pub const __ISwgraph: _bindgen_ty_54 = 7;
pub const __ISwblank: _bindgen_ty_54 = 8;
pub const __ISwcntrl: _bindgen_ty_54 = 9;
pub const __ISwpunct: _bindgen_ty_54 = 10;
pub const __ISwalnum: _bindgen_ty_54 = 11;
pub const _ISwupper: _bindgen_ty_54 = 16777216;
pub const _ISwlower: _bindgen_ty_54 = 33554432;
pub const _ISwalpha: _bindgen_ty_54 = 67108864;
pub const _ISwdigit: _bindgen_ty_54 = 134217728;
pub const _ISwxdigit: _bindgen_ty_54 = 268435456;
pub const _ISwspace: _bindgen_ty_54 = 536870912;
pub const _ISwprint: _bindgen_ty_54 = 1073741824;
pub const _ISwgraph: _bindgen_ty_54 = -2147483648;
pub const _ISwblank: _bindgen_ty_54 = 65536;
pub const _ISwcntrl: _bindgen_ty_54 = 131072;
pub const _ISwpunct: _bindgen_ty_54 = 262144;
pub const _ISwalnum: _bindgen_ty_54 = 524288;
pub type _bindgen_ty_54 = ::std::os::raw::c_int;
extern "C" {
    pub fn iswalnum(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctype(__property: *const ::std::os::raw::c_char) -> wctype_t;
}
extern "C" {
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towlower(__wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towupper(__wc: wint_t) -> wint_t;
}
pub type wctrans_t = *const __int32_t;
extern "C" {
    pub fn wctrans(__property: *const ::std::os::raw::c_char) -> wctrans_t;
}
extern "C" {
    pub fn towctrans(__wc: wint_t, __desc: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn iswalnum_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctype_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctype_t;
}
extern "C" {
    pub fn iswctype_l(__wc: wint_t, __desc: wctype_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towlower_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
extern "C" {
    pub fn towupper_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
extern "C" {
    pub fn wctrans_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctrans_t;
}
extern "C" {
    pub fn towctrans_l(__wc: wint_t, __desc: wctrans_t, __locale: locale_t) -> wint_t;
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = u128;
pub type __m128h = u128;
pub type __m128h_u = u128;
pub type __v8bf = u128;
pub type __m128bh = u128;
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strpbrk(
        __s: *mut ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_sequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_sequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_sequenced_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_sequenced_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_sequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_sequenced_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_parallel_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_parallel_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_parallel_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_parallel_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_parallel_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_unsequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_parallel_unsequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_parallel_unsequenced_policy>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(__pstl_execution_parallel_unsequenced_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_parallel_unsequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_parallel_unsequenced_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_unsequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_unsequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_unsequenced_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_unsequenced_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_unsequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_unsequenced_policy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v1L3seqE"]
    pub static __pstl_execution_seq: __pstl_execution_sequenced_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v1L3parE"]
    pub static __pstl_execution_par: __pstl_execution_parallel_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v1L9par_unseqE"]
    pub static __pstl_execution_par_unseq: __pstl_execution_parallel_unsequenced_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v1L5unseqE"]
    pub static __pstl_execution_unseq: __pstl_execution_unsequenced_policy;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_is_execution_policy {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_sequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_parallel_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_parallel_unsequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_unsequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
pub type __pstl___internal___enable_if_execution_policy = u8;
#[repr(C)]
pub struct open3d_geometry_Geometry__bindgen_vtable(::std::os::raw::c_void);
#[doc = " \\class Geometry\n\n \\brief The base geometry class."]
#[repr(C)]
pub struct open3d_geometry_Geometry {
    pub vtable_: *const open3d_geometry_Geometry__bindgen_vtable,
    #[doc = " Type of geometry from GeometryType."]
    pub geometry_type_: open3d_geometry_Geometry_GeometryType,
    #[doc = " Number of dimensions of the geometry."]
    pub dimension_: ::std::os::raw::c_int,
    pub name_: std_string,
}
#[doc = " Unspecified geometry type."]
pub const open3d_geometry_Geometry_GeometryType_Unspecified: open3d_geometry_Geometry_GeometryType =
    0;
#[doc = " PointCloud"]
pub const open3d_geometry_Geometry_GeometryType_PointCloud: open3d_geometry_Geometry_GeometryType =
    1;
#[doc = " VoxelGrid"]
pub const open3d_geometry_Geometry_GeometryType_VoxelGrid: open3d_geometry_Geometry_GeometryType =
    2;
#[doc = " Octree"]
pub const open3d_geometry_Geometry_GeometryType_Octree: open3d_geometry_Geometry_GeometryType = 3;
#[doc = " LineSet"]
pub const open3d_geometry_Geometry_GeometryType_LineSet: open3d_geometry_Geometry_GeometryType = 4;
#[doc = " MeshBase"]
pub const open3d_geometry_Geometry_GeometryType_MeshBase: open3d_geometry_Geometry_GeometryType = 5;
#[doc = " TriangleMesh"]
pub const open3d_geometry_Geometry_GeometryType_TriangleMesh:
    open3d_geometry_Geometry_GeometryType = 6;
#[doc = " HalfEdgeTriangleMesh"]
pub const open3d_geometry_Geometry_GeometryType_HalfEdgeTriangleMesh:
    open3d_geometry_Geometry_GeometryType = 7;
#[doc = " Image"]
pub const open3d_geometry_Geometry_GeometryType_Image: open3d_geometry_Geometry_GeometryType = 8;
#[doc = " RGBDImage"]
pub const open3d_geometry_Geometry_GeometryType_RGBDImage: open3d_geometry_Geometry_GeometryType =
    9;
#[doc = " TetraMesh"]
pub const open3d_geometry_Geometry_GeometryType_TetraMesh: open3d_geometry_Geometry_GeometryType =
    10;
#[doc = " OrientedBoundingBox"]
pub const open3d_geometry_Geometry_GeometryType_OrientedBoundingBox:
    open3d_geometry_Geometry_GeometryType = 11;
#[doc = " AxisAlignedBoundingBox"]
pub const open3d_geometry_Geometry_GeometryType_AxisAlignedBoundingBox:
    open3d_geometry_Geometry_GeometryType = 12;
#[doc = " \\enum GeometryType\n\n \\brief Specifies possible geometry types."]
pub type open3d_geometry_Geometry_GeometryType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_open3d_geometry_Geometry() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_Geometry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_Geometry>(),
        48usize,
        concat!("Size of: ", stringify!(open3d_geometry_Geometry))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_Geometry>(),
        8usize,
        concat!("Alignment of ", stringify!(open3d_geometry_Geometry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geometry_type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_Geometry),
            "::",
            stringify!(geometry_type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dimension_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_Geometry),
            "::",
            stringify!(dimension_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_Geometry),
            "::",
            stringify!(name_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_AxisAlignedBoundingBox {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_OrientedBoundingBox {
    _unused: [u8; 0],
}
#[doc = " \\class Geometry3D\n\n \\brief The base geometry class for 3D geometries.\n\n Main class for 3D geometries, Derives all data from Geometry Base class."]
#[repr(C)]
pub struct open3d_geometry_Geometry3D {
    pub _base: open3d_geometry_Geometry,
}
#[test]
fn bindgen_test_layout_open3d_geometry_Geometry3D() {
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_Geometry3D>(),
        48usize,
        concat!("Size of: ", stringify!(open3d_geometry_Geometry3D))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_Geometry3D>(),
        8usize,
        concat!("Alignment of ", stringify!(open3d_geometry_Geometry3D))
    );
}
extern "C" {
    #[doc = " Get Rotation Matrix from XYZ RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromXYZERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromXYZ(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from YZX RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromYZXERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromYZX(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from ZXY RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromZXYERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromZXY(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from XZY RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromXZYERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromXZY(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from ZYX RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromZYXERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromZYX(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from YXZ RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D24GetRotationMatrixFromYXZERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromYXZ(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from AxisAngle RotationType."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D30GetRotationMatrixFromAxisAngleERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromAxisAngle(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Get Rotation Matrix from Quaternion."]
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D31GetRotationMatrixFromQuaternionERKN5Eigen6MatrixIdLi4ELi1ELi0ELi4ELi1EEE"]
    pub fn open3d_geometry_Geometry3D_GetRotationMatrixFromQuaternion(
        rotation: *const Eigen_Vector4d,
    ) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Compute min bound of a list points."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D15ComputeMinBoundERKSt6vectorIN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEESaIS5_EE"]
    pub fn open3d_geometry_Geometry3D_ComputeMinBound(
        this: *const open3d_geometry_Geometry3D,
        points: *const std_vector,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[doc = " Compute max bound of a list points."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D15ComputeMaxBoundERKSt6vectorIN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEESaIS5_EE"]
    pub fn open3d_geometry_Geometry3D_ComputeMaxBound(
        this: *const open3d_geometry_Geometry3D,
        points: *const std_vector,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[doc = " Computer center of a list of points."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D13ComputeCenterERKSt6vectorIN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEESaIS5_EE"]
    pub fn open3d_geometry_Geometry3D_ComputeCenter(
        this: *const open3d_geometry_Geometry3D,
        points: *const std_vector,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[doc = " \\brief Resizes the colors vector and paints a uniform color.\n\n \\param colors An array of eigen vectors specifies colors in RGB.\n \\param size The resultant size of the colors array.\n \\param color The final color in which the colors will be painted."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D26ResizeAndPaintUniformColorERSt6vectorIN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEESaIS5_EEmRKS5_"]
    pub fn open3d_geometry_Geometry3D_ResizeAndPaintUniformColor(
        this: *const open3d_geometry_Geometry3D,
        colors: *mut std_vector,
        size: usize,
        color: *const Eigen_Vector3d,
    );
}
extern "C" {
    #[doc = " \\brief Transforms all points with the transformation matrix.\n\n \\param transformation 4x4 matrix for transformation.\n \\param points A list of points to be transformed."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D15TransformPointsERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEERSt6vectorINS3_IdLi3ELi1ELi0ELi3ELi1EEESaIS8_EE"]
    pub fn open3d_geometry_Geometry3D_TransformPoints(
        this: *const open3d_geometry_Geometry3D,
        transformation: *const Eigen_Matrix4d,
        points: *mut std_vector,
    );
}
extern "C" {
    #[doc = " \\brief Transforms the normals with the transformation matrix.\n\n \\param transformation 4x4 matrix for transformation.\n \\param normals A list of normals to be transformed."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D16TransformNormalsERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEERSt6vectorINS3_IdLi3ELi1ELi0ELi3ELi1EEESaIS8_EE"]
    pub fn open3d_geometry_Geometry3D_TransformNormals(
        this: *const open3d_geometry_Geometry3D,
        transformation: *const Eigen_Matrix4d,
        normals: *mut std_vector,
    );
}
extern "C" {
    #[doc = " \\brief Transforms all covariance matrices with the transformation.\n\n \\param transformation 4x4 matrix for transformation.\n \\param covariances A list of covariance matrices to be transformed."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D20TransformCovariancesERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEERSt6vectorINS3_IdLi3ELi3ELi0ELi3ELi3EEESaIS8_EE"]
    pub fn open3d_geometry_Geometry3D_TransformCovariances(
        this: *const open3d_geometry_Geometry3D,
        transformation: *const Eigen_Matrix4d,
        covariances: *mut std_vector,
    );
}
extern "C" {
    #[doc = " \\brief Apply translation to the geometry coordinates.\n\n \\param translation A 3D vector to transform the geometry.\n \\param points A list of points to be transformed.\n \\param relative If `true`, the \\p translation is directly applied to the\n \\p points. Otherwise, the center of the \\p points is moved to the \\p\n translation."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D15TranslatePointsERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEERSt6vectorIS4_SaIS4_EEb"]
    pub fn open3d_geometry_Geometry3D_TranslatePoints(
        this: *const open3d_geometry_Geometry3D,
        translation: *const Eigen_Vector3d,
        points: *mut std_vector,
        relative: bool,
    );
}
extern "C" {
    #[doc = " \\brief Scale the coordinates of all points by the scaling factor \\p\n scale.\n\n \\param scale The scale factor that is used to resize the geometry\n \\param points A list of points to be transformed\n \\param center Scale center that is used to resize the geometry.."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D11ScalePointsEdRSt6vectorIN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEESaIS5_EERKS5_"]
    pub fn open3d_geometry_Geometry3D_ScalePoints(
        this: *const open3d_geometry_Geometry3D,
        scale: f64,
        points: *mut std_vector,
        center: *const Eigen_Vector3d,
    );
}
extern "C" {
    #[doc = " \\brief Rotate all points with the rotation matrix \\p R.\n\n \\param R A 3x3 rotation matrix\n defines the axis of rotation and the norm the angle around this axis.\n \\param points A list of points to be transformed.\n \\param center Rotation center that is used for the rotation."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D12RotatePointsERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEERSt6vectorINS3_IdLi3ELi1ELi0ELi3ELi1EEESaIS8_EERKS8_"]
    pub fn open3d_geometry_Geometry3D_RotatePoints(
        this: *const open3d_geometry_Geometry3D,
        R: *const Eigen_Matrix3d,
        points: *mut std_vector,
        center: *const Eigen_Vector3d,
    );
}
extern "C" {
    #[doc = " \\brief Rotate all normals with the rotation matrix \\p R.\n\n \\param R A 3x3 rotation matrix\n \\param normals A list of normals to be transformed."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D13RotateNormalsERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEERSt6vectorINS3_IdLi3ELi1ELi0ELi3ELi1EEESaIS8_EE"]
    pub fn open3d_geometry_Geometry3D_RotateNormals(
        this: *const open3d_geometry_Geometry3D,
        R: *const Eigen_Matrix3d,
        normals: *mut std_vector,
    );
}
extern "C" {
    #[doc = " \\brief Rotate all covariance matrices with the rotation matrix \\p R.\n\n \\param R A 3x3 rotation matrix\n \\param covariances A list of covariance matrices to be transformed."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10Geometry3D17RotateCovariancesERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEERSt6vectorIS4_SaIS4_EE"]
    pub fn open3d_geometry_Geometry3D_RotateCovariances(
        this: *const open3d_geometry_Geometry3D,
        R: *const Eigen_Matrix3d,
        covariances: *mut std_vector,
    );
}
impl open3d_geometry_Geometry3D {
    #[inline]
    pub unsafe fn GetRotationMatrixFromXYZ(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromXYZ(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromYZX(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromYZX(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromZXY(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromZXY(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromXZY(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromXZY(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromZYX(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromZYX(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromYXZ(rotation: *const Eigen_Vector3d) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromYXZ(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromAxisAngle(
        rotation: *const Eigen_Vector3d,
    ) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromAxisAngle(rotation)
    }
    #[inline]
    pub unsafe fn GetRotationMatrixFromQuaternion(
        rotation: *const Eigen_Vector4d,
    ) -> Eigen_Matrix3d {
        open3d_geometry_Geometry3D_GetRotationMatrixFromQuaternion(rotation)
    }
    #[inline]
    pub unsafe fn ComputeMinBound(&self, points: *const std_vector) -> Eigen_Vector3d {
        open3d_geometry_Geometry3D_ComputeMinBound(self, points)
    }
    #[inline]
    pub unsafe fn ComputeMaxBound(&self, points: *const std_vector) -> Eigen_Vector3d {
        open3d_geometry_Geometry3D_ComputeMaxBound(self, points)
    }
    #[inline]
    pub unsafe fn ComputeCenter(&self, points: *const std_vector) -> Eigen_Vector3d {
        open3d_geometry_Geometry3D_ComputeCenter(self, points)
    }
    #[inline]
    pub unsafe fn ResizeAndPaintUniformColor(
        &self,
        colors: *mut std_vector,
        size: usize,
        color: *const Eigen_Vector3d,
    ) {
        open3d_geometry_Geometry3D_ResizeAndPaintUniformColor(self, colors, size, color)
    }
    #[inline]
    pub unsafe fn TransformPoints(
        &self,
        transformation: *const Eigen_Matrix4d,
        points: *mut std_vector,
    ) {
        open3d_geometry_Geometry3D_TransformPoints(self, transformation, points)
    }
    #[inline]
    pub unsafe fn TransformNormals(
        &self,
        transformation: *const Eigen_Matrix4d,
        normals: *mut std_vector,
    ) {
        open3d_geometry_Geometry3D_TransformNormals(self, transformation, normals)
    }
    #[inline]
    pub unsafe fn TransformCovariances(
        &self,
        transformation: *const Eigen_Matrix4d,
        covariances: *mut std_vector,
    ) {
        open3d_geometry_Geometry3D_TransformCovariances(self, transformation, covariances)
    }
    #[inline]
    pub unsafe fn TranslatePoints(
        &self,
        translation: *const Eigen_Vector3d,
        points: *mut std_vector,
        relative: bool,
    ) {
        open3d_geometry_Geometry3D_TranslatePoints(self, translation, points, relative)
    }
    #[inline]
    pub unsafe fn ScalePoints(
        &self,
        scale: f64,
        points: *mut std_vector,
        center: *const Eigen_Vector3d,
    ) {
        open3d_geometry_Geometry3D_ScalePoints(self, scale, points, center)
    }
    #[inline]
    pub unsafe fn RotatePoints(
        &self,
        R: *const Eigen_Matrix3d,
        points: *mut std_vector,
        center: *const Eigen_Vector3d,
    ) {
        open3d_geometry_Geometry3D_RotatePoints(self, R, points, center)
    }
    #[inline]
    pub unsafe fn RotateNormals(&self, R: *const Eigen_Matrix3d, normals: *mut std_vector) {
        open3d_geometry_Geometry3D_RotateNormals(self, R, normals)
    }
    #[inline]
    pub unsafe fn RotateCovariances(&self, R: *const Eigen_Matrix3d, covariances: *mut std_vector) {
        open3d_geometry_Geometry3D_RotateCovariances(self, R, covariances)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10Geometry3D6RotateERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEE"]
    pub fn open3d_geometry_Geometry3D_Rotate1(
        this: *mut ::std::os::raw::c_void,
        R: *const Eigen_Matrix3d,
    ) -> *mut open3d_geometry_Geometry3D;
}
#[repr(C)]
pub struct open3d_geometry_KDTreeSearchParam__bindgen_vtable(::std::os::raw::c_void);
#[doc = " \\class KDTreeSearchParam\n\n \\brief Base class for KDTree search parameters."]
#[repr(C)]
#[derive(Debug)]
pub struct open3d_geometry_KDTreeSearchParam {
    pub vtable_: *const open3d_geometry_KDTreeSearchParam__bindgen_vtable,
    pub search_type_: open3d_geometry_KDTreeSearchParam_SearchType,
}
pub const open3d_geometry_KDTreeSearchParam_SearchType_Knn:
    open3d_geometry_KDTreeSearchParam_SearchType = 0;
pub const open3d_geometry_KDTreeSearchParam_SearchType_Radius:
    open3d_geometry_KDTreeSearchParam_SearchType = 1;
pub const open3d_geometry_KDTreeSearchParam_SearchType_Hybrid:
    open3d_geometry_KDTreeSearchParam_SearchType = 2;
#[doc = " \\enum SearchType\n\n \\brief Specifies the search type for the search."]
pub type open3d_geometry_KDTreeSearchParam_SearchType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_open3d_geometry_KDTreeSearchParam() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_KDTreeSearchParam> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_KDTreeSearchParam>(),
        16usize,
        concat!("Size of: ", stringify!(open3d_geometry_KDTreeSearchParam))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_KDTreeSearchParam>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(open3d_geometry_KDTreeSearchParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).search_type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_KDTreeSearchParam),
            "::",
            stringify!(search_type_)
        )
    );
}
#[doc = " \\class KDTreeSearchParamKNN\n\n \\brief KDTree search parameters for pure KNN search."]
#[repr(C)]
#[derive(Debug)]
pub struct open3d_geometry_KDTreeSearchParamKNN {
    pub _base: open3d_geometry_KDTreeSearchParam,
    #[doc = " Number of the neighbors that will be searched."]
    pub knn_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_open3d_geometry_KDTreeSearchParamKNN() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_KDTreeSearchParamKNN> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_KDTreeSearchParamKNN>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(open3d_geometry_KDTreeSearchParamKNN)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_KDTreeSearchParamKNN>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(open3d_geometry_KDTreeSearchParamKNN)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).knn_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_KDTreeSearchParamKNN),
            "::",
            stringify!(knn_)
        )
    );
}
#[doc = " \\class KDTreeSearchParamRadius\n\n \\brief KDTree search parameters for pure radius search."]
#[repr(C)]
#[derive(Debug)]
pub struct open3d_geometry_KDTreeSearchParamRadius {
    pub _base: open3d_geometry_KDTreeSearchParam,
    #[doc = " Search radius."]
    pub radius_: f64,
}
#[test]
fn bindgen_test_layout_open3d_geometry_KDTreeSearchParamRadius() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_KDTreeSearchParamRadius> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_KDTreeSearchParamRadius>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(open3d_geometry_KDTreeSearchParamRadius)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_KDTreeSearchParamRadius>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(open3d_geometry_KDTreeSearchParamRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_KDTreeSearchParamRadius),
            "::",
            stringify!(radius_)
        )
    );
}
#[doc = " \\class KDTreeSearchParamHybrid\n\n \\brief KDTree search parameters for hybrid KNN and radius search."]
#[repr(C)]
#[derive(Debug)]
pub struct open3d_geometry_KDTreeSearchParamHybrid {
    pub _base: open3d_geometry_KDTreeSearchParam,
    #[doc = " Search radius."]
    pub radius_: f64,
    #[doc = " At maximum, max_nn neighbors will be searched."]
    pub max_nn_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_open3d_geometry_KDTreeSearchParamHybrid() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_KDTreeSearchParamHybrid> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_KDTreeSearchParamHybrid>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(open3d_geometry_KDTreeSearchParamHybrid)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_KDTreeSearchParamHybrid>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(open3d_geometry_KDTreeSearchParamHybrid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_KDTreeSearchParamHybrid),
            "::",
            stringify!(radius_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_nn_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_KDTreeSearchParamHybrid),
            "::",
            stringify!(max_nn_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_Image {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_RGBDImage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_TriangleMesh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_geometry_VoxelGrid {
    _unused: [u8; 0],
}
#[doc = " \\class PointCloud\n\n \\brief A point cloud consists of point coordinates, and optionally point\n colors and point normals."]
#[repr(C)]
pub struct open3d_geometry_PointCloud {
    pub _base: open3d_geometry_Geometry3D,
    #[doc = " Points coordinates."]
    pub points_: std_vector,
    #[doc = " Points normals."]
    pub normals_: std_vector,
    #[doc = " RGB colors of points."]
    pub colors_: std_vector,
    #[doc = " Covariance Matrix for each point"]
    pub covariances_: std_vector,
}
#[test]
fn bindgen_test_layout_open3d_geometry_PointCloud() {
    const UNINIT: ::std::mem::MaybeUninit<open3d_geometry_PointCloud> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open3d_geometry_PointCloud>(),
        144usize,
        concat!("Size of: ", stringify!(open3d_geometry_PointCloud))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_geometry_PointCloud>(),
        8usize,
        concat!("Alignment of ", stringify!(open3d_geometry_PointCloud))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_PointCloud),
            "::",
            stringify!(points_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normals_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_PointCloud),
            "::",
            stringify!(normals_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors_) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_PointCloud),
            "::",
            stringify!(colors_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).covariances_) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(open3d_geometry_PointCloud),
            "::",
            stringify!(covariances_)
        )
    );
}
extern "C" {
    #[doc = " \\brief Removes all points from the point cloud that have a nan entry, or\n infinite entries. It also removes the corresponding attributes\n associated with the non-finite point such as normals, covariances and\n color entries. It doesn't re-computes these attributes after removing\n non-finite points.\n\n \\param remove_nan Remove NaN values from the PointCloud.\n \\param remove_infinite Remove infinite values from the PointCloud."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud21RemoveNonFinitePointsEbb"]
    pub fn open3d_geometry_PointCloud_RemoveNonFinitePoints(
        this: *mut open3d_geometry_PointCloud,
        remove_nan: bool,
        remove_infinite: bool,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[doc = " \\brief Removes duplicated points, i.e., points that have identical\n coordinates. It also removes the corresponding attributes associated\n with the non-finite point such as normals, covariances and color\n entries. It doesn't re-computes these attributes after removing\n duplicated points."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud22RemoveDuplicatedPointsEv"]
    pub fn open3d_geometry_PointCloud_RemoveDuplicatedPoints(
        this: *mut open3d_geometry_PointCloud,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[doc = " \\brief Selects points from \\p input pointcloud, with indices in \\p\n indices, and returns a new point-cloud with selected points.\n\n \\param indices Indices of points to be selected.\n \\param invert Set to `True` to invert the selection of indices."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud13SelectByIndexERKSt6vectorImSaImEEb"]
    pub fn open3d_geometry_PointCloud_SelectByIndex(
        this: *const open3d_geometry_PointCloud,
        indices: *const std_vector,
        invert: bool,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Downsample input pointcloud with a voxel, and return a new\n point-cloud. Normals, covariances and colors are averaged if they exist.\n\n \\param voxel_size Defines the resolution of the voxel grid,\n smaller value leads to denser output point cloud."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud15VoxelDownSampleEd"]
    pub fn open3d_geometry_PointCloud_VoxelDownSample(
        this: *const open3d_geometry_PointCloud,
        voxel_size: f64,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to downsample using geometry.PointCloud.VoxelDownSample\n\n Also records point cloud index before downsampling.\n\n \\param voxel_size Voxel size to downsample into.\n \\param min_bound Minimum coordinate of voxel boundaries\n \\param max_bound Maximum coordinate of voxel boundaries\n \\param approximate_class Whether to approximate."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud23VoxelDownSampleAndTraceEdRKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEES6_b"]
    pub fn open3d_geometry_PointCloud_VoxelDownSampleAndTrace(
        this: *const open3d_geometry_PointCloud,
        voxel_size: f64,
        min_bound: *const Eigen_Vector3d,
        max_bound: *const Eigen_Vector3d,
        approximate_class: bool,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Function to downsample input pointcloud into output pointcloud\n uniformly.\n\n The sample is performed in the order of the points with the 0-th point\n always chosen, not at random.\n\n \\param every_k_points Sample rate, the selected point indices are [0, k,\n 2k, ]."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud17UniformDownSampleEm"]
    pub fn open3d_geometry_PointCloud_UniformDownSample(
        this: *const open3d_geometry_PointCloud,
        every_k_points: usize,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to downsample input pointcloud into output pointcloud\n randomly.\n\n The sample is performed by randomly selecting the index of the points\n in the pointcloud.\n\n \\param sampling_ratio Sampling ratio, the ratio of sample to total\n number of points in the pointcloud."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud16RandomDownSampleEd"]
    pub fn open3d_geometry_PointCloud_RandomDownSample(
        this: *const open3d_geometry_PointCloud,
        sampling_ratio: f64,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to downsample input pointcloud into output pointcloud\n with a set of points has farthest distance.\n\n The sample is performed by selecting the farthest point from previous\n selected points iteratively.\n\n \\param num_samples Number of points to be sampled."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud23FarthestPointDownSampleEm"]
    pub fn open3d_geometry_PointCloud_FarthestPointDownSample(
        this: *const open3d_geometry_PointCloud,
        num_samples: usize,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to crop pointcloud into output pointcloud\n\n All points with coordinates outside the bounding box \\p bbox are\n clipped.\n\n \\param bbox AxisAlignedBoundingBox to crop points."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud4CropERKNS0_22AxisAlignedBoundingBoxE"]
    pub fn open3d_geometry_PointCloud_Crop(
        this: *const open3d_geometry_PointCloud,
        bbox: *const open3d_geometry_AxisAlignedBoundingBox,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to crop pointcloud into output pointcloud\n\n All points with coordinates outside the bounding box \\p bbox are\n clipped.\n\n \\param bbox OrientedBoundingBox to crop points."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud4CropERKNS0_19OrientedBoundingBoxE"]
    pub fn open3d_geometry_PointCloud_Crop1(
        this: *const open3d_geometry_PointCloud,
        bbox: *const open3d_geometry_OrientedBoundingBox,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Function to remove points that have less than \\p nb_points in a\n sphere of a given radius.\n\n \\param nb_points Number of points within the radius.\n \\param search_radius Radius of the sphere.\n \\param print_progress Whether to print the progress bar."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud20RemoveRadiusOutliersEmdb"]
    pub fn open3d_geometry_PointCloud_RemoveRadiusOutliers(
        this: *const open3d_geometry_PointCloud,
        nb_points: usize,
        search_radius: f64,
        print_progress: bool,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Function to remove points that are further away from their\n \\p nb_neighbor neighbors in average.\n\n \\param nb_neighbors Number of neighbors around the target point.\n \\param std_ratio Standard deviation ratio."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud25RemoveStatisticalOutliersEmdb"]
    pub fn open3d_geometry_PointCloud_RemoveStatisticalOutliers(
        this: *const open3d_geometry_PointCloud,
        nb_neighbors: usize,
        std_ratio: f64,
        print_progress: bool,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Function to compute the normals of a point cloud.\n\n Normals are oriented with respect to the input point cloud if normals\n exist.\n\n \\param search_param The KDTree search parameters for neighborhood\n search.\n \\param fast_normal_computation If true, the normal estimation\n uses a non-iterative method to extract the eigenvector from the\n covariance matrix. This is faster, but is not as numerical stable."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud15EstimateNormalsERKNS0_17KDTreeSearchParamEb"]
    pub fn open3d_geometry_PointCloud_EstimateNormals(
        this: *mut open3d_geometry_PointCloud,
        search_param: *const open3d_geometry_KDTreeSearchParam,
        fast_normal_computation: bool,
    );
}
extern "C" {
    #[doc = " \\brief Function to orient the normals of a point cloud.\n\n \\param orientation_reference Normals are oriented with respect to\n orientation_reference."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud33OrientNormalsToAlignWithDirectionERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_PointCloud_OrientNormalsToAlignWithDirection(
        this: *mut open3d_geometry_PointCloud,
        orientation_reference: *const Eigen_Vector3d,
    );
}
extern "C" {
    #[doc = " \\brief Function to orient the normals of a point cloud.\n\n \\param camera_location Normals are oriented with towards the\n camera_location."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud34OrientNormalsTowardsCameraLocationERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_PointCloud_OrientNormalsTowardsCameraLocation(
        this: *mut open3d_geometry_PointCloud,
        camera_location: *const Eigen_Vector3d,
    );
}
extern "C" {
    #[doc = " \\brief Function to consistently orient estimated normals based on\n consistent tangent planes as described in Hoppe et al., \"Surface\n Reconstruction from Unorganized Points\", 1992.\n\n \\param k k nearest neighbour for graph reconstruction for normal\n propagation."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud35OrientNormalsConsistentTangentPlaneEm"]
    pub fn open3d_geometry_PointCloud_OrientNormalsConsistentTangentPlane(
        this: *mut open3d_geometry_PointCloud,
        k: usize,
    );
}
extern "C" {
    #[doc = " \\brief Function to compute the point to point distances between point\n clouds.\n\n For each point in the \\p source point cloud, compute the distance to the\n \\p target point cloud.\n\n \\param target The target point cloud."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud25ComputePointCloudDistanceERKS1_"]
    pub fn open3d_geometry_PointCloud_ComputePointCloudDistance(
        this: *mut open3d_geometry_PointCloud,
        target: *const open3d_geometry_PointCloud,
    ) -> std_vector;
}
extern "C" {
    #[doc = " \\brief Static function to compute the covariance matrix for each point\n of a point cloud. Doesn't change the input PointCloud, just outputs the\n covariance matrices.\n\n\n \\param input PointCloud to use for covariance computation \\param\n search_param The KDTree search parameters for neighborhood search."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud27EstimatePerPointCovariancesERKS1_RKNS0_17KDTreeSearchParamE"]
    pub fn open3d_geometry_PointCloud_EstimatePerPointCovariances(
        input: *const open3d_geometry_PointCloud,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    ) -> std_vector;
}
extern "C" {
    #[doc = " \\brief Function to compute the covariance matrix for each point of a\n point cloud.\n\n\n \\param search_param The KDTree search parameters for neighborhood\n search."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud19EstimateCovariancesERKNS0_17KDTreeSearchParamE"]
    pub fn open3d_geometry_PointCloud_EstimateCovariances(
        this: *mut open3d_geometry_PointCloud,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    );
}
extern "C" {
    #[doc = " Function to compute the mean and covariance matrix\n of a point cloud."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud24ComputeMeanAndCovarianceEv"]
    pub fn open3d_geometry_PointCloud_ComputeMeanAndCovariance(
        this: *const open3d_geometry_PointCloud,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Function to compute the Mahalanobis distance for points\n in an input point cloud.\n\n See: https://en.wikipedia.org/wiki/Mahalanobis_distance"]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud26ComputeMahalanobisDistanceEv"]
    pub fn open3d_geometry_PointCloud_ComputeMahalanobisDistance(
        this: *const open3d_geometry_PointCloud,
    ) -> std_vector;
}
extern "C" {
    #[doc = " Function to compute the distance from a point to its nearest neighbor in\n the input point cloud"]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud30ComputeNearestNeighborDistanceEv"]
    pub fn open3d_geometry_PointCloud_ComputeNearestNeighborDistance(
        this: *const open3d_geometry_PointCloud,
    ) -> std_vector;
}
extern "C" {
    #[doc = " Function that computes the convex hull of the point cloud using qhull\n \\param joggle_inputs If true allows the algorithm to add random noise\n        to the points to work around degenerate inputs. This adds the\n        'QJ' option to the qhull command.\n \\returns The triangle mesh of the convex hull and the list of point\n          indices that are part of the convex hull."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud17ComputeConvexHullEb"]
    pub fn open3d_geometry_PointCloud_ComputeConvexHull(
        this: *const open3d_geometry_PointCloud,
        joggle_inputs: bool,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief This is an implementation of the Hidden Point Removal operator\n described in Katz et. al. 'Direct Visibility of Point Sets', 2007.\n\n Additional information about the choice of radius\n for noisy point clouds can be found in Mehra et. al. 'Visibility of\n Noisy Point Cloud Data', 2010.\n\n \\param camera_location All points not visible from that location will be\n removed. \\param radius The radius of the spherical projection."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud18HiddenPointRemovalERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEd"]
    pub fn open3d_geometry_PointCloud_HiddenPointRemoval(
        this: *const open3d_geometry_PointCloud,
        camera_location: *const Eigen_Vector3d,
        radius: f64,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Cluster PointCloud using the DBSCAN algorithm\n Ester et al., \"A Density-Based Algorithm for Discovering Clusters\n in Large Spatial Databases with Noise\", 1996\n\n Returns a list of point labels, -1 indicates noise according to\n the algorithm.\n\n \\param eps Density parameter that is used to find neighbouring points.\n \\param min_points Minimum number of points to form a cluster.\n \\param print_progress If `true` the progress is visualized in the\n console."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud13ClusterDBSCANEdmb"]
    pub fn open3d_geometry_PointCloud_ClusterDBSCAN(
        this: *const open3d_geometry_PointCloud,
        eps: f64,
        min_points: usize,
        print_progress: bool,
    ) -> std_vector;
}
extern "C" {
    #[doc = " \\brief Segment PointCloud plane using the RANSAC algorithm.\n\n \\param distance_threshold Max distance a point can be from the plane\n model, and still be considered an inlier.\n \\param ransac_n Number of initial points to be considered inliers in\n each iteration.\n \\param num_iterations Maximum number of iterations.\n \\param probability Expected probability of finding the optimal plane.\n \\return Returns the plane model ax + by + cz + d = 0 and the indices of\n the plane inliers."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud12SegmentPlaneEdiid"]
    pub fn open3d_geometry_PointCloud_SegmentPlane(
        this: *const open3d_geometry_PointCloud,
        distance_threshold: f64,
        ransac_n: ::std::os::raw::c_int,
        num_iterations: ::std::os::raw::c_int,
        probability: f64,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " \\brief Robustly detect planar patches in the point cloud using.\n Arajo and Oliveira, A robust statistics approach for plane\n detection in unorganized point clouds, Pattern Recognition, 2020.\n\n \\param normal_variance_threshold_deg Planes having point normals with\n high variance are rejected. The default value is 60 deg. Larger values\n would allow more noisy planes to be detected. \\param coplanarity_deg The\n curvature of plane detections are scored using the angle between the\n plane's normal vector and an auxiliary vector. An ideal plane would have\n a score of 90 deg. The default value for this threshold is 75 deg, and\n detected planes with scores lower than this are rejected. Large\n threshold values encourage a tighter distribution of points around the\n detected plane, i.e., less curvature. \\param outlier_ratio Maximum\n allowable ratio of outliers in associated plane points before plane is\n rejected. \\param min_plane_edge_length A patch's largest edge must\n greater than this value to be considered a true planar patch. If set to\n 0, defaults to 1% of largest span of point cloud. \\param min_num_points\n Determines how deep the associated octree becomes and how many points\n must be used for estimating a plane. If set to 0, defaults to 0.1% of\n the number of points in point cloud. \\param search_param Point neighbors\n are used to grow and merge detected planes. Neighbors are found with\n KDTree search using these params. More neighbors results in higher\n quality patches at the cost of compute. \\return Returns a list of\n detected planar patches, represented as OrientedBoundingBox objects,\n with the third column (z) of R indicating the planar patch normal\n vector. The extent in the z direction is non-zero so that the\n OrientedBoundingBox contains the points that contribute to the plane\n detection."]
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud19DetectPlanarPatchesEddddmRKNS0_17KDTreeSearchParamE"]
    pub fn open3d_geometry_PointCloud_DetectPlanarPatches(
        this: *const open3d_geometry_PointCloud,
        normal_variance_threshold_deg: f64,
        coplanarity_deg: f64,
        outlier_ratio: f64,
        min_plane_edge_length: f64,
        min_num_points: usize,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    ) -> std_vector;
}
extern "C" {
    #[doc = " \\brief Factory function to create a pointcloud from a depth image and a\n camera model.\n\n Given depth value d at (u, v) image coordinate, the corresponding 3d\n point is: z = d / depth_scale\\n x = (u - cx) * z / fx\\n y = (v - cy) * z\n / fy\\n\n\n \\param depth The input depth image can be either a float image, or a\n uint16_t image. \\param intrinsic Intrinsic parameters of the camera.\n \\param extrinsic Extrinsic parameters of the camera.\n \\param depth_scale The depth is scaled by 1 / \\p depth_scale.\n \\param depth_trunc Truncated at \\p depth_trunc distance.\n \\param stride Sampling factor to support coarse point cloud extraction.\n\n \\return An empty pointcloud if the conversion fails.\n If \\param project_valid_depth_only is true, return point cloud, which\n doesn't\n have nan point. If the value is false, return point cloud, which has\n a point for each pixel, whereas invalid depth results in NaN points."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud20CreateFromDepthImageERKNS0_5ImageERKNS_6camera22PinholeCameraIntrinsicERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEEddib"]
    pub fn open3d_geometry_PointCloud_CreateFromDepthImage(
        depth: *const open3d_geometry_Image,
        intrinsic: *const open3d_camera_PinholeCameraIntrinsic,
        extrinsic: *const Eigen_Matrix4d,
        depth_scale: f64,
        depth_trunc: f64,
        stride: ::std::os::raw::c_int,
        project_valid_depth_only: bool,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Factory function to create a pointcloud from an RGB-D image and a\n camera model.\n\n Given depth value d at (u, v) image coordinate, the corresponding 3d\n point is: z = d / depth_scale\\n x = (u - cx) * z / fx\\n y = (v - cy) * z\n / fy\\n\n\n \\param image The input image.\n \\param intrinsic Intrinsic parameters of the camera.\n \\param extrinsic Extrinsic parameters of the camera.\n\n \\return An empty pointcloud if the conversion fails.\n If \\param project_valid_depth_only is true, return point cloud, which\n doesn't\n have nan point. If the value is false, return point cloud, which has\n a point for each pixel, whereas invalid depth results in NaN points."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud19CreateFromRGBDImageERKNS0_9RGBDImageERKNS_6camera22PinholeCameraIntrinsicERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEEb"]
    pub fn open3d_geometry_PointCloud_CreateFromRGBDImage(
        image: *const open3d_geometry_RGBDImage,
        intrinsic: *const open3d_camera_PinholeCameraIntrinsic,
        extrinsic: *const Eigen_Matrix4d,
        project_valid_depth_only: bool,
    ) -> std_shared_ptr;
}
extern "C" {
    #[doc = " \\brief Factory Function to create a PointCloud from a VoxelGrid.\n\n It transforms the voxel centers to 3D points using the original point\n cloud coordinate (with respect to the center of the voxel grid).\n\n \\param voxel_grid The input VoxelGrid."]
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud19CreateFromVoxelGridERKNS0_9VoxelGridE"]
    pub fn open3d_geometry_PointCloud_CreateFromVoxelGrid(
        voxel_grid: *const open3d_geometry_VoxelGrid,
    ) -> std_shared_ptr;
}
impl open3d_geometry_PointCloud {
    #[inline]
    pub unsafe fn RemoveNonFinitePoints(
        &mut self,
        remove_nan: bool,
        remove_infinite: bool,
    ) -> *mut open3d_geometry_PointCloud {
        open3d_geometry_PointCloud_RemoveNonFinitePoints(self, remove_nan, remove_infinite)
    }
    #[inline]
    pub unsafe fn RemoveDuplicatedPoints(&mut self) -> *mut open3d_geometry_PointCloud {
        open3d_geometry_PointCloud_RemoveDuplicatedPoints(self)
    }
    #[inline]
    pub unsafe fn SelectByIndex(&self, indices: *const std_vector, invert: bool) -> std_shared_ptr {
        open3d_geometry_PointCloud_SelectByIndex(self, indices, invert)
    }
    #[inline]
    pub unsafe fn VoxelDownSample(&self, voxel_size: f64) -> std_shared_ptr {
        open3d_geometry_PointCloud_VoxelDownSample(self, voxel_size)
    }
    #[inline]
    pub unsafe fn VoxelDownSampleAndTrace(
        &self,
        voxel_size: f64,
        min_bound: *const Eigen_Vector3d,
        max_bound: *const Eigen_Vector3d,
        approximate_class: bool,
    ) -> std_tuple {
        open3d_geometry_PointCloud_VoxelDownSampleAndTrace(
            self,
            voxel_size,
            min_bound,
            max_bound,
            approximate_class,
        )
    }
    #[inline]
    pub unsafe fn UniformDownSample(&self, every_k_points: usize) -> std_shared_ptr {
        open3d_geometry_PointCloud_UniformDownSample(self, every_k_points)
    }
    #[inline]
    pub unsafe fn RandomDownSample(&self, sampling_ratio: f64) -> std_shared_ptr {
        open3d_geometry_PointCloud_RandomDownSample(self, sampling_ratio)
    }
    #[inline]
    pub unsafe fn FarthestPointDownSample(&self, num_samples: usize) -> std_shared_ptr {
        open3d_geometry_PointCloud_FarthestPointDownSample(self, num_samples)
    }
    #[inline]
    pub unsafe fn Crop(
        &self,
        bbox: *const open3d_geometry_AxisAlignedBoundingBox,
    ) -> std_shared_ptr {
        open3d_geometry_PointCloud_Crop(self, bbox)
    }
    #[inline]
    pub unsafe fn Crop1(&self, bbox: *const open3d_geometry_OrientedBoundingBox) -> std_shared_ptr {
        open3d_geometry_PointCloud_Crop1(self, bbox)
    }
    #[inline]
    pub unsafe fn RemoveRadiusOutliers(
        &self,
        nb_points: usize,
        search_radius: f64,
        print_progress: bool,
    ) -> std_tuple {
        open3d_geometry_PointCloud_RemoveRadiusOutliers(
            self,
            nb_points,
            search_radius,
            print_progress,
        )
    }
    #[inline]
    pub unsafe fn RemoveStatisticalOutliers(
        &self,
        nb_neighbors: usize,
        std_ratio: f64,
        print_progress: bool,
    ) -> std_tuple {
        open3d_geometry_PointCloud_RemoveStatisticalOutliers(
            self,
            nb_neighbors,
            std_ratio,
            print_progress,
        )
    }
    #[inline]
    pub unsafe fn EstimateNormals(
        &mut self,
        search_param: *const open3d_geometry_KDTreeSearchParam,
        fast_normal_computation: bool,
    ) {
        open3d_geometry_PointCloud_EstimateNormals(self, search_param, fast_normal_computation)
    }
    #[inline]
    pub unsafe fn OrientNormalsToAlignWithDirection(
        &mut self,
        orientation_reference: *const Eigen_Vector3d,
    ) {
        open3d_geometry_PointCloud_OrientNormalsToAlignWithDirection(self, orientation_reference)
    }
    #[inline]
    pub unsafe fn OrientNormalsTowardsCameraLocation(
        &mut self,
        camera_location: *const Eigen_Vector3d,
    ) {
        open3d_geometry_PointCloud_OrientNormalsTowardsCameraLocation(self, camera_location)
    }
    #[inline]
    pub unsafe fn OrientNormalsConsistentTangentPlane(&mut self, k: usize) {
        open3d_geometry_PointCloud_OrientNormalsConsistentTangentPlane(self, k)
    }
    #[inline]
    pub unsafe fn ComputePointCloudDistance(
        &mut self,
        target: *const open3d_geometry_PointCloud,
    ) -> std_vector {
        open3d_geometry_PointCloud_ComputePointCloudDistance(self, target)
    }
    #[inline]
    pub unsafe fn EstimatePerPointCovariances(
        input: *const open3d_geometry_PointCloud,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    ) -> std_vector {
        open3d_geometry_PointCloud_EstimatePerPointCovariances(input, search_param)
    }
    #[inline]
    pub unsafe fn EstimateCovariances(
        &mut self,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    ) {
        open3d_geometry_PointCloud_EstimateCovariances(self, search_param)
    }
    #[inline]
    pub unsafe fn ComputeMeanAndCovariance(&self) -> std_tuple {
        open3d_geometry_PointCloud_ComputeMeanAndCovariance(self)
    }
    #[inline]
    pub unsafe fn ComputeMahalanobisDistance(&self) -> std_vector {
        open3d_geometry_PointCloud_ComputeMahalanobisDistance(self)
    }
    #[inline]
    pub unsafe fn ComputeNearestNeighborDistance(&self) -> std_vector {
        open3d_geometry_PointCloud_ComputeNearestNeighborDistance(self)
    }
    #[inline]
    pub unsafe fn ComputeConvexHull(&self, joggle_inputs: bool) -> std_tuple {
        open3d_geometry_PointCloud_ComputeConvexHull(self, joggle_inputs)
    }
    #[inline]
    pub unsafe fn HiddenPointRemoval(
        &self,
        camera_location: *const Eigen_Vector3d,
        radius: f64,
    ) -> std_tuple {
        open3d_geometry_PointCloud_HiddenPointRemoval(self, camera_location, radius)
    }
    #[inline]
    pub unsafe fn ClusterDBSCAN(
        &self,
        eps: f64,
        min_points: usize,
        print_progress: bool,
    ) -> std_vector {
        open3d_geometry_PointCloud_ClusterDBSCAN(self, eps, min_points, print_progress)
    }
    #[inline]
    pub unsafe fn SegmentPlane(
        &self,
        distance_threshold: f64,
        ransac_n: ::std::os::raw::c_int,
        num_iterations: ::std::os::raw::c_int,
        probability: f64,
    ) -> std_tuple {
        open3d_geometry_PointCloud_SegmentPlane(
            self,
            distance_threshold,
            ransac_n,
            num_iterations,
            probability,
        )
    }
    #[inline]
    pub unsafe fn DetectPlanarPatches(
        &self,
        normal_variance_threshold_deg: f64,
        coplanarity_deg: f64,
        outlier_ratio: f64,
        min_plane_edge_length: f64,
        min_num_points: usize,
        search_param: *const open3d_geometry_KDTreeSearchParam,
    ) -> std_vector {
        open3d_geometry_PointCloud_DetectPlanarPatches(
            self,
            normal_variance_threshold_deg,
            coplanarity_deg,
            outlier_ratio,
            min_plane_edge_length,
            min_num_points,
            search_param,
        )
    }
    #[inline]
    pub unsafe fn CreateFromDepthImage(
        depth: *const open3d_geometry_Image,
        intrinsic: *const open3d_camera_PinholeCameraIntrinsic,
        extrinsic: *const Eigen_Matrix4d,
        depth_scale: f64,
        depth_trunc: f64,
        stride: ::std::os::raw::c_int,
        project_valid_depth_only: bool,
    ) -> std_shared_ptr {
        open3d_geometry_PointCloud_CreateFromDepthImage(
            depth,
            intrinsic,
            extrinsic,
            depth_scale,
            depth_trunc,
            stride,
            project_valid_depth_only,
        )
    }
    #[inline]
    pub unsafe fn CreateFromRGBDImage(
        image: *const open3d_geometry_RGBDImage,
        intrinsic: *const open3d_camera_PinholeCameraIntrinsic,
        extrinsic: *const Eigen_Matrix4d,
        project_valid_depth_only: bool,
    ) -> std_shared_ptr {
        open3d_geometry_PointCloud_CreateFromRGBDImage(
            image,
            intrinsic,
            extrinsic,
            project_valid_depth_only,
        )
    }
    #[inline]
    pub unsafe fn CreateFromVoxelGrid(
        voxel_grid: *const open3d_geometry_VoxelGrid,
    ) -> std_shared_ptr {
        open3d_geometry_PointCloud_CreateFromVoxelGrid(voxel_grid)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud5ClearEv"]
    pub fn open3d_geometry_PointCloud_Clear(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud7IsEmptyEv"]
    pub fn open3d_geometry_PointCloud_IsEmpty(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud11GetMinBoundEv"]
    pub fn open3d_geometry_PointCloud_GetMinBound(
        this: *mut ::std::os::raw::c_void,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud11GetMaxBoundEv"]
    pub fn open3d_geometry_PointCloud_GetMaxBound(
        this: *mut ::std::os::raw::c_void,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud9GetCenterEv"]
    pub fn open3d_geometry_PointCloud_GetCenter(
        this: *mut ::std::os::raw::c_void,
    ) -> Eigen_Vector3d;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud25GetAxisAlignedBoundingBoxEv"]
    pub fn open3d_geometry_PointCloud_GetAxisAlignedBoundingBox(
        this: *mut ::std::os::raw::c_void,
    ) -> open3d_geometry_AxisAlignedBoundingBox;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud22GetOrientedBoundingBoxEb"]
    pub fn open3d_geometry_PointCloud_GetOrientedBoundingBox(
        this: *mut ::std::os::raw::c_void,
        robust: bool,
    ) -> open3d_geometry_OrientedBoundingBox;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6open3d8geometry10PointCloud29GetMinimalOrientedBoundingBoxEb"]
    pub fn open3d_geometry_PointCloud_GetMinimalOrientedBoundingBox(
        this: *mut ::std::os::raw::c_void,
        robust: bool,
    ) -> open3d_geometry_OrientedBoundingBox;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud9TransformERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEE"]
    pub fn open3d_geometry_PointCloud_Transform(
        this: *mut ::std::os::raw::c_void,
        transformation: *const Eigen_Matrix4d,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud9TranslateERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEEb"]
    pub fn open3d_geometry_PointCloud_Translate(
        this: *mut ::std::os::raw::c_void,
        translation: *const Eigen_Vector3d,
        relative: bool,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud5ScaleEdRKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_PointCloud_Scale(
        this: *mut ::std::os::raw::c_void,
        scale: f64,
        center: *const Eigen_Vector3d,
    ) -> *mut open3d_geometry_PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d8geometry10PointCloud6RotateERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEERKNS3_IdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_geometry_PointCloud_Rotate(
        this: *mut ::std::os::raw::c_void,
        R: *const Eigen_Matrix3d,
        center: *const Eigen_Vector3d,
    ) -> *mut open3d_geometry_PointCloud;
}
pub type open3d_utility_Matrix4d_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Matrix6d_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Vector2d_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Vector3uint8_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Vector4i_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Vector4d_allocator = Eigen_aligned_allocator;
pub type open3d_utility_Vector6d_allocator = Eigen_aligned_allocator;
extern "C" {
    #[doc = " Genretate a skew-symmetric matrix from a vector 3x1."]
    #[link_name = "\u{1}_ZN6open3d7utility10SkewMatrixERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_utility_SkewMatrix(vec: *const Eigen_Vector3d) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Function to transform 6D motion vector to 4D motion matrix\n Reference:\n https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html#TutorialGeoTransform"]
    #[link_name = "\u{1}_ZN6open3d7utility27TransformVector6dToMatrix4dERKN5Eigen6MatrixIdLi6ELi1ELi0ELi6ELi1EEE"]
    pub fn open3d_utility_TransformVector6dToMatrix4d(
        input: *const Eigen_Vector6d,
    ) -> Eigen_Matrix4d;
}
extern "C" {
    #[doc = " Function to transform 4D motion matrix to 6D motion vector\n this is consistent with the matlab function in\n the Aerospace Toolbox\n Reference:\n https://github.com/qianyizh/ElasticReconstruction/blob/master/Matlab_Toolbox/Core/mrEvaluateRegistration.m"]
    #[link_name = "\u{1}_ZN6open3d7utility27TransformMatrix4dToVector6dERKN5Eigen6MatrixIdLi4ELi4ELi0ELi4ELi4EEE"]
    pub fn open3d_utility_TransformMatrix4dToVector6d(
        input: *const Eigen_Matrix4d,
    ) -> Eigen_Vector6d;
}
extern "C" {
    #[doc = " Function to solve Ax=b"]
    #[link_name = "\u{1}_ZN6open3d7utility20SolveLinearSystemPSDERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEERKNS2_IdLin1ELi1ELi0ELin1ELi1EEEbbbb"]
    pub fn open3d_utility_SolveLinearSystemPSD(
        A: *const Eigen_MatrixXd,
        b: *const Eigen_VectorXd,
        prefer_sparse: bool,
        check_symmetric: bool,
        check_det: bool,
        check_psd: bool,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " Function to solve Jacobian system\n Input: 6x6 Jacobian matrix and 6-dim residual vector.\n Output: tuple of is_success, 4x4 extrinsic matrices."]
    #[link_name = "\u{1}_ZN6open3d7utility43SolveJacobianSystemAndObtainExtrinsicMatrixERKN5Eigen6MatrixIdLi6ELi6ELi0ELi6ELi6EEERKNS2_IdLi6ELi1ELi0ELi6ELi1EEE"]
    pub fn open3d_utility_SolveJacobianSystemAndObtainExtrinsicMatrix(
        JTJ: *const Eigen_Matrix6d,
        JTr: *const Eigen_Vector6d,
    ) -> std_tuple;
}
extern "C" {
    #[doc = " Function to solve Jacobian system\n Input: 6nx6n Jacobian matrix and 6n-dim residual vector.\n Output: tuple of is_success, n 4x4 motion matrices."]
    #[link_name = "\u{1}_ZN6open3d7utility48SolveJacobianSystemAndObtainExtrinsicMatrixArrayERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEERKNS2_IdLin1ELi1ELi0ELin1ELi1EEE"]
    pub fn open3d_utility_SolveJacobianSystemAndObtainExtrinsicMatrixArray(
        JTJ: *const Eigen_MatrixXd,
        JTr: *const Eigen_VectorXd,
    ) -> std_tuple;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utility15RotationMatrixXEd"]
    pub fn open3d_utility_RotationMatrixX(radians: f64) -> Eigen_Matrix3d;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utility15RotationMatrixYEd"]
    pub fn open3d_utility_RotationMatrixY(radians: f64) -> Eigen_Matrix3d;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utility15RotationMatrixZEd"]
    pub fn open3d_utility_RotationMatrixZ(radians: f64) -> Eigen_Matrix3d;
}
extern "C" {
    #[doc = " Color conversion from double [0,1] to uint8_t 0-255; this does proper\n clipping and rounding"]
    #[link_name = "\u{1}_ZN6open3d7utility12ColorToUint8ERKN5Eigen6MatrixIdLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_utility_ColorToUint8(color: *const Eigen_Vector3d) -> Eigen_Vector3uint8;
}
extern "C" {
    #[doc = " Color conversion from uint8_t 0-255 to double [0,1]"]
    #[link_name = "\u{1}_ZN6open3d7utility13ColorToDoubleEhhh"]
    pub fn open3d_utility_ColorToDouble(r: u8, g: u8, b: u8) -> Eigen_Vector3d;
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utility13ColorToDoubleERKN5Eigen6MatrixIhLi3ELi1ELi0ELi3ELi1EEE"]
    pub fn open3d_utility_ColorToDouble1(rgb: *const Eigen_Vector3uint8) -> Eigen_Vector3d;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_utility_in_place_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_open3d_utility_in_place_t() {
    assert_eq!(
        ::std::mem::size_of::<open3d_utility_in_place_t>(),
        1usize,
        concat!("Size of: ", stringify!(open3d_utility_in_place_t))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_utility_in_place_t>(),
        1usize,
        concat!("Alignment of ", stringify!(open3d_utility_in_place_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utilityL8in_placeE"]
    pub static open3d_utility_in_place: open3d_utility_in_place_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_utility_detail__has_overloaded_addressof {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_utility_trivial_init_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_open3d_utility_trivial_init_t() {
    assert_eq!(
        ::std::mem::size_of::<open3d_utility_trivial_init_t>(),
        1usize,
        concat!("Size of: ", stringify!(open3d_utility_trivial_init_t))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_utility_trivial_init_t>(),
        1usize,
        concat!("Alignment of ", stringify!(open3d_utility_trivial_init_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utilityL12trivial_initE"]
    pub static open3d_utility_trivial_init: open3d_utility_trivial_init_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_utility_nullopt_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_utility_nullopt_t_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_open3d_utility_nullopt_t_init() {
    assert_eq!(
        ::std::mem::size_of::<open3d_utility_nullopt_t_init>(),
        1usize,
        concat!("Size of: ", stringify!(open3d_utility_nullopt_t_init))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_utility_nullopt_t_init>(),
        1usize,
        concat!("Alignment of ", stringify!(open3d_utility_nullopt_t_init))
    );
}
#[test]
fn bindgen_test_layout_open3d_utility_nullopt_t() {
    assert_eq!(
        ::std::mem::size_of::<open3d_utility_nullopt_t>(),
        1usize,
        concat!("Size of: ", stringify!(open3d_utility_nullopt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_utility_nullopt_t>(),
        1usize,
        concat!("Alignment of ", stringify!(open3d_utility_nullopt_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6open3d7utilityL7nulloptE"]
    pub static open3d_utility_nullopt: open3d_utility_nullopt_t;
}
#[repr(C)]
pub struct open3d_utility_bad_optional_access {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_open3d_utility_bad_optional_access() {
    assert_eq!(
        ::std::mem::size_of::<open3d_utility_bad_optional_access>(),
        16usize,
        concat!("Size of: ", stringify!(open3d_utility_bad_optional_access))
    );
    assert_eq!(
        ::std::mem::align_of::<open3d_utility_bad_optional_access>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(open3d_utility_bad_optional_access)
        )
    );
}
#[repr(C)]
pub union open3d_utility_storage_t<T> {
    pub dummy_: ::std::os::raw::c_uchar,
    pub value_: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub union open3d_utility_constexpr_storage_t<T> {
    pub dummy_: ::std::os::raw::c_uchar,
    pub value_: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct open3d_utility_optional_base<T> {
    pub init_: bool,
    pub storage_: open3d_utility_storage_t<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct open3d_utility_constexpr_optional_base<T> {
    pub init_: bool,
    pub storage_: open3d_utility_constexpr_storage_t<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type open3d_utility_OptionalBase = u8;
#[repr(C)]
#[derive(Debug)]
pub struct open3d_utility_optional {
    pub _address: u8,
}
pub type open3d_utility_optional_OptionalBase = u8;
pub type open3d_utility_optional_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open3d_camera_PinholeCameraIntrinsic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_42 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u16>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios<::std::os::raw::c_char>>(),
        264usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream<::std::os::raw::c_char>>(),
        272usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream<::std::os::raw::c_char>>(),
        288usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringbuf<::std::os::raw::c_char>>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringbuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringbuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringbuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istringstream<::std::os::raw::c_char>>(),
        384usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostringstream<::std::os::raw::c_char>>(),
        376usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringstream<::std::os::raw::c_char>>(),
        392usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringstream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringstream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringstream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ios<u32>>(),
        264usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ios<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ios<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ios<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<u32>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostream<u32>>(),
        272usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_iostream<u32>>(),
        288usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_iostream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_iostream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_iostream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringbuf<u32>>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringbuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringbuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringbuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istringstream<u32>>(),
        384usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istringstream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_ostringstream<u32>>(),
        376usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_ostringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_ostringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_ostringstream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_stringstream<u32>>(),
        392usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_stringstream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_stringstream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_stringstream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char16_t_std_char_traits_open2_char16_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char32_t_std_char_traits_open2_char32_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<u32>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_istream<u32>>(),
        280usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_istream<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_istream<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u16>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u16>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char16_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char32_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type size_type = size_type;
pub type size_type = usize;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_32() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_33() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_32() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_34() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_33() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
pub type char_type = ::std::os::raw::c_char;
pub type int_type = int_type;
pub type int_type = ::std::os::raw::c_int;
pub type char_type = u32;
pub type int_type = int_type;
pub type int_type = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_35() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_36() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_34() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_35() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_37() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_38() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_39() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_40() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_36() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_37() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_38() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_39() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_long_double_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<u128>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<u128>>(),
        16usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<u128>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_55 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_56 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_57 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_pair_open0_bool__std_size_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<bool, usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<bool, usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_bool__std_size_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<bool, usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<bool, usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_random_access_iterator_tag_bool__long_ptr_bool_ref_bool_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
pub type iterator = std__Bit_iterator;
pub type size_type = usize;
pub type iterator = std__Bit_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_58 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_equal_to_open0_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_41() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_float_Eigen_half_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_int_Eigen_half_close0_instantiation_1()
{
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_internal_scalar_cast_op_open0_Eigen_half_float_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_scalar_cast_op>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_internal_scalar_cast_op)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_59 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_60 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_61 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_62 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_63 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_64 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_32() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_33() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_34() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_35() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_36() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_37() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_38() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_39() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_40() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_32() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_33() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_34() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_35() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_36() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_37() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_38() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_39() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_41() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_42() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_43() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_44() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_45() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_46() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_47() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_48() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_49() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_50() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_51() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_52() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_53() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_float_close0_instantiation_54() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_40() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_41() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_42() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_43() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_44() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_45() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_46() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_47() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_48() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_49() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_50() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_51() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_52() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_complex_open0_double_close0_instantiation_53() {
    assert_eq!(
        ::std::mem::size_of::<std_complex<f64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_complex<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_complex<f64>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_65 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_66 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_67 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_68 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_69 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_70 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_71 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_72 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_73 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_74 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_75 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_76 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_77 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_78 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_79 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Eigen_UniformScaling_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_UniformScaling<f32>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_UniformScaling<f32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_UniformScaling<f32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_UniformScaling<f32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Eigen_UniformScaling_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_UniformScaling<f64>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Eigen_UniformScaling<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_UniformScaling<f64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Eigen_UniformScaling<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Matrix3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_10(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Matrix3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_11(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_10(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_12(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Matrix3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_13(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_11(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_14(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_12(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_15(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Vector3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_13(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_16(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_Eigen_Matrix3d_std_allocator_open1_Eigen_Matrix_open2_double_close2_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_Eigen_Matrix_open1_double_close1_close0_instantiation_17(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
